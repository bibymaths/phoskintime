#!/usr/bin/env python3
"""
Publication-grade visualization for Kinopt network readouts (minimal titles),
with requested annotations and EGFR DAG layout.

Inputs (generated by kinopt_network_readout.py):
  - out/kinopt_kinase_load.csv
  - out/kinopt_target_dominant_kinases.csv
  - out/kinopt_knockout_effects.csv

Outputs:
  - out/figures/*.pdf and *.svg

Enhancements in this version:
1) Observed vs reconstructed target magnitude:
   - Draw 95% parallel band around identity line: y = x ± delta95
   - Label outliers (points outside band) with "Gene Psite"
2) Kinase breadth vs control load:
   - Label kinases with control load > 2
3) EGFR control logic:
   - Render as a DAG with DOT layout if available (pydot/graphviz),
     otherwise fall back to a layered bipartite layout.
"""

from __future__ import annotations

from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import networkx as nx
from networkx.drawing.nx_pydot import write_dot

IN_DIR = Path("./results_scripts/figures_kinopt")
FIG_DIR = IN_DIR
FIG_DIR.mkdir(parents=True, exist_ok=True)

KINASE_LOAD_CSV = IN_DIR / "kinopt_kinase_load.csv"
TARGET_DOM_CSV = IN_DIR / "kinopt_target_dominant_kinases.csv"
KNOCKOUT_CSV = IN_DIR / "kinopt_knockout_effects.csv"

# Annotation thresholds
KINASE_LABEL_LOAD_THRESHOLD = 1.0
OUTLIER_BAND_QUANTILE = 0.95
OUTLIER_MAX_LABELS = 5


# -----------------------------
# Style
# -----------------------------
def set_pub_style():
    plt.rcParams.update({
        "figure.dpi": 160,
        "savefig.dpi": 300,
        "font.size": 8,
        "axes.labelsize": 8,
        "axes.titlesize": 9,
        "legend.fontsize": 7,
        "xtick.labelsize": 7,
        "ytick.labelsize": 7,
        "axes.linewidth": 0.7,
        "lines.linewidth": 1.2,
        "grid.linewidth": 0.4,
        "grid.alpha": 0.25,
        "pdf.fonttype": 42,
        "ps.fonttype": 42,
    })


def savefig(basepath: Path):
    plt.tight_layout()
    # plt.savefig(basepath.with_suffix(".pdf"), bbox_inches="tight")
    plt.savefig(basepath.with_suffix(".png"), bbox_inches="tight")
    plt.close()


def require_cols(df: pd.DataFrame, cols: list[str], name: str):
    missing = [c for c in cols if c not in df.columns]
    if missing:
        raise ValueError(f"{name} missing columns: {missing}\nHave: {list(df.columns)}")


def light_xgrid():
    plt.grid(axis="x", alpha=0.25, linewidth=0.6)


def density_hist(values: np.ndarray, bins: int = 40):
    hist, edges = np.histogram(values, bins=bins, density=True)
    centers = 0.5 * (edges[:-1] + edges[1:])
    return centers, hist


# -----------------------------
# Small plotting utilities
# -----------------------------
def top_n_barh(
        df: pd.DataFrame,
        value_col: str,
        label_col: str,
        n: int,
        title: str,
        xlabel: str,
        outname: str,
        annotate: callable | None = None,
        xlim: tuple[float, float] | None = None,
):
    d = df.sort_values(value_col, ascending=False).head(n).copy()
    d = d.iloc[::-1]

    plt.figure(figsize=(6.2, max(2.4, 0.22 * len(d) + 1.4)))
    y = np.arange(len(d))
    plt.barh(y, d[value_col].astype(float))
    plt.yticks(y, d[label_col].astype(str))
    plt.title(title)
    plt.xlabel(xlabel)
    light_xgrid()
    if xlim is not None:
        plt.xlim(*xlim)

    if annotate is not None:
        for i, (_, r) in enumerate(d.iterrows()):
            annotate(i, r)

    savefig(FIG_DIR / outname)


# -----------------------------
# Plot set 1: kinase-level
# -----------------------------
def plot_kinase_load(kl: pd.DataFrame):
    require_cols(
        kl,
        ["Kinase", "n_targets", "total_load_auc_abs", "frac_beta_at_bound", "latent_auc_abs", "latent_peak_abs"],
        "kinopt_kinase_load.csv",
    )

    # A) Top kinases by control load
    top_n_barh(
        kl, "total_load_auc_abs", "Kinase",
        n=min(25, len(kl)),
        title="Kinase control load",
        xlabel="Total routed activity",
        outname="kinase_control_load_top",
    )

    # B) Breadth vs load + labels for load > threshold
    plt.figure(figsize=(5.6, 4.3))
    x = kl["n_targets"].astype(float).to_numpy()
    y = kl["total_load_auc_abs"].astype(float).to_numpy()
    plt.scatter(x, y, s=20, alpha=0.85)
    plt.title("Kinase breadth vs control load")
    plt.xlabel("Number of targets")
    plt.ylabel("Control load")
    plt.grid(alpha=0.25, linewidth=0.6)

    # Label only kinases above threshold
    mask = y > KINASE_LABEL_LOAD_THRESHOLD
    for kin, xi, yi in zip(kl["Kinase"].astype(str), x, y):
        if yi > KINASE_LABEL_LOAD_THRESHOLD:
            plt.annotate(kin, (xi, yi), fontsize=7, xytext=(3, 3), textcoords="offset points", alpha=0.9)

    savefig(FIG_DIR / "kinase_breadth_vs_load")

    # C) Constraint pressure vs load
    plt.figure(figsize=(5.6, 4.3))
    plt.scatter(kl["frac_beta_at_bound"].astype(float), kl["total_load_auc_abs"].astype(float), s=20, alpha=0.85)
    plt.title("Constraint pressure vs control load")
    plt.xlabel("Fraction of β at bounds")
    plt.ylabel("Control load")
    plt.grid(alpha=0.25, linewidth=0.6)
    savefig(FIG_DIR / "kinase_boundpressure_vs_load")


# -----------------------------
# Plot set 2: target-level
# -----------------------------
def plot_target_fragility(td: pd.DataFrame):
    require_cols(
        td,
        ["Gene", "Psite", "n_kinases", "dominant_overall", "dominant_overall_share", "pred_auc_abs", "obs_auc_abs"],
        "kinopt_target_dominant_kinases.csv",
    )

    # A) Dominance distribution
    vals = td["dominant_overall_share"].dropna().astype(float).to_numpy()
    centers, dens = density_hist(vals, bins=35)
    plt.figure(figsize=(5.6, 3.6))
    plt.plot(centers, dens)
    plt.xlabel("Fraction of signal explained by top kinase")
    plt.ylabel("Density")
    plt.title("Target control dominance")
    plt.grid(alpha=0.25, linewidth=0.6)
    savefig(FIG_DIR / "target_control_dominance_distribution")

    # B) Most fragile targets
    top = td.sort_values("dominant_overall_share", ascending=False).head(min(25, len(td))).copy()
    top["Target"] = top["Gene"].astype(str) + " " + top["Psite"].astype(str)

    def _ann(i, r):
        x = float(r["dominant_overall_share"])
        dom = str(r["dominant_overall"])
        n = int(r["n_kinases"])
        plt.text(min(x + 0.015, 1.02), i, f"{dom} (n={n})", va="center", fontsize=7)

    top_n_barh(
        top,
        value_col="dominant_overall_share",
        label_col="Target",
        n=len(top),
        title="Most fragile targets",
        xlabel="Dominance",
        outname="target_fragility_top",
        annotate=_ann,
        xlim=(0, 1.05),
    )

    # C) Observed vs reconstructed magnitude:
    #    - identity line only
    #    - label points with pred > obs

    d = td.dropna(subset=["pred_auc_abs", "obs_auc_abs"]).copy()
    d["obs"] = d["obs_auc_abs"].astype(float)
    d["pred"] = d["pred_auc_abs"].astype(float)
    d["label"] = d["Gene"].astype(str) + " " + d["Psite"].astype(str)

    # Distance to identity line y=x (perpendicular distance; scaling not important for quantile)
    d["perp_dist"] = np.abs(d["pred"] - d["obs"]) / np.sqrt(2)

    # 95% parallel band threshold around identity
    thr = np.quantile(d["perp_dist"].to_numpy(), OUTLIER_BAND_QUANTILE)
    offset = thr * np.sqrt(2)  # convert back to vertical offset for y = x ± offset

    # Label outliers: points outside the 95% band
    # label only points that fall within the 95% parallel band to identity
    in_band = d[d["perp_dist"] <= thr].copy()
    label_df = in_band.sort_values("perp_dist", ascending=True).head(OUTLIER_MAX_LABELS)

    plt.figure(figsize=(5.2, 4.1))
    plt.scatter(d["obs"], d["pred"], s=20, alpha=0.85)

    mx = float(np.nanmax(np.r_[d["obs"].to_numpy(), d["pred"].to_numpy(), 1e-9]))
    xline = np.array([0.0, mx])

    # identity through origin + 95% parallel band
    plt.plot(xline, xline, linewidth=1.0, color="black")
    plt.plot(xline, xline + offset, linewidth=0.8, alpha=0.5, color="black")
    plt.plot(xline, xline - offset, linewidth=0.8, alpha=0.5, color="black")

    # show only non-negative quadrant and keep 45° identity
    plt.xlim(0.0, mx)
    plt.ylim(0.0, mx)
    plt.gca().set_aspect("equal", adjustable="box")

    for _, r in label_df.iterrows():
        plt.annotate(
            r["label"],
            (r["obs"], r["pred"]),
            fontsize=5,
            xytext=(3, 3),
            textcoords="offset fontsize",
            alpha=0.9,
        )

    plt.xlabel("Observed signal magnitude")
    plt.ylabel("Reconstructed signal magnitude")
    plt.title("Observed vs reconstructed target magnitude")
    plt.grid(alpha=0.25, linewidth=0.6)

    savefig(FIG_DIR / "target_obs_vs_reconstructed_magnitude")


# -----------------------------
# Plot set 3: knockout landscape
# -----------------------------
def plot_knockout_effects(ko: pd.DataFrame):
    require_cols(
        ko,
        ["Gene", "Psite", "KnockedKinase", "delta_auc_abs", "delta_peak_abs", "ko_rank_site"],
        "kinopt_knockout_effects.csv",
    )

    vals = ko["delta_auc_abs"].dropna().astype(float).to_numpy()
    centers, dens = density_hist(vals, bins=45)
    plt.figure(figsize=(5.6, 3.6))
    plt.plot(centers, dens)
    plt.axvline(0.0, linewidth=1.0)
    plt.xlabel("Change in reconstructed signal")
    plt.ylabel("Density")
    plt.title("Distribution of kinase knockout effects")
    plt.grid(alpha=0.25, linewidth=0.6)
    plt.text(
        0.02, 0.95, "Right: activating\nLeft: suppressing",
        transform=plt.gca().transAxes, fontsize=7, va="top"
    )
    savefig(FIG_DIR / "knockout_effect_distribution")

    d = ko.copy()
    d["Edge"] = d["Gene"].astype(str) + " " + d["Psite"].astype(str) + " \u2190 " + d["KnockedKinase"].astype(str)

    top_pos = d.sort_values("delta_auc_abs", ascending=False).head(20).copy()
    top_neg = d.sort_values("delta_auc_abs", ascending=True).head(20).copy()

    top_n_barh(
        top_pos, "delta_auc_abs", "Edge", n=len(top_pos),
        title="Strongest activating edges",
        xlabel="Change in reconstructed signal",
        outname="knockout_top_activating",
    )
    top_n_barh(
        top_neg, "delta_auc_abs", "Edge", n=len(top_neg),
        title="Strongest suppressing edges",
        xlabel="Change in reconstructed signal",
        outname="knockout_top_suppressing",
    )


# -----------------------------
# EGFR control logic (EGFR → phosphosite → kinase), Graphviz only
# -----------------------------
def _sanitize_id(prefix: str, name: str) -> str:
    s = str(name).strip().replace(" ", "_").replace(":", "_").replace("/", "_")
    return f"{prefix}__{s}"


def graphviz_dot_layout(G: nx.DiGraph) -> dict[str, tuple[float, float]]:
    from networkx.drawing.nx_pydot import to_pydot, graphviz_layout  # type: ignore

    P = to_pydot(G)
    if not P.get_nodes():
        raise RuntimeError("Graphviz DOT conversion failed (0 nodes).")

    pos = graphviz_layout(G, prog="dot")
    if len(pos) != G.number_of_nodes():
        raise RuntimeError("Graphviz DOT layout incomplete.")
    return pos


def plot_egfr_control_logic_dag(ko: pd.DataFrame, td: pd.DataFrame):
    eg = ko[ko["Gene"].astype(str) == "EGFR"].copy()
    if eg.empty:
        raise ValueError("No EGFR rows found in knockout CSV.")

    eg["abs_delta"] = eg["delta_auc_abs"].abs()
    eg = eg[eg["abs_delta"] > 1e-10]

    TOPK_PER_SITE = 17
    eg = (
        eg.sort_values(["Psite", "abs_delta"], ascending=[True, False])
        .groupby("Psite", as_index=False)
        .head(TOPK_PER_SITE)
    )

    # Nodes
    egfr_id = "EGFR"
    site_nodes = sorted(eg["Psite"].astype(str).unique())
    kinase_nodes = sorted(eg["KnockedKinase"].astype(str).unique())

    site_ids = {_sanitize_id("site", s): s for s in site_nodes}
    kin_ids = {_sanitize_id("kin", k): k for k in kinase_nodes}

    G = nx.DiGraph()

    # Graphviz layout hints
    G.graph["graph"] = {"rankdir": "LR", "splines": "true", "nodesep": "0.25", "ranksep": "0.4"}

    # Add nodes
    G.add_node(egfr_id, kind="protein")

    for sid in site_ids:
        G.add_node(sid, kind="psite")

    for kid in kin_ids:
        G.add_node(kid, kind="kinase")

    # EGFR → phosphosite edges (structural, no sign/weight)
    for sid in site_ids:
        G.add_edge(egfr_id, sid, weight=0.5, sign=1)

    # phosphosite → kinase edges (KO-derived logic)
    for _, r in eg.iterrows():
        sid = _sanitize_id("site", r["Psite"])
        kid = _sanitize_id("kin", r["KnockedKinase"])
        w = float(abs(r["delta_auc_abs"]))
        sign = 1 if r["delta_auc_abs"] > 0 else -1
        G.add_edge(sid, kid, weight=w, sign=sign)

    # DAG sanity
    if not nx.is_directed_acyclic_graph(G):
        raise ValueError("EGFR control graph is not a DAG.")

    # Layout
    pos = graphviz_dot_layout(G)

    # Edge width scaling
    weights = np.array([G.edges[e]["weight"] for e in G.edges if G.edges[e]["weight"] > 0])
    w_min, w_max = weights.min(), weights.max()

    def w_scale(w):
        if w_max - w_min < 1e-12:
            return 2.0
        return 0.6 + 3.4 * (w - w_min) / (w_max - w_min)

    # Plot
    plt.figure(figsize=(11.0, max(4.5, 0.32 * len(G.nodes()) + 1.2)))

    # Draw nodes by type
    def draw_nodes(node_ids, marker, size):
        xy = np.array([pos[n] for n in node_ids])
        plt.scatter(xy[:, 0], xy[:, 1], s=size, marker=marker)

    draw_nodes([egfr_id], marker="D", size=220)
    draw_nodes(list(site_ids.keys()), marker="o", size=160)
    draw_nodes(list(kin_ids.keys()), marker="s", size=160)

    # Labels
    x, y = pos[egfr_id]
    plt.text(x - 0.1, y, "EGFR", ha="right", va="center", fontsize=9, fontweight="bold")

    for sid, s in site_ids.items():
        x, y = pos[sid]
        plt.text(x - 0.08, y, s, ha="right", va="center", fontsize=8)

    for kid, k in kin_ids.items():
        x, y = pos[kid]
        plt.text(x + 0.08, y, k, ha="left", va="center", fontsize=8)

    # Edges
    for u, v in G.edges:
        x1, y1 = pos[u]
        x2, y2 = pos[v]
        w = w_scale(G.edges[(u, v)]["weight"])
        ls = "-" if G.edges[(u, v)]["sign"] > 0 else "--"
        plt.plot([x1, x2], [y1, y2], linewidth=w, linestyle=ls, alpha=0.85)

    plt.axis("off")
    plt.title("EGFR phosphosite control logic")
    plt.text(
        0.01, 0.01,
        "EGFR → phosphosite → kinase · Width ∝ |knockout effect| · Solid: activating · Dashed: inhibitory",
        transform=plt.gca().transAxes, fontsize=7, ha="left", va="bottom"
    )

    savefig(FIG_DIR / "EGFR_control_logic_diagram")


# -----------------------------
# Main
# -----------------------------
def main():
    set_pub_style()

    kl = pd.read_csv(KINASE_LOAD_CSV)
    td = pd.read_csv(TARGET_DOM_CSV)
    ko = pd.read_csv(KNOCKOUT_CSV)

    plot_kinase_load(kl)
    plot_target_fragility(td)
    plot_knockout_effects(ko)
    plot_egfr_control_logic_dag(ko, td)

    print("Wrote figures to:", FIG_DIR.resolve())


if __name__ == "__main__":
    main()
