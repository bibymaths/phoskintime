{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"PhosKinTime Documentation Welcome to the official documentation for PhosKinTime , an ODE-based modeling toolkit for phosphorylation kinetics and transcriptional time-series analysis. This index page provides an overview of each package and submodule in the project. Acknowledgments This project originated as part of my master's thesis work at Theoretical Biophysics group ( now, Klipp-Linding Lab ), Humboldt Universit\u00e4t zu Berlin. Conceptual framework and mathematical modeling were developed under the supervision of Prof. Dr. Dr. H.C. Edda Klipp . Experimental datasets were provided by the (Retd. Prof.) Dr. Rune Linding . The subpackage tfopt is an optimized and efficient derivative of original work by my colleague Julius Normann , adapted with permission. I am especially grateful to Ivo Maintz for his generous technical support, enabling seamless experimentation with packages and server setups. The package is built on the shoulders of giants, leveraging the power of NumPy , SciPy , Matplotlib , and Pandas for numerical computations and data handling. The package also utilizes Numba for JIT compilation, enhancing performance for computationally intensive tasks. The package is designed to be compatible with Python 3.8+ and is tested on various platforms, including Windows, macOS, and Linux. Overview PhosKinTime integrates: Parameter estimation Mechanistic ODE models (distributive, successive, random) Steady-state computation Morris sensitivity analysis Static and interactive visualization Modular design for extensibility PhosKinTime uses ordinary differential equations (ODEs) to model phosphorylation kinetics and supports multiple mechanistic hypotheses, including: Distributive Model: Phosphorylation events occur independently. Successive Model: Phosphorylation events occur sequentially. Random Model: Phosphorylation events occur in a random manner. Core Modules config Holds global constants, CLI parsing, and logging setup. models Implements ODE systems for different phosphorylation hypotheses. models Parameter estimation routines for ODE models. steady Computes steady-state initial conditions for each model. sensitivity Morris sensitivity analysis for parameter sensitivity. plotting Visualization tools for plotting results. utils Helper functions for data loading, saving, and plotting. Optimization Frameworks kinopt The kinopt package provides advanced optimization and post-processing: evol Global evolutionary optimization using pymoo (DE, NSGA-II): Problem formulation, data construction, exporter for Excel and plots local Local constrained optimization using SciPy solvers (SLSQP, TRUST-CONSTR) with Numba-accelerated objectives optimality Post-optimization analysis: feasibility checks, sensitivity reporting, LaTeX table generation, diagnostic plots fitanalysis Additional fit-evaluation utilities for residual and performance analysis tfopt Originally implemented by Julius Normann. This version has been modified and optimized by Abhinav Mishra. The tfopt package estimates transcriptional regulation using mRNA and TF time-series data through constrained optimization. evol Global evolutionary optimization using pymoo (NSGA-II, AGEMOEA, SMSEMOA): Multi-objective loss (fit error, \u03b1 and \u03b2 constraint violations) Parallel evaluation, Excel export, and HTML/plot reports local Local constrained optimization using SciPy solvers (SLSQP): Fast deterministic optimization under linear constraints Numba-accelerated objectives, identical output and reports as evol objfn Shared objective logic and prediction functions for both backends optcon Data construction and constraint generation from TF\u2013mRNA interaction files utils Input parsing, Excel + plot output, and HTML report generation Command-Line Entry Point for the Phoskintime Pipeline The phoskintime pipeline provides a command-line interface to execute various stages of the workflow, including preprocessing, optimization, and modeling. Below are the usage instructions and examples for running the pipeline. Before running any commands, ensure you are in the working directory one level above the project root (where the project directory is visible). Run All Stages Run the entire pipeline with the default (local) solver: python phoskintime all Run Preprocessing Only Execute only the preprocessing stage: python phoskintime prep Run Transcription-Factor-mRNA Optimization (TFOPT) Run TFOPT with the local solver: python phoskintime tfopt --mode local Run TFOPT with the evolutionary solver: python phoskintime tfopt --mode evol Run Kinase-Phosphorylation Optimization (KINOPT) Run KINOPT with the local solver: python phoskintime kinopt --mode local Run KINOPT with the evolutionary solver: python phoskintime kinopt --mode evol Run the Model Execute the modeling stage: python phoskintime model Quick Start: Setting up environment This guide provides clean setup instructions for running the phoskintime package on a new machine. Choose the scenario that best fits your environment and preferences. Before proceeding, ensure you have the following prerequisites installed: graphviz (for generating diagrams) # For Debian/Ubuntu sudo apt-get install graphviz # For Fedora sudo dnf install graphviz # For MacOS brew install graphviz python 3.10 or higher # Check python version python3 --version # If not installed, install python 3.10 or higher # For Debian/Ubuntu sudo apt-get install python3.10 # For Fedora sudo dnf install python3.10 # For MacOS brew install python@3.10 git (for cloning the repository) # For Debian/Ubuntu sudo apt-get install git # For Fedora sudo dnf install git # For MacOS brew install git Scenario 1: pip + virtualenv (Debian/Ubuntu/Fedora) For Debian/Ubuntu sudo apt update && sudo apt install -y python3 python3-pip python3-venv git For Fedora sudo dnf install -y python3 python3-pip python3-virtualenv git Setup git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create and activate a virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install --upgrade pip pip install -r requirements.txt Scenario 2: Poetry + pyproject.toml Install Poetry (all platforms) curl -sSL https://install.python-poetry.org | python3 - # Or: pip install poetry Setup git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Install dependencies poetry install # Optional: activate shell within poetry env poetry shell Scenario 3: Using uv (fast, isolated pip alternative) Install uv curl -LsSf https://astral.sh/uv/install.sh | sh Setup git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create virtual environment and install deps fast uv venv source .venv/bin/activate uv pip install -r requirements.txt Scenario 4: Conda or Mamba (Anaconda/Miniconda users) Setup git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create and activate conda environment conda create -n phoskintime python=3.10 -y conda activate phoskintime # Install dependencies pip install -r requirements.txt Or if using pyproject.toml , add: pip install poetry poetry install For making illustration diagrams, you need to install Graphviz. You can do this via conda or apt-get: conda install graphviz or apt-get install graphviz or download it from the Graphviz website . For macusers, you can use Homebrew: brew install graphviz","title":"Home"},{"location":"index.html#phoskintime-documentation","text":"Welcome to the official documentation for PhosKinTime , an ODE-based modeling toolkit for phosphorylation kinetics and transcriptional time-series analysis. This index page provides an overview of each package and submodule in the project.","title":"PhosKinTime Documentation"},{"location":"index.html#acknowledgments","text":"This project originated as part of my master's thesis work at Theoretical Biophysics group ( now, Klipp-Linding Lab ), Humboldt Universit\u00e4t zu Berlin. Conceptual framework and mathematical modeling were developed under the supervision of Prof. Dr. Dr. H.C. Edda Klipp . Experimental datasets were provided by the (Retd. Prof.) Dr. Rune Linding . The subpackage tfopt is an optimized and efficient derivative of original work by my colleague Julius Normann , adapted with permission. I am especially grateful to Ivo Maintz for his generous technical support, enabling seamless experimentation with packages and server setups. The package is built on the shoulders of giants, leveraging the power of NumPy , SciPy , Matplotlib , and Pandas for numerical computations and data handling. The package also utilizes Numba for JIT compilation, enhancing performance for computationally intensive tasks. The package is designed to be compatible with Python 3.8+ and is tested on various platforms, including Windows, macOS, and Linux.","title":"Acknowledgments"},{"location":"index.html#overview","text":"PhosKinTime integrates: Parameter estimation Mechanistic ODE models (distributive, successive, random) Steady-state computation Morris sensitivity analysis Static and interactive visualization Modular design for extensibility PhosKinTime uses ordinary differential equations (ODEs) to model phosphorylation kinetics and supports multiple mechanistic hypotheses, including: Distributive Model: Phosphorylation events occur independently. Successive Model: Phosphorylation events occur sequentially. Random Model: Phosphorylation events occur in a random manner.","title":"Overview"},{"location":"index.html#core-modules","text":"config Holds global constants, CLI parsing, and logging setup. models Implements ODE systems for different phosphorylation hypotheses. models Parameter estimation routines for ODE models. steady Computes steady-state initial conditions for each model. sensitivity Morris sensitivity analysis for parameter sensitivity. plotting Visualization tools for plotting results. utils Helper functions for data loading, saving, and plotting.","title":"Core Modules"},{"location":"index.html#optimization-frameworks","text":"","title":"Optimization Frameworks"},{"location":"index.html#kinopt","text":"The kinopt package provides advanced optimization and post-processing:","title":"kinopt"},{"location":"index.html#evol","text":"Global evolutionary optimization using pymoo (DE, NSGA-II): Problem formulation, data construction, exporter for Excel and plots","title":"evol"},{"location":"index.html#local","text":"Local constrained optimization using SciPy solvers (SLSQP, TRUST-CONSTR) with Numba-accelerated objectives","title":"local"},{"location":"index.html#optimality","text":"Post-optimization analysis: feasibility checks, sensitivity reporting, LaTeX table generation, diagnostic plots","title":"optimality"},{"location":"index.html#fitanalysis","text":"Additional fit-evaluation utilities for residual and performance analysis","title":"fitanalysis"},{"location":"index.html#tfopt","text":"Originally implemented by Julius Normann. This version has been modified and optimized by Abhinav Mishra. The tfopt package estimates transcriptional regulation using mRNA and TF time-series data through constrained optimization.","title":"tfopt"},{"location":"index.html#evol_1","text":"Global evolutionary optimization using pymoo (NSGA-II, AGEMOEA, SMSEMOA): Multi-objective loss (fit error, \u03b1 and \u03b2 constraint violations) Parallel evaluation, Excel export, and HTML/plot reports","title":"evol"},{"location":"index.html#local_1","text":"Local constrained optimization using SciPy solvers (SLSQP): Fast deterministic optimization under linear constraints Numba-accelerated objectives, identical output and reports as evol","title":"local"},{"location":"index.html#objfn","text":"Shared objective logic and prediction functions for both backends","title":"objfn"},{"location":"index.html#optcon","text":"Data construction and constraint generation from TF\u2013mRNA interaction files","title":"optcon"},{"location":"index.html#utils","text":"Input parsing, Excel + plot output, and HTML report generation","title":"utils"},{"location":"index.html#command-line-entry-point-for-the-phoskintime-pipeline","text":"The phoskintime pipeline provides a command-line interface to execute various stages of the workflow, including preprocessing, optimization, and modeling. Below are the usage instructions and examples for running the pipeline. Before running any commands, ensure you are in the working directory one level above the project root (where the project directory is visible).","title":"Command-Line Entry Point for the Phoskintime Pipeline"},{"location":"index.html#run-all-stages","text":"Run the entire pipeline with the default (local) solver: python phoskintime all","title":"Run All Stages"},{"location":"index.html#run-preprocessing-only","text":"Execute only the preprocessing stage: python phoskintime prep","title":"Run Preprocessing Only"},{"location":"index.html#run-transcription-factor-mrna-optimization-tfopt","text":"Run TFOPT with the local solver: python phoskintime tfopt --mode local Run TFOPT with the evolutionary solver: python phoskintime tfopt --mode evol","title":"Run Transcription-Factor-mRNA Optimization (TFOPT)"},{"location":"index.html#run-kinase-phosphorylation-optimization-kinopt","text":"Run KINOPT with the local solver: python phoskintime kinopt --mode local Run KINOPT with the evolutionary solver: python phoskintime kinopt --mode evol","title":"Run Kinase-Phosphorylation Optimization (KINOPT)"},{"location":"index.html#run-the-model","text":"Execute the modeling stage: python phoskintime model","title":"Run the Model"},{"location":"index.html#quick-start-setting-up-environment","text":"This guide provides clean setup instructions for running the phoskintime package on a new machine. Choose the scenario that best fits your environment and preferences. Before proceeding, ensure you have the following prerequisites installed: graphviz (for generating diagrams) # For Debian/Ubuntu sudo apt-get install graphviz # For Fedora sudo dnf install graphviz # For MacOS brew install graphviz python 3.10 or higher # Check python version python3 --version # If not installed, install python 3.10 or higher # For Debian/Ubuntu sudo apt-get install python3.10 # For Fedora sudo dnf install python3.10 # For MacOS brew install python@3.10 git (for cloning the repository) # For Debian/Ubuntu sudo apt-get install git # For Fedora sudo dnf install git # For MacOS brew install git","title":"Quick Start: Setting up environment"},{"location":"index.html#scenario-1-pip-virtualenv-debianubuntufedora","text":"","title":"Scenario 1: pip + virtualenv (Debian/Ubuntu/Fedora)"},{"location":"index.html#for-debianubuntu","text":"sudo apt update && sudo apt install -y python3 python3-pip python3-venv git","title":"For Debian/Ubuntu"},{"location":"index.html#for-fedora","text":"sudo dnf install -y python3 python3-pip python3-virtualenv git","title":"For Fedora"},{"location":"index.html#setup","text":"git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create and activate a virtual environment python3 -m venv venv source venv/bin/activate # Install dependencies pip install --upgrade pip pip install -r requirements.txt","title":"Setup"},{"location":"index.html#scenario-2-poetry-pyprojecttoml","text":"","title":"Scenario 2: Poetry + pyproject.toml"},{"location":"index.html#install-poetry-all-platforms","text":"curl -sSL https://install.python-poetry.org | python3 - # Or: pip install poetry","title":"Install Poetry (all platforms)"},{"location":"index.html#setup_1","text":"git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Install dependencies poetry install # Optional: activate shell within poetry env poetry shell","title":"Setup"},{"location":"index.html#scenario-3-using-uv-fast-isolated-pip-alternative","text":"","title":"Scenario 3: Using uv (fast, isolated pip alternative)"},{"location":"index.html#install-uv","text":"curl -LsSf https://astral.sh/uv/install.sh | sh","title":"Install uv"},{"location":"index.html#setup_2","text":"git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create virtual environment and install deps fast uv venv source .venv/bin/activate uv pip install -r requirements.txt","title":"Setup"},{"location":"index.html#scenario-4-conda-or-mamba-anacondaminiconda-users","text":"","title":"Scenario 4: Conda or Mamba (Anaconda/Miniconda users)"},{"location":"index.html#setup_3","text":"git clone git@github.com:bibymaths/phoskintime.git cd phoskintime # Create and activate conda environment conda create -n phoskintime python=3.10 -y conda activate phoskintime # Install dependencies pip install -r requirements.txt Or if using pyproject.toml , add: pip install poetry poetry install For making illustration diagrams, you need to install Graphviz. You can do this via conda or apt-get: conda install graphviz or apt-get install graphviz or download it from the Graphviz website . For macusers, you can use Homebrew: brew install graphviz","title":"Setup"},{"location":"reference.html","text":"API Reference Data Standardization & Cleanup processing.cleanup process_collecttri() Processes the CollecTRI file to clean and filter mRNA-TF interactions. Removes complex interactions, filters by target genes, and saves the result. format_site(site) Formats a phosphorylation site string. If the input is NaN or an empty string, returns an empty string. If the input contains an underscore ('_'), splits the string into two parts, converts the first part to uppercase, and appends the second part unchanged. Otherwise, converts the entire string to uppercase. Parameters: site ( str ) \u2013 The phosphorylation site string to format. Returns: str \u2013 The formatted phosphorylation site string. process_msgauss() Processes the MS Gaussian data file to generate time series data. process_msgauss_std() Processes the MS Gaussian data file to compute transformed means and standard deviations. process_routlimma() Processes the Rout Limma table to generate time series data for mRNA. update_gene_symbols(filename) Updates the GeneID column in a CSV file by mapping GeneIDs to gene/protein symbols. Parameters: filename ( str ) \u2013 The path to the CSV file to be updated. The file must contain a 'GeneID' column. move_processed_files() Moves or copies processed files to their respective directories. Optimization Results Mapping processing.map map_optimization_results(tf_file_path, kin_file_path, sheet_name='Alpha Values') Reads the TF-mRNA optimization results from an Excel file and maps mRNA to each TF. Parameters: tf_file_path \u2013 Path to the Excel file containing TF-mRNA optimization results. kin_file_path \u2013 Path to the Excel file containing Kinase-Phosphorylation optimization results. sheet_name \u2013 The name of the sheet in the Excel file to read from. Default is 'Alpha Values'. Returns: \u2013 pd.DataFrame: A DataFrame containing the mapped TF, mRNA, Psite, and Kinase information. create_cytoscape_table(mapping_csv_path) Creates a Cytoscape-compatible edge table from a mapping file. Parameters: mapping_csv_path ( str ) \u2013 Path to the input CSV file with columns: TF, TF_strength, mRNA, Psite, Kinase, Kinase_strength Returns: table ( DataFrame ) \u2013 Edge table with columns [Source, Target, Interaction, Strength] add_kinetic_strength_columns(mapping_path, mapping__path, excel_path, suffix) Adds kinetic strength columns to the mapping files based on the provided Excel file. Parameters: mapping_path ( str ) \u2013 Path to the first mapping file. mapping__path ( str ) \u2013 Path to the second mapping file. excel_path ( str ) \u2013 Path to the Excel file containing kinetic strength data. suffix ( str ) \u2013 Suffix to append to the output files. generate_nodes(edge_df) Infers node types and aggregates all phosphorylation sites per target node from phosphorylation edges. Parameters: edge_df ( DataFrame ) \u2013 Must have columns ['Source', 'Target', 'Interaction', 'Psite'] Returns: \u2013 pd.DataFrame: DataFrame with columns ['Node', 'Type', 'Psite'] Kinase-Phosphorylation Optimization Evolutionary Algorithms kinopt.evol.config.constants kinopt.evol.config.logconf ColoredFormatter Bases: Formatter format(record) Format the log record with ANSI color codes and elapsed time. Parameters: record ( LogRecord ) \u2013 The log record to format. Returns: str: The formatted log message with ANSI color codes. remove_ansi(s) staticmethod Remove ANSI escape codes from a string. Parameters: s ( str ) \u2013 The string from which to remove ANSI escape codes. Returns: str: The string without ANSI escape codes. setup_logger(name='phoskintime', log_file=None, level=logging.DEBUG, log_dir=LOG_DIR, rotate=True, max_bytes=2 * 1024 * 1024, backup_count=5) Function to set up a logger with both file and console handlers. Parameters: name ( str , default: 'phoskintime' ) \u2013 Name of the logger. log_file ( str , default: None ) \u2013 Path to the log file. If None, a default path is generated. level ( int , default: DEBUG ) \u2013 Logging level (e.g., logging.DEBUG, logging.INFO). log_dir ( str , default: LOG_DIR ) \u2013 Directory where log files are stored. rotate ( bool , default: True ) \u2013 Whether to use rotating file handler. max_bytes ( int , default: 2 * 1024 * 1024 ) \u2013 Maximum size of log file before rotation. backup_count ( int , default: 5 ) \u2013 Number of backup files to keep. Returns: logger ( Logger ) \u2013 Configured logger instance. kinopt.evol.exporter.plotout plot_residuals_for_gene(gene, gene_data) Generates and saves combined residual-related plots for one gene with all psites in the legend. Parameters: gene ( str ) \u2013 Gene identifier. gene_data ( dict ) \u2013 Dictionary with keys 'psites', 'observed', 'estimated', and 'residuals' containing data for all psites. TIME_POINTS ( ndarray or list ) \u2013 Time points corresponding to the series. opt_analyze_nsga(problem, result, F, pairs, approx_ideal, approx_nadir, asf_i, pseudo_i, n_evals, hv, hist, val, hist_cv_avg, k, igd, best_objectives, waterfall_df, convergence_df, alpha_values, beta_values) Function to generate and save various plots related to optimization results. Parameters: problem \u2013 The optimization problem instance. result \u2013 The result of the optimization run. F \u2013 Objective function values. pairs \u2013 Pairs of objectives to plot. approx_ideal \u2013 Approximate ideal point in objective space. approx_nadir \u2013 Approximate nadir point in objective space. asf_i \u2013 Index of the best solution in terms of the augmented weighted sum. pseudo_i \u2013 Index of the pseudo weights. n_evals \u2013 Number of evaluations at each generation. hv \u2013 Hypervolume values. hist \u2013 History of the optimization process. val \u2013 Values for convergence plot. hist_cv_avg \u2013 Average constraint violation history. k \u2013 Number of generations. igd \u2013 Inverted generational distance values. best_objectives \u2013 Best objectives found during the optimization process. waterfall_df \u2013 DataFrame containing waterfall plot data. convergence_df \u2013 DataFrame containing convergence data. alpha_values \u2013 Dictionary containing alpha values for parameters. beta_values \u2013 Dictionary containing beta values for parameters. Returns: \u2013 None opt_analyze_de(long_df, convergence_df, ordered_optimizer_runs, x_values, y_values, val) Function to generate and save various plots related to optimization results. Parameters: long_df ( DataFrame ) \u2013 DataFrame containing parameter values and objective function values. convergence_df ( DataFrame ) \u2013 DataFrame containing convergence data. ordered_optimizer_runs ( DataFrame ) \u2013 DataFrame containing ordered optimizer runs. x_values ( list ) \u2013 X-axis values for the waterfall plot. y_values ( list ) \u2013 Y-axis values for the waterfall plot. val ( list ) \u2013 Values for the convergence plot. Returns: \u2013 None kinopt.evol.exporter.sheetutils output_results(P_initial, P_init_dense, P_estimated, residuals, alpha_values, beta_values, result, timepoints, OUT_FILE) Function to output results to an Excel file. Parameters: P_initial ( dict ) \u2013 Dictionary with initial parameters. P_init_dense ( ndarray ) \u2013 Dense matrix of initial parameters. P_estimated ( ndarray ) \u2013 Dense matrix of estimated parameters. residuals ( ndarray ) \u2013 Dense matrix of residuals. alpha_values ( dict ) \u2013 Dictionary with alpha values. beta_values ( dict ) \u2013 Dictionary with beta values. result ( str ) \u2013 Result string for logging. timepoints ( list ) \u2013 List of time points. OUT_FILE ( str ) \u2013 Output file path. Returns: \u2013 None kinopt.evol.objfn.minfndiffevo PhosphorylationOptimizationProblem Bases: ElementwiseProblem Single-objective constrained optimization problem for phosphorylation dynamics (Numba-accelerated). Minimizes loss between observed and predicted phosphorylation levels subject to constraints that alpha and beta weights sum to 1.0 for each gene-psite and kinase group, respectively. Objective minimize loss (MSE, autocorrelation, Huber, or MAPE) Constraints g(x) <= 0: - for each alpha group: |sum(alpha_group) - 1| <= eps_eq - for each kinase beta group: |sum(beta_group) - 1| <= eps_eq Attributes: P_initial ( dict ) \u2013 Dictionary mapping (gene, psite) tuples to data dictionaries. P_initial_array ( ndarray ) \u2013 Observed phosphorylation matrix with shape (i_max, t_max). K_index ( dict ) \u2013 Dictionary mapping kinase names to lists of (psite_label, row_idx) tuples. K_array ( ndarray ) \u2013 Kinase activity matrix with shape (n_k_rows, t_max). gp_offsets ( ndarray ) \u2013 Offset indices for gene-psite groups. gp_kinase_ids ( ndarray ) \u2013 Kinase IDs for alpha variables. k_offsets ( ndarray ) \u2013 Offset indices for kinase groups. k_psite_rows ( ndarray ) \u2013 Psite row indices for beta variables. num_alpha ( int ) \u2013 Total number of alpha variables. num_beta ( int ) \u2013 Total number of beta variables. eps_eq ( float ) \u2013 Tolerance for equality constraints. loss_id ( int ) \u2013 Loss type identifier. include_reg ( bool ) \u2013 Whether to include regularization. n_scalar ( float ) \u2013 Scalar factor for normalization. estimated_series(params) Compute estimated phosphorylation series for given parameters. Parameters: params ( array - like ) \u2013 1D array of parameters [alpha_1, ..., alpha_N, beta_1, ..., beta_M]. Returns: ndarray \u2013 Predicted phosphorylation matrix with shape (i_max, t_max). residuals(params) Compute residuals between observed and estimated phosphorylation for given parameters. Parameters: params ( array - like ) \u2013 1D array of parameters [alpha_1, ..., alpha_N, beta_1, ..., beta_M]. Returns: ndarray \u2013 Residual matrix (observed - estimated) with shape (i_max, t_max). kinopt.evol.objfn.minfnnsgaii PhosphorylationOptimizationProblem Bases: ElementwiseProblem Multi-objective optimization F[0] = main loss (error) F[1] = alpha sum-to-1 violations (aggregated) F[2] = beta sum-to-1 violations (aggregated) Parameters: P_initial ( dict ) \u2013 Dictionary with keys as (gene, psite) and values containing 'Kinases' and 'TimeSeries'. P_initial_array ( ndarray ) \u2013 Array of observed gene-psite data. K_index ( dict ) \u2013 Dictionary mapping each kinase to a list of (psite, time_series) tuples. K_array ( ndarray ) \u2013 Array of kinase-psite time-series data. gene_psite_counts ( list ) \u2013 List of integers indicating the number of kinases associated with each gene-psite. beta_counts ( dict ) \u2013 Dictionary indicating how many beta values correspond to each kinase-psite combination. objective_function(params) Computes the main objective function (loss) for the given parameters. Parameters: params ( ndarray ) \u2013 Parameter vector containing alpha and beta values. Returns: float \u2013 Computed loss value based on the selected loss type (base, autocorrelation, huber, or mape). kinopt.evol.opt.optrun choose_de_pop_size(problem) Determine an appropriate population size for Differential Evolution (DE) algorithms. The population size is calculated based on the number of decision variables, with bounds to ensure reasonable performance. DE algorithms benefit from population sizes that are multiples of 10. Parameters: problem \u2013 The optimization problem instance with an 'n_var' attribute indicating the number of decision variables. Returns: int \u2013 The calculated population size (multiple of 10, between 100 and 600). choose_nsga_pop_size(problem, n_obj=3) Determine an appropriate population size for NSGA-based multi-objective algorithms. The population size is scaled based on the problem dimensionality (number of decision variables) with heuristic thresholds. The size is rounded to multiples of 50 and enforced to be at least 10 times the number of objectives. Parameters: problem \u2013 The optimization problem instance with an 'n_var' attribute indicating the number of decision variables. n_obj ( int , default: 3 ) \u2013 Number of objectives in the problem. Defaults to 3. Returns: int \u2013 The calculated population size (multiple of 50, at least 10*n_obj). binary_tournament_loss_cv(pop, P, eps_cv=1e-10, cv_mode='linf', **kwargs) Robust binary tournament comparator for constrained optimization. This function performs binary tournament selection with constraint handling using either true constraint violations (CV) or pseudo-constrained objectives. It supports both single-objective and multi-objective formulations. Works for A) single-objective: F has length 1 - if CV exists, use constraint-domination (CV first, then F) - else compare by F only B) pseudo-constrained objectives: F = [loss, alpha_violation, beta_violation] - feasibility-first based on F[1], F[2], then loss Parameters: pop \u2013 Population of individuals with 'F' (objectives) and optionally 'CV' attributes. P ( ndarray ) \u2013 Tournament pairs array of shape (n_tournaments, 2), where each row contains indices of two competing individuals. eps_cv ( float , default: 1e-10 ) \u2013 Feasibility tolerance for constraint violations. Defaults to 1e-10. cv_mode ( str , default: 'linf' ) \u2013 Mode for aggregating constraint violations when using pseudo-constrained objectives. Options: 'linf' (max), 'l1' (sum), 'l2' (norm). Defaults to \"linf\". **kwargs \u2013 Additional keyword arguments (unused, for compatibility). Returns: \u2013 np.ndarray: Array of winning indices for each tournament, shape (n_tournaments,). Raises: ValueError \u2013 If pressure is not 2 (only binary tournaments supported) or if cv_mode is not one of 'linf', 'l1', 'l2'. run_optimization(P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts, PhosphorylationOptimizationProblem) Sets up and runs the multi-objective optimization problem for phosphorylation using an NSGA2 algorithm and a thread pool for parallelization. Parameters: P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts \u2013 Data structures describing the problem (time-series data, kinases, etc.). PhosphorylationOptimizationProblem ( class ) \u2013 The custom problem class to be instantiated. Returns: result \u2013 The pymoo result object containing the optimized population and history. exec_time \u2013 Execution time for the optimization. pick_best_loss_with_constraints_as_objectives(result, eps_cv=1e-10, cv_mode='l1', tie_tol=1e-12, tie_break='loss_then_l2') Select the best solution from a population with constraints formulated as objectives. This function assumes a specific objective structure where F[:,0] = loss (minimize) F[:,1] = constraint violation 1 (minimize, ideally 0) F[:,2] = constraint violation 2 (minimize, ideally 0) Selection rule A) If any feasible solutions exist (cv1<=eps and cv2<=eps): choose minimum loss among feasible. B) Else: choose minimum aggregated CV; tie-break by loss; optional tie-break by ||X||2. Parameters: result \u2013 Pymoo result object containing the final population with 'F' and 'X' attributes. eps_cv ( float , default: 1e-10 ) \u2013 Feasibility tolerance for constraint violations. Defaults to 1e-10. cv_mode ( str , default: 'l1' ) \u2013 Mode for aggregating constraint violations. Options: 'l1' (sum), 'linf' (max), 'l2' (Euclidean norm). Defaults to \"l1\". tie_tol ( float , default: 1e-12 ) \u2013 Tolerance for considering values as tied. Defaults to 1e-12. tie_break ( str , default: 'loss_then_l2' ) \u2013 Tie-breaking strategy. Options: 'loss_then_l2' or 'loss_only'. Defaults to \"loss_then_l2\". Returns: tuple \u2013 A tuple containing: - best_solution: The selected individual from the population. - best_index_in_pop (int): The index of the best solution in the population. - info (dict): Dictionary with selection metadata including selection case, number of feasible solutions, and best objective values. Raises: ValueError \u2013 If the objective array has fewer than 3 columns or if cv_mode is not one of 'l1', 'linf', 'l2'. post_optimization_nsga(result, weights=np.array([1.0, 1.0, 1.0]), ref_point=np.array([3, 1, 1])) Post-process the result of a multi-objective NSGA-based optimization run. This function analyzes the optimization history, computes convergence metrics (hypervolume, IGD+), identifies the best solution using constraint handling, and generates CSV reports for convergence and parameter scans. Parameters: result \u2013 The final result object from the pymoo optimizer containing the final population, history, and objective values. weights ( ndarray , default: array ([1.0, 1.0, 1.0]) ) \u2013 Array of length 3 for weighting the objectives in decomposition-based selection. Defaults to [1.0, 1.0, 1.0]. ref_point ( ndarray , default: array ([3, 1, 1]) ) \u2013 Reference point for hypervolume computation. Defaults to [3, 1, 1]. Returns: tuple \u2013 A tuple containing 23 elements: - F: Final objective values array - pairs: Objective pairs for plotting [(0,1), (0,2), (1,2)] - n_evals: Number of evaluations per generation - hist_cv: Minimum constraint violation per generation - hist_cv_avg: Average constraint violation per generation - k: Generation index when first feasible solution appeared - metric_igd: IGDPlus metric object - metric_hv: Hypervolume metric object - best_solution: The selected best individual - best_objectives: Objective vector of best solution - optimized_params: Decision variables (X) of best solution - approx_nadir: Approximate nadir point - approx_ideal: Approximate ideal point - scores: Best solution's objective scores - best_index: Index of best solution in population - hist: Full optimization history - hist_hv: Hypervolume values per generation - hist_igd: IGD+ values per generation - convergence_df: DataFrame with iteration vs best objective - waterfall_df: DataFrame with all solutions and parameters - asf_i: Index of best solution by ASF decomposition - pseudo_weights_result: Result of pseudo-weights MCDM method - pairs (duplicate): Objective pairs - val: Best objective value per generation post_optimization_de(result, alpha_values, beta_values) Post-process the result of a single-objective DE or GA optimization run. This function extracts the final population, creates parameter labels from alpha and beta values, generates a parameter scan DataFrame sorted by objective value, and produces a convergence DataFrame showing the best objective per iteration. Parameters: result \u2013 The final result object from the pymoo optimizer (e.g., GA or DE result) containing the population, history, and objective values. alpha_values ( dict ) \u2013 Dictionary mapping (gene, psite) tuples to dictionaries of {kinase: value} for alpha parameters. beta_values ( dict ) \u2013 Dictionary mapping (kinase, psite) tuples to beta parameter values. Returns: tuple \u2013 A tuple containing 6 elements: - ordered_optimizer_runs: DataFrame of all solutions sorted by objective value - convergence_df: DataFrame with iteration vs best objective value - long_df: Long-form DataFrame for parameter visualization with columns ['Individual', 'Objective Value (F)', 'Parameter', 'Parameter Value', 'Type'] - x_values: List of iteration indices selected for plotting - y_values: List of objective values corresponding to x_values - val: Best objective value per generation from history kinopt.evol.optcon.construct pipeline(input1_path: str, input2_path: str, time_series_columns: list[str], scaling_method: str, split_point: float, segment_points: list[float], estimate_missing_kinases: bool, kinase_to_psites: dict[str, int]) Function to run the entire pipeline for loading and processing data. Parameters: input1_path ( str ) \u2013 Path to the first CSV file (HGNC data). input2_path ( str ) \u2013 Path to the second CSV file (kinase interactions). time_series_columns ( list [ str ] ) \u2013 List of time series columns to extract. scaling_method ( str ) \u2013 Method for scaling the data. split_point ( float ) \u2013 Split point for scaling. segment_points ( list [ float ] ) \u2013 Segment points for scaling. estimate_missing_kinases ( bool ) \u2013 Flag to estimate missing kinases. kinase_to_psites ( dict [ str , int ] ) \u2013 Dictionary mapping kinases to their respective psites. Returns: full_hgnc_df ( DataFrame ) \u2013 The scaled data from input1. interaction_df ( DataFrame ) \u2013 The subset/merged DataFrame from input2. observed ( DataFrame ) \u2013 Subset of full_hgnc_df merged with interaction_df. P_initial ( dict ) \u2013 Dictionary mapping gene-psite pairs to kinase relationships and time-series data. P_initial_array ( ndarray ) \u2013 Array containing observed time-series data for gene-psite pairs. K_array ( ndarray ) \u2013 Array containing time-series data for kinase-psite combinations. K_index ( dict ) \u2013 Mapping of kinases to their respective psite data. beta_counts ( dict ) \u2013 Mapping of kinase indices to the number of associated psites. gene_psite_counts ( list ) \u2013 List of counts of psites for each gene. n ( int ) \u2013 Number of unique gene-psite pairs. load_geneid_to_psites(input1_path=INPUT1) Function to load geneid to psite mapping from input1.csv. Args: input1_path (str): Path to the first CSV file (HGNC data). Returns: geneid_psite_map (dict): Dictionary mapping gene IDs to sets of psites. get_unique_kinases(input2_path=INPUT2) Function to extract unique kinases from input2.csv. Args: input2_path (str): Path to the second CSV file (kinase interactions). Returns: kinases (set): Set of unique kinases extracted from the input2 file. check_kinases() Function to check if kinases from input2.csv are present in input1.csv. Returns: \u2013 None kinopt.evol.utils.iodata format_duration(seconds) Returns a formatted string representing the duration in seconds, minutes, or hours. Parameters: seconds ( float ) \u2013 The duration in seconds. Returns: str: The formatted duration string. load_and_scale_data(estimate_missing, scaling_method, split_point, seg_points) Function to load and scale data from CSV files. Parameters: estimate_missing ( bool ) \u2013 If True, estimates missing values. scaling_method ( str ) \u2013 The scaling method to apply ('min_max', 'log', 'temporal', 'segmented', 'slope', 'cumulative'). split_point ( int ) \u2013 Column index for temporal scaling. seg_points ( list ) \u2013 List of column indices for segmented scaling. Returns: full_hgnc_df ( DataFrame ) \u2013 DataFrame with scaled time-series data. interaction_df ( DataFrame ) \u2013 DataFrame containing interaction data. observed ( DataFrame ) \u2013 DataFrame containing observed data. apply_scaling(df, time_series_columns, method, split_point, segment_points) Function to apply different scaling methods to time-series data in a DataFrame. Parameters: df ( DataFrame ) \u2013 Input DataFrame containing time-series data. time_series_columns ( list ) \u2013 List of column names to scale. method ( str ) \u2013 Scaling method ('min_max', 'log', 'temporal', 'segmented', 'slope', 'cumulative'). split_point ( int ) \u2013 Column index for temporal scaling. segment_points ( list ) \u2013 List of column indices for segmented scaling. Returns: \u2013 pd.DataFrame: DataFrame with scaled time-series data. create_report(results_dir: str, output_file: str = 'report.html') Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root result's directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir). Returns: \u2013 None organize_output_files(*directories) Function to organize output files into protein-specific folders and a general folder. Parameters: *directories \u2013 List of directories to organize. Returns: \u2013 None kinopt.evol.utils.params extract_parameters(P_initial, gene_psite_counts, K_index, optimized_params) Function to extract alpha and beta values from the optimized parameters. Parameters: P_initial ( dict ) \u2013 Dictionary containing initial parameters for each gene-psite pair. gene_psite_counts ( list ) \u2013 List of counts for each gene-psite pair. K_index ( dict ) \u2013 Dictionary mapping kinases to their respective psite pairs. optimized_params ( list ) \u2013 List of optimized parameters. Returns: alpha_values ( dict ) \u2013 Dictionary containing alpha values for each gene-psite pair. beta_values ( dict ) \u2013 Dictionary containing beta values for each kinase-psite pair. compute_metrics(optimized_params: np.ndarray, P_initial: dict, P_initial_array: np.ndarray, K_index: dict, K_array: np.ndarray, gene_psite_counts: list, beta_counts: dict, n: int) Function to compute error metrics for the estimated series. Parameters: optimized_params ( list ) \u2013 List of optimized parameters. P_initial ( dict ) \u2013 Dictionary containing initial parameters for each gene-psite pair. P_initial_array ( ndarray ) \u2013 Array of initial parameters. K_index ( dict ) \u2013 Dictionary mapping kinases to their respective psite pairs. K_array ( ndarray ) \u2013 Array of kinases. gene_psite_counts ( list ) \u2013 List of counts for each gene-psite pair. beta_counts ( dict ) \u2013 List of counts for each kinase-psite pair. n ( int ) \u2013 Number of samples. Returns: P_estimated ( ndarray ) \u2013 Estimated series. residuals ( ndarray ) \u2013 Residuals between initial and estimated series. mse ( float ) \u2013 Mean Squared Error. rmse ( float ) \u2013 Root Mean Squared Error. mae ( float ) \u2013 Mean Absolute Error. mape ( float ) \u2013 Mean Absolute Percentage Error. r_squared ( float ) \u2013 R-squared value. Gradient-Based Algorithms kinopt.local.config.constants parse_args() kinopt.local CLI. Defaults come from config.toml. kinopt.local.config.logconf kinopt.local.exporter.plotout format_timepoints(tp, tol=1e-09) Format timepoints with minimal decimals: - integers -> no decimal - non-integers -> one decimal Parameters: tp ( array - like ) \u2013 Timepoints (list or np.ndarray) tol ( float , default: 1e-09 ) \u2013 Tolerance for floating-point integer check Returns: \u2013 list[str]: Formatted labels plot_fits_for_gene(gene, gene_data, real_timepoints) Function to plot the observed and estimated phosphorylation levels for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing observed and estimated data for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. export_outcomes_to_csv(outcomes, csv_path) Export multistart optimization outcomes to CSV. One row per start, scalar diagnostics only. plot_cumulative_residuals(gene, gene_data, real_timepoints) Function to plot the cumulative residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_autocorrelation_residuals(gene, gene_data, real_timepoints) Function to plot the autocorrelation of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_histogram_residuals(gene, gene_data, real_timepoints) Function to plot histograms of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_qqplot_residuals(gene, gene_data, real_timepoints) Function to plot QQ plots of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_multistart_summary_runtime_overlay(summary_csv, out_path=None, figsize=(8, 8), x_col='rank', y_col='fun', c_col='runtime_s', success_col='success', cv_col='constr_violation', annotate_best=True) Read a multistart summary CSV and plot objective vs rank with point color = runtime. Minimal, information-dense conventions: - x: rank (best -> worst) - y: final objective (fun) - color: runtime in seconds - optional: de-emphasize non-success / infeasible points (if columns exist) Parameters: summary_csv ( str | Path ) \u2013 Path to the multistart_summary.csv out_path ( str | Path | None , default: None ) \u2013 If provided, saves the figure (e.g. .png) figsize ( tuple , default: (8, 8) ) \u2013 Figure size in inches x_col, y_col, c_col \u2013 Column names success_col, cv_col \u2013 Optional columns for styling (used if present) annotate_best ( bool , default: True ) \u2013 Annotate the best run (rank=1 or min fun) Returns: ( fig , ax , df ) \u2013 Matplotlib figure/axis and the loaded DataFrame kinopt.local.exporter.sheetutils format_timepoints(tp, tol=1e-09) Format timepoints with minimal decimals: - integers -> no decimal - non-integers -> one decimal Parameters: tp ( array - like ) \u2013 Timepoints (list or np.ndarray) tol ( float , default: 1e-09 ) \u2013 Tolerance for floating-point integer check Returns: \u2013 list[str]: Formatted labels plot_fits_for_gene(gene, gene_data, real_timepoints) Function to plot the observed and estimated phosphorylation levels for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing observed and estimated data for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. export_outcomes_to_csv(outcomes, csv_path) Export multistart optimization outcomes to CSV. One row per start, scalar diagnostics only. plot_cumulative_residuals(gene, gene_data, real_timepoints) Function to plot the cumulative residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_autocorrelation_residuals(gene, gene_data, real_timepoints) Function to plot the autocorrelation of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_histogram_residuals(gene, gene_data, real_timepoints) Function to plot histograms of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_qqplot_residuals(gene, gene_data, real_timepoints) Function to plot QQ plots of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data. plot_multistart_summary_runtime_overlay(summary_csv, out_path=None, figsize=(8, 8), x_col='rank', y_col='fun', c_col='runtime_s', success_col='success', cv_col='constr_violation', annotate_best=True) Read a multistart summary CSV and plot objective vs rank with point color = runtime. Minimal, information-dense conventions: - x: rank (best -> worst) - y: final objective (fun) - color: runtime in seconds - optional: de-emphasize non-success / infeasible points (if columns exist) Parameters: summary_csv ( str | Path ) \u2013 Path to the multistart_summary.csv out_path ( str | Path | None , default: None ) \u2013 If provided, saves the figure (e.g. .png) figsize ( tuple , default: (8, 8) ) \u2013 Figure size in inches x_col, y_col, c_col \u2013 Column names success_col, cv_col \u2013 Optional columns for styling (used if present) annotate_best ( bool , default: True ) \u2013 Annotate the best run (rank=1 or min fun) Returns: ( fig , ax , df ) \u2013 Matplotlib figure/axis and the loaded DataFrame output_results(P_initial, P_init_dense, P_estimated, residuals, alpha_values, beta_values, result, mse, rmse, mae, mape, r_squared) Function to output the results of the optimization process. Parameters: P_initial ( dict ) \u2013 Dictionary containing initial phosphorylation data. P_init_dense ( ndarray ) \u2013 Dense matrix of initial phosphorylation data. P_estimated ( ndarray ) \u2013 Dense matrix of estimated phosphorylation data. residuals ( ndarray ) \u2013 Dense matrix of residuals. alpha_values ( dict ) \u2013 Dictionary containing optimized alpha values. beta_values ( dict ) \u2013 Dictionary containing optimized beta values. result ( OptimizeResult ) \u2013 Result object from the optimization process. mse ( float ) \u2013 Mean Squared Error of the optimization. rmse ( float ) \u2013 Root Mean Squared Error of the optimization. mae ( float ) \u2013 Mean Absolute Error of the optimization. mape ( float ) \u2013 Mean Absolute Percentage Error of the optimization. r_squared ( float ) \u2013 R-squared value of the optimization. export_params_npz(outcomes, path) Export the optimized parameters to a compressed npz file. Parameters: outcomes ( list ) \u2013 List of OptimizeResult objects. path ( str ) \u2013 Path to save the npz file. kinopt.local.objfn.minfn kinopt.local.opt.optrun StartOutcome dataclass Outcome of a single optimization start. :param start_id: ID of the start. :param seed: Seed used for the start. :param result: Result of the optimization. :param optimized_params: Optimized parameters. :param fun: Objective function value. :param success: Whether the optimization was successful. :param constr_violation: Constraint violation. :param runtime_s: Runtime of the optimization. run_optimization(obj_fun, params_initial, opt_method, bounds, constraints) Run optimization using the specified method. Parameters: obj_fun \u2013 Objective function to minimize. params_initial \u2013 Initial parameters for the optimization. opt_method \u2013 Optimization method to use (e.g., 'SLSQP', 'trust-constr'). bounds \u2013 Bounds for the parameters. constraints \u2013 Constraints for the optimization. Returns: result \u2013 Result of the optimization. optimized_params \u2013 Optimized parameters. multistart_run_optimization(obj_fun, params_initial, opt_method, bounds, constraints, n_starts=24, n_jobs=-1, base_seed=1234, init_strategy='hybrid', jitter_scale=0.15, prefer_feasible=True, logger=None) Runs run_optimization multiple times in parallel and returns (best_result, best_params, outcomes). Selection logic (sophisticated but simple): 1) If prefer_feasible: prefer (cv <= 0) or smallest constraint violation. 2) Then lowest objective. 3) Then success=True as tie-breaker. 4) Then shortest runtime as final tie-breaker. Parameters: obj_fun \u2013 Objective function to optimize. params_initial \u2013 Initial parameters for optimization. opt_method \u2013 Optimization method to use (e.g., 'SLSQP', 'trust-constr'). bounds \u2013 Parameter bounds for optimization. constraints \u2013 Constraints for optimization. n_starts \u2013 Number of optimization starts to run (default: 24). n_jobs \u2013 Number of parallel jobs to run. -1 means use all processors (default: -1). base_seed \u2013 Base seed for random number generation (default: 1234). init_strategy \u2013 Strategy for sampling initial parameters: 'jitter', 'uniform', or 'hybrid' (default: 'hybrid'). jitter_scale \u2013 Scale for jittering initial parameters (default: 0.15). prefer_feasible \u2013 If True, prefer feasible solutions over infeasible ones (default: True). logger \u2013 Logger instance for logging messages (default: None). Returns: tuple \u2013 A tuple containing: - best_result: The optimization result object with the best outcome. - best_params: The optimized parameters corresponding to the best result. - outcomes: List of StartOutcome objects for all optimization starts. kinopt.local.optcon.construct load_geneid_to_psites(input1_path=INPUT1) Load the geneid to psite mapping from a CSV file. Parameters: input1_path ( str , default: INPUT1 ) \u2013 Path to the input CSV file containing geneid and psite information. Returns: defaultdict: A dictionary mapping geneid to a set of psites. get_unique_kinases(input2_path=INPUT2) Extract unique kinases from the input CSV file. Parameters: input2_path ( str , default: INPUT2 ) \u2013 Path to the input CSV file containing kinase information. Returns: set: A set of unique kinases. check_kinases() Check if kinases in input2.csv are present in input1.csv and log the results. kinopt.local.utils.iodata format_duration(seconds) Formats a duration in seconds into a human-readable string. - If less than 60 seconds, returns in seconds. - If less than 3600 seconds, returns in minutes. - If more than 3600 seconds, returns in hours. :param seconds: :return: Formatted string load_and_scale_data(estimate_missing, scaling_method, split_point, seg_points) Load and scale the data from the specified input files. :param estimate_missing: :param scaling_method: :param split_point: :param seg_points: :return: Time series data, interaction data, observed data apply_scaling(df, cols, method, split_point, seg_points) Apply scaling to the specified columns of a DataFrame based on the given method. The scaling methods include: - 'min_max': Min-Max scaling - 'log': Logarithmic scaling - 'temporal': Temporal scaling (two segments) - 'segmented': Segmented scaling (multiple segments) - 'slope': Slope scaling - 'cumulative': Cumulative scaling :param df: :param cols: :param method: :param split_point: :param seg_points: :return: df create_report(results_dir: str, output_file: str = 'report.html') Creates a single global report HTML file from all gene folders inside the results directory. For each gene folder (e.g. \"ABL2\"), the report will include: - All PNG plots and interactive HTML plots displayed in a grid with three plots per row. - Each plot is confined to a fixed size of 900px by 900px. - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row. Parameters: results_dir ( str ) \u2013 Path to the root results directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir). organize_output_files(*directories) Function to organize output files into protein-specific folders. It moves files matching the pattern 'protein_name_*.{json,svg,png,html,csv,xlsx}' into a folder named after the protein (e.g., 'ABL2') and moves all other files into a 'General' folder within the same directory. :param directories: kinopt.local.utils.params extract_parameters(P_initial, gene_kinase_counts, total_alpha, unique_kinases, K_index, optimized_params) Extracts the alpha and beta parameters from the optimized parameters. :param P_initial: :param gene_kinase_counts: :param total_alpha: :param unique_kinases: :param K_index: :param optimized_params: :return: Alpha and beta values as dictionaries compute_metrics(optimized_params, P_init_dense, t_max, gene_alpha_starts, gene_kinase_counts, gene_kinase_idx, total_alpha, kinase_beta_starts, kinase_beta_counts, K_data, K_indices, K_indptr) Computes the estimated series and various metrics based on the optimized parameters. :param optimized_params: :param P_init_dense: :param t_max: :param gene_alpha_starts: :param gene_kinase_counts: :param gene_kinase_idx: :param total_alpha: :param kinase_beta_starts: :param kinase_beta_counts: :param K_data: :param K_indices: :param K_indptr: :return: Estimated series, residuals, MSE, RMSE, MAE, MAPE, R-squared Fitting Analysis & Feasibility kinopt.fitanalysis.helpers.postfit goodnessoffit(estimated, observed) Function to plot the goodness of fit and kullback-leibler divergence for estimated and observed values. Parameters: estimated ( DataFrame ) \u2013 DataFrame containing estimated values. observed ( DataFrame ) \u2013 DataFrame containing observed values. Returns: \u2013 None reshape_alpha_beta(alpha_values, beta_values) Function to reshape alpha and beta values for plotting. Parameters: alpha_values ( DataFrame ) \u2013 DataFrame containing alpha values. beta_values ( DataFrame ) \u2013 DataFrame containing beta values. Returns: pd.DataFrame: Reshaped DataFrame containing both alpha and beta values. perform_pca(df) Function to perform PCA analysis on the given DataFrame. Parameters: df ( DataFrame ) \u2013 DataFrame containing the data for PCA analysis. Returns: \u2013 pd.DataFrame: DataFrame with PCA results and additional columns for type and gene/psite information. plot_pca(result_df_sorted, y_axis_column) Plot PCA or t-SNE results for each gene/psite. The function creates scatter plots with different markers for alpha and beta parameters, and adds labels for each point. The function also adjusts text labels to avoid overlap using the adjustText library. :param result_df_sorted: DataFrame containing PCA or t-SNE results. :param y_axis_column: Column name for the y-axis values in the plot. perform_tsne(scaled_data, df) Perform t-SNE analysis on the given scaled data. The function returns a DataFrame with t-SNE results and additional columns for type and gene/psite information. :param scaled_data: :param df: :return: - pd.DataFrame: DataFrame with t-SNE results and additional columns. additional_plots(df, scaled_data, alpha_values, beta_values, residuals_df) Function to create additional plots including CDF, KDE, Boxplot, and Hierarchical Clustering. :param df: :param scaled_data: :param alpha_values: :param beta_values: :param residuals_df: create_sankey_from_network(output_dir, data, title) Creates a Sankey diagram from the given data and saves it as an HTML file. This function processes the input data to generate nodes and links for a Sankey diagram. It assigns colors to nodes and links based on their attributes and values, and uses Plotly to render the diagram. The resulting diagram is saved as an HTML file in the specified output directory. :param output_dir: str The directory where the Sankey diagram HTML file will be saved. :param data: pd.DataFrame A DataFrame containing the data for the Sankey diagram. It must include the following columns: - 'Source': The source node of the link. - 'Target': The target node of the link. - 'Value': The value of the link, which determines the flow size. :param title: str The title of the Sankey diagram. The function performs the following steps: 1. Initializes nodes and links for the Sankey diagram. 2. Maps node labels to indices and assigns colors to nodes. 3. Processes the data to create links between nodes, assigning colors based on link values. 4. Builds the Sankey diagram using Plotly. 5. Adds a color bar to explain the flow gradient. 6. Saves the Sankey diagram as an HTML file in the specified output directory. important_connections(output_dir, data, top_n=20) Extracts the top N most important connections based on their absolute values and saves them to a CSV file. :param output_dir: str The directory where the CSV file will be saved. :param data: pd.DataFrame A DataFrame containing the connections with columns 'Source', 'Target', and 'Value'. :param top_n: int, optional The number of top connections to extract (default is 20). The function sorts the connections by their absolute values in descending order, selects the top N connections, and saves them to a CSV file named 'top_connections.csv' in the specified output directory. kinopt.optimality.KKT generate_latex_table(summary_dict, table_caption, table=None) Function to generate a LaTeX table from a summary dictionary. Parameters: summary_dict ( dict ) \u2013 Dictionary containing summary data. table_caption ( str ) \u2013 Caption for the LaTeX table. table ( str , default: None ) \u2013 Optional existing LaTeX table to append to. Returns: str \u2013 LaTeX formatted table as a string. print_primal_feasibility_results(primal_summary, alpha_violations, beta_violations, logger_obj=None) Logs the primal feasibility summary and violation details. Parameters: primal_summary ( dict ) \u2013 Dictionary containing primal feasibility results. alpha_violations ( dict ) \u2013 Dictionary containing alpha constraint violations. beta_violations ( dict ) \u2013 Dictionary containing beta constraint violations. logger_obj \u2013 Optional logger object to log the information. print_sensitivity_and_active_constraints(sensitivity_summary, active_constraints_summary, logger_obj=None) Logs the sensitivity summary and active constraints summary. Parameters: sensitivity_summary ( dict ) \u2013 Dictionary containing sensitivity analysis results. active_constraints_summary ( dict ) \u2013 Dictionary containing active constraints summary. logger_obj \u2013 Optional logger object to log the information. plot_constraint_violations(alpha_violations, beta_violations, out_dir) Function to plot constraint violations for alpha and beta values. It creates a stacked bar plot showing the violations for each protein. The top 5 proteins with the highest violations are highlighted in red. Parameters: alpha_violations ( Series ) \u2013 Series containing alpha constraint violations. beta_violations ( Series ) \u2013 Series containing beta constraint violations. out_dir ( str ) \u2013 Directory to save the plot. plot_sensitivity_analysis(sensitivity_analysis, out_dir) Function to plot sensitivity analysis results. It creates a horizontal bar plot showing the mean, max, and min sensitivity for each protein. Parameters: sensitivity_analysis ( DataFrame ) \u2013 DataFrame containing sensitivity analysis results. out_dir ( str ) \u2013 Directory to save the plot. Returns: \u2013 None process_excel_results(file_path=OUT_FILE) Function to process the Excel results file. It reads the alpha and beta values, estimated and observed values, validates normalization constraints, computes residuals and gradients, and generates LaTeX tables for the residuals and sensitivity summaries. It also performs sensitivity analysis and identifies high sensitivity sites. The results are returned as a dictionary. Parameters: file_path ( str , default: OUT_FILE ) \u2013 Path to the Excel file containing results. Returns: dict: Dictionary containing the processed results, including alpha and beta values, estimated and observed values, constraint violations, residuals summary, sensitivity summary, and high sensitivity sites. post_optimization_results() Function to process and visualize the results of the optimization. Returns: dict: Dictionary containing the processed results, including alpha and beta values, estimated and observed values, constraint violations, residuals summary, sensitivity summary, and high sensitivity sites. TF-mRNA Optimization Evolutionary Algorithms tfopt.evol.config.constants parse_args() tfopt.evol CLI: bounds, loss, optimizer selection. Defaults come from config.toml. tfopt.evol.config.logconf tfopt.evol.exporter.plotout plot_estimated_vs_observed(predictions, expression_matrix, gene_ids, time_points, regulators, tf_protein_matrix, tf_ids, num_targets, save_path=OUT_DIR) Plot the estimated vs observed expression levels for a set of genes. Parameters: predictions ( ndarray ) \u2013 Predicted expression levels. expression_matrix ( ndarray ) \u2013 Observed expression levels. gene_ids ( list ) \u2013 List of gene identifiers. time_points ( ndarray ) \u2013 Time points for the experiments. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. tf_protein_matrix ( ndarray ) \u2013 Matrix of TF protein levels. tf_ids ( list ) \u2013 List of TF identifiers. num_targets ( int ) \u2013 Number of target genes to plot. save_path ( str , default: OUT_DIR ) \u2013 Directory to save the plots. compute_predictions(x, regulators, protein_mat, psite_tensor, n_reg, T_use, n_mRNA, beta_start_indices, num_psites) Compute the predicted expression levels based on the optimization variables. Parameters: x ( ndarray ) \u2013 Optimization variables. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. protein_mat ( ndarray ) \u2013 Matrix of TF protein levels. psite_tensor ( ndarray ) \u2013 Tensor of phosphorylation sites. n_reg ( int ) \u2013 Number of regulators. T_use ( int ) \u2013 Number of time points to use. n_mRNA ( int ) \u2013 Number of mRNAs. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. tfopt.evol.exporter.sheetutils save_results_to_excel(gene_ids, tf_ids, final_alpha, final_beta, psite_labels_arr, expression_matrix, predictions, objective_value, reg_map, filename=OUT_FILE) Save the optimization results to an Excel file. Parameters: gene_ids ( list ) \u2013 List of gene identifiers. tf_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha values. final_beta ( ndarray ) \u2013 Final beta values. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels. expression_matrix ( ndarray ) \u2013 Observed expression levels. predictions ( ndarray ) \u2013 Predicted expression levels. objective_value ( float ) \u2013 Objective value from optimization. reg_map ( dict ) \u2013 Mapping of genes to regulators. filename ( str , default: OUT_FILE ) \u2013 Path to the output Excel file. tfopt.evol.objfn.minfn TFOptimizationMultiObjectiveProblem Bases: Problem Represents a multi-objective optimization problem specific to transcription factor (TF) and mRNA synthesis dynamics. This class is an extension of the Problem class and is designed to model complex biological processes by incorporating various dynamic parameters like regulators, protein matrices, psite tensors, and associated configurations. It supports parallel evaluation for multi-thread usage, optimizing performance for large populations. Attributes: n_mRNA ( int ) \u2013 Number of mRNA species in the system. n_TF ( int ) \u2013 Number of transcription factor species in the system. n_reg ( int ) \u2013 Number of regulators. n_psite_max ( int ) \u2013 Maximum number of potential p-sites. n_alpha ( int ) \u2013 Number of alpha parameters used in modeling. T_use ( int ) \u2013 Number of time units or steps to use in the evaluation. mRNA_mat ( ndarray ) \u2013 A matrix representing the mRNA dynamics. regulators ( ndarray ) \u2013 Array of regulator IDs associated with mRNA and TF interactions. protein_mat ( ndarray ) \u2013 A matrix representing the protein synthesis rates or patterns. psite_tensor ( ndarray ) \u2013 A tensor indicating probabilistic binding sites of proteins. beta_start_indices ( ndarray ) \u2013 Array indicating the starting indices of beta coefficients. num_psites ( ndarray ) \u2013 Array indicating the number of p-sites per transcription factor. no_psite_tf ( ndarray ) \u2013 Boolean array indicating TFs with zero p-sites. loss_type ( int ) \u2013 Configurable loss function type for the optimization. Defaults to 0. lam1 ( float ) \u2013 First regularization parameter for loss calculation. Defaults to 1e-3. lam2 ( float ) \u2013 Second regularization parameter for loss calculation. Defaults to 1e-3. max_threads ( int ) \u2013 Maximum number of threads to use for evaluation. 0 indicates automatic thread selection based on system capacity. __init__(n_var: int, n_mRNA: int, n_TF: int, n_reg: int, n_psite_max: int, n_alpha: int, mRNA_mat: np.ndarray, regulators: np.ndarray, protein_mat: np.ndarray, psite_tensor: np.ndarray, T_use: int, beta_start_indices: np.ndarray, num_psites: np.ndarray, no_psite_tf: np.ndarray, xl: Optional[np.ndarray] = None, xu: Optional[np.ndarray] = None, **kwargs) Initializes the class with various parameters required for computational evaluation. Parameters: n_var ( int ) \u2013 The number of variables. n_mRNA ( int ) \u2013 The number of mRNA molecules. n_TF ( int ) \u2013 The number of transcription factors (TFs). n_reg ( int ) \u2013 The number of regulators. n_psite_max ( int ) \u2013 The maximum number of p-sites. n_alpha ( int ) \u2013 The number of alpha coefficients. mRNA_mat ( ndarray ) \u2013 Matrix representing the mRNA data. regulators ( ndarray ) \u2013 Array representing the regulator mappings. protein_mat ( ndarray ) \u2013 Matrix representing the protein data. psite_tensor ( ndarray ) \u2013 Tensor representing the p-site data. T_use ( int ) \u2013 The time step or usage parameter. beta_start_indices ( ndarray ) \u2013 Array of start indices for beta calculations. num_psites ( ndarray ) \u2013 Array representing the number of p-sites. no_psite_tf ( ndarray ) \u2013 Boolean array indicating TFs with no associated p-sites. xl ( Optional [ ndarray ] , default: None ) \u2013 Optional lower-bound array for the variables. xu ( Optional [ ndarray ] , default: None ) \u2013 Optional upper-bound array for the variables. **kwargs \u2013 Additional optional arguments such as \"loss_type\", \"lam1\", \"lam2\", and \"threads\". tfopt.evol.opt.optrun run_optimization(problem, total_dim, optimizer) Execute multi-objective optimization using the specified algorithm. This function configures and runs one of three multi-objective evolutionary algorithms (UNSGA3, SMSEMOA, or AGEMOEA) on the provided optimization problem. The algorithm is configured with appropriate genetic operators (two-point crossover and polynomial mutation) and terminated after 1000 generations. Parameters: problem ( Problem ) \u2013 The pymoo Problem instance defining the optimization problem, including objectives, constraints, and variable bounds. total_dim ( int ) \u2013 Total number of decision variables (dimensions) in the optimization problem. Used to determine population size and mutation probability. optimizer ( int ) \u2013 Selector for the optimization algorithm: - 0: UNSGA3 (Unified NSGA-III) - Reference direction-based algorithm - 1: SMSEMOA - S-Metric Selection Evolutionary Multi-objective Algorithm - 2: AGEMOEA - Adaptive Geometry Estimation-based Multi-objective Evolutionary Algorithm Returns: Result \u2013 A pymoo Result object containing the optimization outcomes, including: - X: Decision variables of the Pareto-optimal solutions - F: Objective function values of the Pareto-optimal solutions - algorithm: The algorithm instance used - Additional statistics and convergence information Notes Population size is set to 2 * total_dim (or larger for UNSGA3 if needed) Crossover probability: 0.9 Mutation probability: 1.0 / total_dim Mutation distribution index (eta): 20 Termination: Fixed at 1000 generations Random seed: 1 (for reproducibility) Duplicate elimination is enabled for all algorithms UNSGA3 automatically adjusts population size to match reference directions tfopt.evol.optcon.construct build_fixed_arrays(mRNA_ids, mRNA_mat, TF_ids, protein_dict, psite_dict, psite_labels_dict, reg_map) Builds fixed-shape arrays from the input data. Parameters: mRNA_ids ( list ) \u2013 List of mRNA identifiers. mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression levels. TF_ids ( list ) \u2013 List of TF identifiers. protein_dict ( dict ) \u2013 Dictionary mapping TFs to their protein levels. psite_dict ( dict ) \u2013 Dictionary mapping TFs to their phosphorylation sites. psite_labels_dict ( dict ) \u2013 Dictionary mapping TFs to their phosphorylation site labels. reg_map ( dict ) \u2013 Mapping of genes to their regulators. Returns: mRNA_mat (np.ndarray): Matrix of mRNA expression levels. regulators (np.ndarray): Matrix of regulators for each mRNA. protein_mat (np.ndarray): Matrix of TF protein levels. psite_tensor (np.ndarray): Tensor of phosphorylation sites. n_reg (int): Number of regulators. n_psite_max (int): Maximum number of phosphorylation sites across all TFs. psite_labels_arr (list): List of phosphorylation site labels for each TF. num_psites (np.ndarray): Array indicating the number of phosphorylation sites for each TF. tfopt.evol.optcon.filter load_raw_data() Load raw data from files. Returns: mRNA_ids \u2013 List of mRNA gene identifiers. mRNA_mat \u2013 Matrix of mRNA expression data. mRNA_time_cols \u2013 Time points for mRNA data. TF_ids \u2013 List of transcription factor identifiers. protein_dict \u2013 Dictionary mapping TF_ids to their protein data. psite_dict \u2013 Dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict \u2013 Dictionary mapping TF_ids to their phosphorylation site labels. TF_time_cols \u2013 Time points for TF data. reg_map \u2013 Regulation map, mapping mRNA genes to their regulators. filter_mrna(mRNA_ids, mRNA_mat, reg_map) Filter mRNA genes to only those with regulators present in the regulation map. Parameters: mRNA_ids ( list ) \u2013 List of mRNA gene identifiers. mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression data. reg_map ( dict ) \u2013 Regulation map, mapping mRNA genes to their regulators. Returns: filtered_mRNA_ids ( list ) \u2013 List of filtered mRNA gene identifiers. filtered_mRNA_mat ( ndarray ) \u2013 Matrix of filtered mRNA expression data. update_regulations(mRNA_ids, reg_map, TF_ids) Update the regulation map to only include relevant transcription factors. Parameters: mRNA_ids ( list ) \u2013 List of mRNA gene identifiers. reg_map ( dict ) \u2013 Regulation map, mapping mRNA genes to their regulators. TF_ids ( list ) \u2013 List of transcription factor identifiers. Returns: relevant_TFs ( set ) \u2013 Set of relevant transcription factors. filter_TF(TF_ids, protein_dict, psite_dict, psite_labels_dict, relevant_TFs) Filter transcription factors to only those present in the relevant_TFs set. Parameters: TF_ids ( list ) \u2013 List of transcription factor identifiers. protein_dict ( dict ) \u2013 Dictionary mapping TF_ids to their protein data. psite_dict ( dict ) \u2013 Dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict ( dict ) \u2013 Dictionary mapping TF_ids to their phosphorylation site labels. relevant_TFs ( set ) \u2013 Set of relevant transcription factors. Returns: TF_ids_filtered ( list ) \u2013 List of filtered transcription factor identifiers. protein_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their protein data. psite_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their phosphorylation site labels. determine_T_use(mRNA_mat, TF_time_cols) Determine the number of time points to use for the analysis. Parameters: mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression data. TF_time_cols ( list ) \u2013 Time points for TF data. tfopt.evol.utils.iodata load_mRNA_data(filename=INPUT3) Load mRNA data from a CSV file. Parameters: filename ( str , default: INPUT3 ) \u2013 Path to the CSV file containing mRNA data. Returns: - mRNA_ids: List of mRNA gene identifiers (strings). - mRNA_mat: Matrix of mRNA expression data (numpy array). - time_cols: List of time columns (excluding \"GeneID\"). load_TF_data(filename=INPUT1) Load TF data from a CSV file. Parameters: filename ( str , default: INPUT1 ) \u2013 Path to the CSV file containing TF data. Returns: - TF_ids: List of TF identifiers (strings). - protein_dict: Dictionary mapping TF identifiers to their protein data (numpy array). - psite_dict: Dictionary mapping TF identifiers to their phosphorylation site data (list of numpy arrays). - psite_labels_dict: Dictionary mapping TF identifiers to their phosphorylation site labels (list of strings). - time_cols: List of time columns (excluding \"GeneID\" and \"Psite\"). load_regulation(filename=INPUT4) Load regulation data from a CSV file. Parameters: filename ( str , default: INPUT4 ) \u2013 Path to the CSV file containing regulation data. Returns: - reg_map: Dictionary mapping mRNA genes to their regulators (list of TF identifiers). create_report(results_dir: str, output_file: str = 'report.html') Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the directory containing gene folders. organize_output_files(*directories) Organizes output files from multiple directories into separate folders for each protein. Parameters: directories ( str , default: () ) \u2013 List of directories to organize. format_duration(seconds) Format a duration in seconds into a human-readable string. Parameters: seconds ( float ) \u2013 Duration in seconds. Returns: str: Formatted duration string. tfopt.evol.utils.params create_no_psite_array(n_TF, num_psites, psite_labels_arr) Create an array indicating whether each TF has no phosphorylation sites. Parameters: n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF. Returns: no_psite_tf ( ndarray ) \u2013 Array indicating whether each TF has no phosphorylation sites. compute_beta_indices(num_psites, n_TF) Compute the starting indices for the beta parameters for each TF. Parameters: num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. n_TF ( int ) \u2013 Number of transcription factors. Returns: beta_start_indices ( ndarray ) \u2013 Array of starting indices for the beta parameters. cum ( int ) \u2013 Total number of beta parameters. create_initial_guess(n_mRNA, n_reg, n_TF, num_psites, no_psite_tf) Create the initial guess for the optimization variables. Parameters: n_mRNA ( int ) \u2013 Number of mRNAs. n_reg ( int ) \u2013 Number of regulators. n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( ndarray ) \u2013 Array indicating whether each TF has no phosphorylation sites. Returns: x0 ( ndarray ) \u2013 Initial guess for the optimization variables. n_alpha ( int ) \u2013 Number of alpha parameters. create_bounds(n_alpha, n_beta_total, lb, ub) Create the lower and upper bounds for the optimization variables. Parameters: n_alpha ( int ) \u2013 Number of alpha parameters. n_beta_total ( int ) \u2013 Total number of beta parameters. lb ( float ) \u2013 Lower bound for the optimization variables. ub ( float ) \u2013 Upper bound for the optimization variables. Returns: xl ( ndarray ) \u2013 Lower bounds for the optimization variables. xu ( ndarray ) \u2013 Upper bounds for the optimization variables. get_parallel_runner() Get a parallel runner for multi-threading. Returns: runner \u2013 Parallelization runner. pool \u2013 ThreadPool instance for parallel execution. extract_best_solution(res, n_alpha, n_mRNA, n_reg, n_TF, num_psites, beta_start_indices) Extract the best solution from the optimization results. Parameters: res \u2013 Optimization results. n_alpha ( int ) \u2013 Number of alpha parameters. n_mRNA ( int ) \u2013 Number of mRNAs. n_reg ( int ) \u2013 Number of regulators. n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. beta_start_indices ( ndarray ) \u2013 Array of starting indices for the beta parameters. Returns: final_alpha ( ndarray ) \u2013 Final alpha parameters. final_beta ( ndarray ) \u2013 Final beta parameters. best_objectives ( ndarray ) \u2013 Best objectives from the Pareto front. final_x ( ndarray ) \u2013 Final optimization variables. print_alpha_mapping(mRNA_ids, reg_map, TF_ids, final_alpha) Print the mapping of transcription factors (TFs) to mRNAs with their corresponding alpha values. Parameters: mRNA_ids ( list ) \u2013 List of mRNA identifiers. reg_map ( dict ) \u2013 Mapping of genes to their regulators. TF_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha parameters (mRNA x TF). print_beta_mapping(TF_ids, final_beta, psite_labels_arr) Print the mapping of transcription factors (TFs) to their beta parameters. Parameters: TF_ids ( list ) \u2013 List of TF identifiers. final_beta ( ndarray ) \u2013 Final beta parameters (TF x \u03b2). psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF. Gradient-Based Algorithms tfopt.local.config.constants parse_args() tfopt.local CLI: bounds and loss selection. Defaults come from config.toml. tfopt.local.config.logconf tfopt.local.exporter.plotout plot_estimated_vs_observed(predictions, expression_matrix, gene_ids, time_points, regulators, tf_protein_matrix, tf_ids, num_targets, save_path=OUT_DIR) Plots the estimated vs observed values for a given set of genes and their corresponding TFs. Parameters: predictions ( ndarray ) \u2013 Predicted expression levels. expression_matrix ( ndarray ) \u2013 Observed expression levels. gene_ids ( list ) \u2013 List of gene identifiers. time_points ( ndarray ) \u2013 Time points for the experiments. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. tf_protein_matrix ( ndarray ) \u2013 Matrix of TF protein levels. tf_ids ( list ) \u2013 List of TF identifiers. num_targets ( int ) \u2013 Number of target genes to plot. save_path ( str , default: OUT_DIR ) \u2013 Directory to save the plots. plot_multistart_summary_runtime_overlay(summary_csv, out_path=None, figsize=(8, 8), x_col='rank', y_col='fun', c_col='runtime_s', success_col='success', cv_col='constr_violation', annotate_best=True) Creates a scatter plot visualizing multi-start optimization results with runtime overlay. This function reads a CSV summary of multiple optimization runs and generates a scatter plot showing the relationship between run rank and final objective value, with runtime (or iterations) represented as color intensity. Successful and feasible runs are emphasized while unsuccessful or infeasible runs are shown with reduced opacity. Parameters: summary_csv ( str or Path ) \u2013 Path to the CSV file containing multi-start optimization results. out_path ( str or Path , default: None ) \u2013 Path to save the output figure. If None, figure is not saved. Defaults to None. figsize ( tuple , default: (8, 8) ) \u2013 Figure size as (width, height) in inches. Defaults to (8, 8). x_col ( str , default: 'rank' ) \u2013 Column name for x-axis (run rank). If missing, will be created from y_col ranking. Defaults to \"rank\". y_col ( str , default: 'fun' ) \u2013 Column name for y-axis (final objective value). Defaults to \"fun\". c_col ( str , default: 'runtime_s' ) \u2013 Column name for color mapping (typically runtime). Falls back to \"nit\" (iterations) if not found. Defaults to \"runtime_s\". success_col ( str , default: 'success' ) \u2013 Column name indicating optimization success status. Defaults to \"success\". cv_col ( str , default: 'constr_violation' ) \u2013 Column name for constraint violation values. Falls back to common alternatives if not found. Defaults to \"constr_violation\". annotate_best ( bool , default: True ) \u2013 Whether to annotate the best (rank 1) point on the plot. Defaults to True. Returns: tuple \u2013 A tuple containing: - fig (matplotlib.figure.Figure): The generated figure object. - ax (matplotlib.axes.Axes): The axes object of the plot. - df (pd.DataFrame): The processed DataFrame with sorted results. Notes Points are considered feasible if constraint violation <= 1e-8 Infeasible or unsuccessful runs are plotted with reduced opacity (0.25) If rank column is missing, it's automatically generated from objective values If runtime column is missing, falls back to iteration count or constant color tfopt.local.exporter.sheetutils save_results_to_excel(gene_ids, tf_ids, final_alpha, final_beta, psite_labels_arr, expression_matrix, predictions, objective_value, reg_map, filename=OUT_FILE) Save the optimization results to an Excel file. Parameters: gene_ids ( list ) \u2013 List of gene identifiers. tf_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha values. final_beta ( ndarray ) \u2013 Final beta values. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels. expression_matrix ( ndarray ) \u2013 Observed expression levels. predictions ( ndarray ) \u2013 Predicted expression levels. objective_value ( float ) \u2013 Objective value from optimization. reg_map ( dict ) \u2013 Mapping of genes to regulators. filename ( str , default: OUT_FILE ) \u2013 Path to the output Excel file. export_multistart_results(results) Export multiple multistart optimization results to an Excel file. Parameters: results ( list ) \u2013 List of optimization results, each containing attributes like 'start_id', 'fun', 'success', etc. Returns: \u2013 None save_multistart_solutions_npz(all_results, out_path) Saves multistart optimization solutions to a compressed .npz file format. This function aggregates optimization results into a structured format and saves them in a compressed NumPy .npz file. It processes the solutions, extracting relevant attributes such as optimization variables, function values, success status, and starting IDs, before saving them for later use. Parameters: all_results \u2013 list A list of optimization result objects. Each result object must have the attributes x (optimization solution vector) and fun (objective function value). Optionally, it can have success (indicating whether the optimization succeeded, defaults to False if not present) and start_id (identifier of the starting point, defaults to -1 if not present). out_path \u2013 str or Path The file path where the compressed .npz file will be saved. The path will be converted into a pathlib Path object if it is not already one. tfopt.local.objfn.minfn objective_(x, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type, lam1=1e-06, lam2=1e-06) Originally implemented by Julius Normann. This version has been modified and optimized for consistency & speed in submodules by Abhinav Mishra. Computes a loss value using one of several loss functions. Parameters: x \u2013 Decision vector. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes, n_TF \u2013 Number of genes and TF respectively. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Integer indicating the loss type (0: MSE, 1: MAE, 2: soft L1, 3: Cauchy, 4: Arctan, 5: Elastic Net, 6: Tikhonov). Returns: loss \u2013 The computed loss (a scalar). compute_predictions(x, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites) Computes the predicted expression matrix based on the decision vector x. Parameters: x \u2013 Decision vector. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes \u2013 Number of genes. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. Returns: predictions \u2013 (n_genes x T_use) predicted gene expression values. objective_wrapper(x, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type) Wrapper function for the objective function. Parameters: x \u2013 Decision vector. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes \u2013 Number of genes. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Integer indicating the loss type. Returns: loss \u2013 The computed loss (a scalar). tfopt.local.opt.optrun run_optimizer(x0, bounds, lin_cons, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type) Runs the optimization algorithm to minimize the objective function. Parameters: x0 \u2013 Initial guess for the optimization variables. bounds \u2013 Bounds for the optimization variables. lin_cons \u2013 Linear constraints for the optimization problem. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes, n_TF \u2013 Number of genes and TF respectively. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Type of loss function to use. Returns: result : Result of the optimization process, including the optimized parameters and objective value. generate_multistart_x0(x0: np.ndarray, bounds: Sequence[Tuple[float, float]], n_starts: int, seed: int = 0, jitter_frac: float = 0.05, p_random: float = 0.3) -> List[np.ndarray] Generates multiple starting points for multi-start optimization. Builds a diverse list of starting points mostly: jitter around baseline x0 some: fully random within bounds jitter_frac is relative to (ub - lb). p_random is fraction of starts that are random-in-bounds. Returns: List [ ndarray ] \u2013 List[np.ndarray]: A list of starting points for optimization. run_optimizer_multistart(x0: np.ndarray, bounds, lin_cons, expression_matrix, regulators, tf_protein_matrix, psite_tensor, n_reg, T_use, n_genes, beta_start_indices, num_psites, loss_type, run_optimizer_func, cfg: Optional[MultiStartConfig] = None, polish: bool = True) Executes a multistart optimization loop with parallelization and optional polishing to find the best solution across multiple starting points. The function leverages a parallel approach for running multiple optimizations, selects the best result based on predefined sorting criteria, and optionally refines it. Parameters: x0 ( ndarray ) \u2013 Initial guess for the optimization variables. bounds \u2013 Bounds for the optimization variables, typically a sequence of (min, max) pairs. lin_cons \u2013 Linear constraints for the optimizer, defined as per specific optimizer requirements. expression_matrix \u2013 Input gene expression data utilized in the optimization process. regulators \u2013 Regulatory inputs or factors influencing the optimization process. tf_protein_matrix \u2013 Matrix representing transcription factor proteins relevant to the process. psite_tensor \u2013 Tensor containing phosphorylation site data used in the computations. n_reg \u2013 Number of regulators involved in the optimization. T_use \u2013 Specific configuration parameter determining time or iteration usage. n_genes \u2013 Number of genes considered within the problem scope. beta_start_indices \u2013 Indices indicating the start positions of beta parameters in the optimization. num_psites \u2013 Total number of phosphorylation sites accounted for in optimization. loss_type \u2013 Type of loss function used for evaluating optimization performance. run_optimizer_func \u2013 Optimization function to be executed for each starting point. cfg ( Optional [ MultiStartConfig ] , default: None ) \u2013 Configuration object specifying multistart parameters such as number of starts, parallelization settings, and randomness. polish ( bool , default: True ) \u2013 Indicates whether to perform a final optimization run initialized at the best solution. Defaults to True. Returns: Tuple \u2013 A tuple containing: - The best result as determined by sorting criteria. - A list of sorted optimization results from all starting points. tfopt.local.optcon.construct build_fixed_arrays(gene_ids, expression_matrix, tf_ids, tf_protein, tf_psite_data, tf_psite_labels, reg_map) Builds fixed-shape arrays from the input data. Parameters: - gene_ids \u2013 list of mRNA identifiers. - expression_matrix \u2013 array of shape (n_genes, T) with mRNA expression levels. - tf_ids \u2013 list of TF identifiers. - tf_protein \u2013 dict mapping TFs to their protein levels. - tf_psite_data \u2013 dict mapping TFs to their phosphorylation sites. - tf_psite_labels \u2013 dict mapping TFs to their phosphorylation site labels. - reg_map \u2013 mapping of genes to their regulators (TFs). Returns: \u2013 expression_matrix: array of shape (n_genes, T) with mRNA expression levels. \u2013 regulators: array of shape (n_genes, n_reg) with TF indices. \u2013 tf_protein_matrix: array of shape (n_TF, T) with TF protein levels. \u2013 psite_tensor: array of shape (n_TF, n_psite_max, T) with phosphorylation sites. \u2013 n_reg: number of regulators. \u2013 n_psite_max: maximum number of phosphorylation sites across all TFs. \u2013 psite_labels_arr: list of labels for each TF's phosphorylation sites. \u2013 num_psites: array indicating the number of phosphorylation sites for each TF. constraint_alpha_func(x, n_genes, n_reg) For each gene, the sum of its alpha parameters must equal 1. Parameters: x ( ndarray ) \u2013 Decision vector. n_genes ( int ) \u2013 Number of genes. n_reg ( int ) \u2013 Number of regulators. Returns: \u2013 np.ndarray: Array of constraints. constraint_beta_func(x, n_alpha, n_TF, beta_start_indices, num_psites, no_psite_tf) For each TF, the sum of its beta parameters must equal 1. Parameters: x ( ndarray ) \u2013 Decision vector. n_alpha ( int ) \u2013 Number of alpha parameters. n_TF ( int ) \u2013 Number of transcription factors. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( list ) \u2013 List indicating if a TF has no phosphorylation site. Returns: \u2013 np.ndarray: Array of constraints. build_linear_constraints(n_genes, n_TF, n_reg, n_alpha, beta_start_indices, num_psites, no_psite_tf) Build linear constraints for the transcription factor optimization problem. Parameters: n_genes ( int ) \u2013 Number of genes. n_TF ( int ) \u2013 Number of transcription factors. n_reg ( int ) \u2013 Number of regulators. n_alpha ( int ) \u2013 Number of alpha parameters. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( list ) \u2013 List indicating if a TF has no phosphorylation site. Returns: list \u2013 List of linear constraints. tfopt.local.optcon.filter load_and_filter_data() Load and filter data for the optimization problem. Returns: \u2013 gene_ids (list): List of gene IDs. \u2013 expr_matrix (np.ndarray): Gene expression matrix. \u2013 expr_time_cols (list): Time columns for expression data. \u2013 tf_ids (list): List of transcription factor IDs. \u2013 tf_protein (dict): Dictionary mapping TF IDs to their protein data. \u2013 tf_psite_data (dict): Dictionary mapping TF IDs to their phosphorylation site data. \u2013 tf_psite_labels (dict): Dictionary mapping TF IDs to their phosphorylation site labels. \u2013 tf_time_cols (list): Time columns for TF data. \u2013 reg_map (dict): Regulation map, mapping gene IDs to their regulators. prepare_data(gene_ids, expr_matrix, tf_ids, tf_protein, tf_psite_data, tf_psite_labels, tf_time_cols, reg_map) Prepares the data for optimization by filtering the expression matrix to match the number of time points and building fixed arrays. Parameters: gene_ids ( list ) \u2013 List of gene IDs. expr_matrix ( ndarray ) \u2013 Gene expression matrix. tf_ids ( list ) \u2013 List of transcription factor IDs. tf_protein ( dict ) \u2013 Dictionary mapping TF IDs to their protein data. tf_psite_data ( dict ) \u2013 Dictionary mapping TF IDs to their phosphorylation site data. tf_psite_labels ( dict ) \u2013 Dictionary mapping TF IDs to their phosphorylation site labels. tf_time_cols ( list ) \u2013 Time columns for TF data. reg_map ( dict ) \u2013 Regulation map, mapping gene IDs to their regulators. Returns: fixed_arrays (tuple): Tuple containing the fixed arrays: - expression_matrix: array of shape (n_genes, T) - regulators: array of shape (n_genes, n_reg) with indices into tf_ids. - tf_protein_matrix: array of shape (n_TF, T) - psite_tensor: array of shape (n_TF, n_psite_max, T), padded with zeros. - n_reg: maximum number of regulators per gene. - n_psite_max: maximum number of PSites among TFs. - psite_labels_arr: list (length n_TF) of lists of PSite names (padded with empty strings). - num_psites: array of length n_TF with the actual number of PSites for each TF. T_use (int): Number of time points used in the expression matrix. tfopt.local.utils.iodata min_max_normalize(df, custom_max=None) Row-wise (per-sample) min-max normalize time-series columns starting with 'x'. Parameters: df ( DataFrame ) \u2013 Input DataFrame with time-series columns (x1-xN). custom_max ( float , default: None ) \u2013 If given, used as max for all rows. Returns: \u2013 pd.DataFrame: Normalized DataFrame with same shape. load_expression_data(filename=INPUT3) Loads gene expression (mRNA) data. Parameters: filename ( str , default: INPUT3 ) \u2013 Path to the CSV file containing mRNA data. Returns: \u2013 gene_ids: List of gene identifiers (strings). \u2013 expression_matrix: Matrix of gene expression data (numpy array). \u2013 time_cols: List of time columns (excluding \"GeneID\"). load_tf_protein_data(filename=INPUT1) Loads TF protein data along with PSite information. Parameters: filename ( str , default: INPUT1 ) \u2013 Path to the CSV file containing TF protein data. Returns: - tf_ids: List of TF identifiers (strings). - tf_protein: Dictionary mapping TF identifiers to their protein data (numpy array). - tf_psite_data: Dictionary mapping TF identifiers to their phosphorylation site data (list of numpy arrays). - tf_psite_labels: Dictionary mapping TF identifiers to their phosphorylation site labels (list of strings). - time_cols: List of time columns (excluding \"GeneID\" and \"Psite\"). load_regulation(filename=INPUT4) Returns a mapping from gene (source) to a list of TFs (targets). Parameters: filename ( str , default: INPUT4 ) \u2013 Path to the CSV file containing regulation data. Returns: - reg_map: Dictionary mapping gene identifiers to lists of TF identifiers. summarize_stats(input3=INPUT3, input1=INPUT1, input4=INPUT4) Summarizes statistics for the expression data (input3) and TF protein data (input1). Parameters: input3 ( str , default: INPUT3 ) \u2013 Path to the expression data CSV file. input1 ( str , default: INPUT1 ) \u2013 Path to the TF protein data CSV file. input4 ( str , default: INPUT4 ) \u2013 Path to the mapping file CSV. create_report(results_dir: str, output_file: str = 'report.html') Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root results directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir). organize_output_files(*directories) Function to organize output files into protein-specific folders. Parameters: directories ( str , default: () ) \u2013 List of directories to organize. tfopt.local.utils.params get_optimization_parameters(expression_matrix, tf_protein_matrix, n_reg, T_use, psite_labels_arr, num_psites, lb, ub) Prepare the optimization parameters for the optimization problem. Parameters: expression_matrix ( ndarray ) \u2013 Gene expression matrix. tf_protein_matrix ( ndarray ) \u2013 TF protein matrix. n_reg ( int ) \u2013 Number of regulators. T_use ( int ) \u2013 Number of time points to use. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF. num_psites ( ndarray ) \u2013 Array containing the number of phosphorylation sites for each TF. lb ( float ) \u2013 Lower bound for beta parameters. ub ( float ) \u2013 Upper bound for beta parameters. Returns: x0 (np.ndarray): Initial guess for the optimization variables. n_alpha (int): Number of alpha parameters. beta_start_indices (np.ndarray): Starting indices for beta parameters. bounds (list): List of bounds for the optimization variables. no_psite_tf (np.ndarray): Array indicating whether each TF has no phosphorylation sites. n_genes (int): Number of genes. n_TF (int): Number of transcription factors. postprocess_results(result, n_alpha, n_genes, n_reg, beta_start_indices, num_psites, reg_map, gene_ids, tf_ids, psite_labels_arr) Post-process the optimization results to extract the final alpha and beta parameters. Parameters: result ( OptimizeResult ) \u2013 The result of the optimization. n_alpha ( int ) \u2013 Number of alpha parameters. n_genes ( int ) \u2013 Number of genes. n_reg ( int ) \u2013 Number of regulators. beta_start_indices ( ndarray ) \u2013 Starting indices for beta parameters. num_psites ( ndarray ) \u2013 Array containing the number of phosphorylation sites for each TF. reg_map ( dict ) \u2013 Regulation map, mapping gene IDs to their regulators. gene_ids ( list ) \u2013 List of gene IDs. tf_ids ( list ) \u2013 List of transcription factor IDs. psite_labels_arr ( list ) \u2013 List of lists containing phosphorylation site labels. Returns: final_x ( ndarray ) \u2013 Final optimization result. final_alpha ( ndarray ) \u2013 Final alpha parameters reshaped into a matrix. final_beta ( ndarray ) \u2013 Final beta parameters reshaped into a matrix. Fitting Analysis tfopt.fitanalysis.helper Plotter A class to plot various analysis results from an Excel file. __init__(filepath, savepath) Initializes the Plotter instance by loading data from the Excel file. Args: filepath (str): Path to the Excel file containing analysis results. savepath (str): Directory where the plots will be saved. load_data() Loads data from the specified Excel file. Args: filepath (str): Path to the Excel file. savepath (str): Directory where the plots will be saved. plot_alpha_distribution() Plots the distribution of alpha parameter values grouped by transcription factors (TFs) using a strip plot. plot_beta_barplots() Processes the beta values DataFrame and creates a separate bar plot for each unique transcription factor (TF). plot_heatmap_abs_residuals() Plots a heatmap of the absolute values of the residuals. plot_goodness_of_fit() Creates a scatter plot comparing observed vs. estimated values, fits a linear regression model, plots the 95% confidence interval, and labels points outside the confidence interval. plot_kld() Plots the Kullback-Leibler Divergence (KLD) for each mRNA. The KLD is calculated between the observed and estimated distributions of the mRNA expression levels. plot_pca() Plots a PCA (Principal Component Analysis) of the observed and estimated values. plot_boxplot_alpha() Plots a boxplot of the alpha values. plot_boxplot_beta() Plots a boxplot of the beta values. plot_cdf_alpha() Plots the cumulative distribution function (CDF) of the alpha values. plot_cdf_beta() Plots the cumulative distribution function (CDF) of the beta values. plot_time_wise_residuals() Plots the residuals over time for each mRNA. ODE Modelling & Parameter Estimation Configuration config.cli Command\u2011line entry point for the phoskintime pipeline. Usage Come one level up from the package root, it should be the working directory (where you can see the project directory). run everything with the default (local) solver python phoskintime all run only preprocessing python phoskintime prep run tfopt with local flavour python phoskintime tfopt --mode local run tfopt with evol flavour python phoskintime tfopt --mode evol run kinopt with local flavour python phoskintime kinopt --mode local run kinopt with evol flavour python phoskintime kinopt --mode evol run the model python phoskintime model prep() Preprocess data (processing.cleanup). tfopt(mode: str = typer.Option('local', help='local | evol'), conf: Path | None = typer.Option(None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.')) Transcription-Factor-mRNA Optimisation. Parameters: mode ( str , default: Option ('local', help='local | evol') ) \u2013 local | evol conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. Returns: None kinopt(mode: str = typer.Option('local', help='local | evol'), conf: Path | None = typer.Option(None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.')) Kinase-Phosphorylation Optimization. Parameters: mode ( str , default: Option ('local', help='local | evol') ) \u2013 local | evol conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. Returns: None model(conf: Path | None = typer.Option(None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to model config file. Uses defaults if omitted.')) Run the model (bin.main). Parameters: conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to model config file. Uses defaults if omitted.') ) \u2013 Path to model config file. Uses defaults if omitted. Returns: None all(tf_mode: str = typer.Option('local', help='tfopt mode: local | evol'), kin_mode: str = typer.Option('local', help='kinopt mode: local | evol'), tf_conf: Path | None = typer.Option(None, help='tfopt config file'), kin_conf: Path | None = typer.Option(None, help='kinopt config file'), model_conf: Path | None = typer.Option(None, help='model config file')) Run every stage in sequence. Preprocessing -> TF optimisation -> Kinase optimisation -> Model. Parameters: tf_mode ( str , default: Option ('local', help='tfopt mode: local | evol') ) \u2013 tfopt mode: local | evol kin_mode ( str , default: Option ('local', help='kinopt mode: local | evol') ) \u2013 kinopt mode: local | evol tf_conf ( Path | None , default: Option (None, help='tfopt config file') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. kin_conf ( Path | None , default: Option (None, help='kinopt config file') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. model_conf ( Path | None , default: Option (None, help='model config file') ) \u2013 Path to model config file. Uses defaults if omitted. Returns: None config.config parse_bound_pair(val) Parse a string representing a pair of bounds (lower, upper) into a tuple of floats. The upper bound can be 'inf' or 'infinity' to represent infinity. Raises ValueError if the input is not in the correct format. Args: val (str): The string to parse, e.g., \"0,3\" or \"0,infinity\". Returns: tuple: A tuple containing the lower and upper bounds as floats. parse_fix_value(val) Parse a fixed value or a list of fixed values from a string. If the input is a single value, it returns that value as a float. If the input is a comma-separated list, it returns a list of floats. Raises ValueError if the input is not in the correct format. Args: val (str): The string to parse, e.g., \"1.0\" or \"1.0,2.0\". Returns: float or list: The parsed fixed value(s) as a float or a list of floats. ensure_output_directory(directory) Parameters: directory ( str ) \u2013 The path to the directory to create. Returns: None parse_args() Parse command-line arguments for the PhosKinTime script. This function uses argparse to define and handle the command-line options. It includes options for setting bounds, fixed parameters, bootstrapping, profile estimation, and input file paths. The function returns the parsed arguments as a Namespace object. The arguments include: --A-bound, --B-bound, --C-bound, --D-bound, --Ssite-bound, --Dsite-bound, --bootstraps, --input-excel-protein, --input-excel-psite, --input-excel-rna. Returns: argparse.Namespace: The parsed command-line arguments. log_config(logger, bounds, args) Log the configuration settings for the PhosKinTime script. This function logs the parameter bounds bootstrapping iterations. It uses the provided logger to output the information. Parameters: logger ( Logger ) \u2013 The logger to use for logging. bounds ( dict ) \u2013 The parameter bounds. args ( Namespace ) \u2013 The command-line arguments. Returns: None extract_config(args) Extract configuration settings from command-line arguments. This function creates a dictionary containing the parameter bounds, bootstrapping iterations. The function returns the configuration dictionary. Parameters: args ( Namespace ) \u2013 The command-line arguments. Returns: dict: The configuration settings. score_fit(params, target, prediction, alpha=ALPHA_WEIGHT, beta=BETA_WEIGHT, gamma=GAMMA_WEIGHT, delta=DELTA_WEIGHT, mu=MU_WEIGHT) Calculate the score for the fit of a model to target data. The score is a weighted combination of various metrics including mean squared error (MSE), root mean squared error (RMSE), mean absolute error (MAE), variance, and regularization penalty. The weights for each metric can be adjusted using the parameters alpha, beta, gamma, and delta. The regularization penalty is controlled by the reg_penalty parameter. The function returns the calculated score. Args: params (np.ndarray): The model parameters. target (np.ndarray): The target data. prediction (np.ndarray): The predicted data. alpha (float): Weight for RMSE. beta (float): Weight for MAE. gamma (float): Weight for variance. delta (float): Weight for MSE. mu (float): Regularization penalty weight. Returns: float: The calculated score. future_times(n_new: int, ratio: Optional[float] = None, tp: np.ndarray = TIME_POINTS) -> np.ndarray Extend ttime points by n_new points, each spaced by multiplying the previous interval by ratio. If ratio is None, it is inferred from the last two points. Parameters: n_new ( int ) \u2013 Number of new time points to generate. ratio ( float , default: None ) \u2013 Ratio to multiply the previous interval. Defaults to None. tp ( ndarray , default: TIME_POINTS ) \u2013 Existing time points. Defaults to TIME_POINTS. Returns: np.ndarray: Extended time points. config.constants get_param_names_rand(num_psites: int) -> list Generate parameter names for the random model. Format: ['A', 'B', 'C', 'D'] + ['S1', 'S2', ..., 'S '] + [parameter names for all combinations of dephosphorylation sites]. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of parameter names. get_param_names_ds(num_psites: int) -> list Generate parameter names for distributive or successive models. Format: ['A', 'B', 'C', 'D'] + ['S1', 'S2', ..., 'S '] + ['D1', 'D2', ..., 'D ']. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of parameter names. generate_labels_rand(num_psites: int) -> list Generates labels for the states based on the number of phosphorylation sites for the random model. Returns a list with the base labels \"R\" and \"P\", followed by labels for all combinations of phosphorylated sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of state labels. generate_labels_ds(num_psites: int) -> list Generates labels for the states based on the number of phosphorylation sites for the distributive or successive models. Returns a list with the base labels \"R\" and \"P\", followed by labels for each individual phosphorylated state. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of state labels. location(path: str, label: str = None) -> str Returns a clickable hyperlink string for supported terminals using ANSI escape sequences. Parameters: path ( str ) \u2013 The file path or URL. label ( str , default: None ) \u2013 The display text for the link. Defaults to the path if not provided. Returns: str ( str ) \u2013 A string that, when printed, shows a clickable link in terminals that support ANSI hyperlinks. get_number_of_params_rand(num_psites) Calculate the number of parameters required for the ODE system based on the number of phosphorylation sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites (1 to 4). Returns: int \u2013 Total number of parameters. get_bounds_rand(num_psites, ub=0, lower=0) Generate bounds for the ODE parameters based on the number of phosphorylation sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. lower ( float , default: 0 ) \u2013 Lower bound for parameters. upper ( float ) \u2013 Upper bound for parameters. Returns: list \u2013 List of bounds as [lower, upper] for each parameter. config.logconf ColoredFormatter Bases: Formatter Custom formatter to add colors to log messages and elapsed time. This formatter uses ANSI escape codes to colorize the log messages based on their severity level. It also includes a right-aligned clock that shows the elapsed time since the logger was initialized. The elapsed time is displayed in a human-readable format (e.g., \"1h 23m 45s\"). The formatter is designed to be used with a logger that has a console handler. The elapsed time is calculated from the time the logger was initialized and is displayed in a right-aligned format. The formatter also ensures that the log messages are padded to a specified width, which can be adjusted using the width parameter. The remove_ansi method is used to strip ANSI escape codes from the log message for accurate padding calculation. The format method is overridden to customize the log message format, including the timestamp, logger name, log level, and message. The setup_logger function is used to configure the logger with a file handler and a stream handler. The file handler writes log messages to a specified log file, while the stream handler outputs log messages to the console. The logger is set to the specified logging level, and the log file is created in the specified directory. The log file is rotated based on size, and old log files are backed up. format(record) Format the log record with colors and elapsed time. This method overrides the default format method to customize the log message format. It includes the timestamp, logger name, log level, and message. remove_ansi(s) staticmethod Remove ANSI escape codes from a string. setup_logger(name='phoskintime', log_file=None, level=logging.DEBUG, log_dir=LOG_DIR, rotate=True, max_bytes=2 * 1024 * 1024, backup_count=5, mp_file_logging='main_only') Setup a logger with colored output and file logging. This function creates a logger with colored output for console messages :param name: :param log_file: :param level: :param log_dir: :param rotate: :param max_bytes: :param backup_count: :param mp_file_logging: - \"off\": disable file logging - \"main_only\": file logging only in main process - \"per_process\": file logging in each process :return: logger Core Functions paramest.normest worker_find_lambda(lam: float, gene: str, target: np.ndarray, p0: np.ndarray, time_points: np.ndarray, free_bounds: Tuple[np.ndarray, np.ndarray], init_cond: np.ndarray, num_psites: int, p_data: np.ndarray, pr_data: np.ndarray) -> Tuple[float, float, str] Worker function for a single lambda value. Parameters: lam ( float ) \u2013 Regularization parameter. gene ( str ) \u2013 Gene name. target ( ndarray ) \u2013 Target data. p0 ( ndarray ) \u2013 Initial parameter guess. time_points ( ndarray ) \u2013 Time points for the model fitting. free_bounds ( Tuple [ ndarray , ndarray ] ) \u2013 Parameter bounds for the optimization. init_cond ( ndarray ) \u2013 Initial conditions for the ODE solver. num_psites ( int ) \u2013 Number of phosphorylation sites. p_data ( ndarray ) \u2013 Measurement data for protein-phospho. pr_data ( ndarray ) \u2013 Reference data for protein. Returns: Tuple [ float , float , str ] \u2013 Tuple containing the lambda value, score, and weight key. find_best_lambda(gene: str, target: np.ndarray, p0: np.ndarray, time_points: np.ndarray, free_bounds: Tuple[np.ndarray, np.ndarray], init_cond: np.ndarray, num_psites: int, p_data: np.ndarray, pr_data: np.ndarray, lambdas=np.logspace(-2, 0, 10), max_workers: int = 4, per_lambda_timeout: float = 1800.0) -> Tuple[float, str] Finds best lambda_reg to use in model_func. normest(gene, pr_data, p_data, r_data, init_cond, num_psites, time_points, bounds, bootstraps, use_regularization=USE_REGULARIZATION) Function to estimate parameters for a given gene using ODE models. Parameters: gene \u2013 Gene name. pr_data \u2013 Protein data. p_data \u2013 Phosphorylation data. r_data \u2013 Reference data. init_cond \u2013 Initial conditions for the ODE solver. num_psites \u2013 Number of phosphorylation sites. time_points \u2013 Time points for the model fitting. bounds \u2013 Parameter bounds for the optimization. bootstraps \u2013 Number of bootstrap iterations. use_regularization \u2013 Whether to use regularization in the fitting process. Returns: \u2013 Tuple containing estimated parameters, model fits, error values, and regularization term. paramest.toggle estimate_parameters(gene, pr_data, p_data, r_data, init_cond, num_psites, time_points, bounds, bootstraps) This function allows for the selection of the estimation mode and handles the parameter estimation process accordingly. Parameters: gene ( str ) \u2013 Gene name. pr_data ( array ) \u2013 Array of protein data. p_data ( array ) \u2013 Array of protein-phospho data. r_data ( array ) \u2013 Array of RNA data. init_cond ( array ) \u2013 Initial conditions for the model. num_psites ( int ) \u2013 Number of phosphorylation sites. time_points ( array ) \u2013 Time points for the data. bounds ( tuple ) \u2013 Bounds for the parameter estimation. bootstraps ( int ) \u2013 Number of bootstrap samples. Returns: model_fits ( list ) \u2013 List of model fits. estimated_params ( array ) \u2013 Estimated parameters. seq_model_fit ( array ) \u2013 Sequence model fit. errors ( array ) \u2013 Errors in the estimation. reg_term ( float ) \u2013 Regularization term. Weights for Curve Fitting models.weights early_emphasis(pr_data, p_data, time_points, num_psites) Function that calculates custom weights for early time points in a dataset. Parameters: pr_data \u2013 2D numpy array of shape (num_psites, n_times) p_data \u2013 2D numpy array of shape (num_psites, n_times) time_points \u2013 1D numpy array of time points num_psites \u2013 Number of phosphorylation sites Returns: custom_weights \u2013 1D numpy array of weights for early time points get_protein_weights(gene, input1_path=Path(__file__).resolve().parent.parent / 'processing' / 'input1_wstd.csv', input2_path=Path(__file__).resolve().parent.parent / 'data' / 'input2.csv') Function to extract weights for a specific gene from the input files. Parameters: gene ( str ) \u2013 Gene ID to filter the weights. input1_path ( Path , default: parent / 'processing' / 'input1_wstd.csv' ) \u2013 Path to the input1_wstd.csv file. input2_path ( Path , default: parent / 'data' / 'input2.csv' ) \u2013 Path to the input2.csv file. Returns: weights ( ndarray ) \u2013 Extracted weights for the specified gene. full_weight(p_data_weight, use_regularization, reg_len) Function to create a full weight array for parameter estimation. Parameters: p_data_weight ( ndarray ) \u2013 The weight data to be processed. use_regularization ( bool ) \u2013 Flag to indicate if regularization is used. reg_len ( int ) \u2013 Length of the regularization term. Returns: \u2013 numpy.ndarray: The full weight array. get_weight_options(target, t_target, num_psites, use_regularization, reg_len, early_weights, ms_gauss_weights) Function to calculate weights for parameter estimation based on the target data and time points. Parameters: target ( ndarray ) \u2013 The target data for which weights are calculated. t_target ( ndarray ) \u2013 The time points corresponding to the target data. num_psites ( int ) \u2013 Number of phosphorylation sites. use_regularization ( bool ) \u2013 Flag to indicate if regularization is used. reg_len ( int ) \u2013 Length of the regularization term. early_weights ( ndarray ) \u2013 Weights for early time points. ms_gauss_weights ( ndarray ) \u2013 Weights based on Gaussian distribution. Returns: dict \u2013 A dictionary containing different weight options. Parameter Estimation paramest.core process_gene(gene, protein_data, kinase_data, mrna_data, time_points, bounds, bootstraps=0, out_dir=OUT_DIR) Process a single gene by estimating its parameters and generating plots. Parameters: gene ( str ) \u2013 Gene name. protein_data ( DataFrame ) \u2013 DataFrame containing protein-only data. kinase_data ( DataFrame ) \u2013 DataFrame containing kinase data. mrna_data ( DataFrame ) \u2013 DataFrame containing mRNA data. time_points ( list ) \u2013 List of time points for the experiment. bounds ( tuple ) \u2013 Bounds for parameter estimation. bootstraps ( int , default: 0 ) \u2013 Number of bootstrap iterations. Defaults to 0. out_dir ( str , default: OUT_DIR ) \u2013 Output directory for saving results. Defaults to OUT_DIR. Returns: \u2013 gene: The gene being processed. \u2013 estimated_params: Estimated parameters for the gene. \u2013 model_fits: Model fits for the gene. \u2013 seq_model_fit: Sequential model fit for the gene. \u2013 errors: Error metrics (MSE, MAE). \u2013 final_params: Final estimated parameters. \u2013 param_df: DataFrame of estimated parameters. \u2013 gene_psite_data: Dictionary of gene-specific data. \u2013 psite_labels: Labels for phosphorylation sites. \u2013 pca_result: PCA result for the gene. \u2013 ev: Explained variance for PCA. \u2013 tsne_result: t-SNE result for the gene. \u2013 perturbation_analysis: Sensitivity analysis results. \u2013 perturbation_curves_params: Trajectories with parameters for sensitivity analysis. \u2013 knockout_results: Dictionary of knockout results. \u2013 regularization: Regularization value used in parameter estimation. process_gene_wrapper(gene, protein_data, kinase_data, mrna_data, time_points, bounds, bootstraps, out_dir=OUT_DIR) Wrapper function to process a gene. Parameters: gene ( str ) \u2013 Gene name. protein_data ( DataFrame ) \u2013 DataFrame containing protein-only data. kinase_data ( DataFrame ) \u2013 DataFrame containing kinase data. mrna_data ( DataFrame ) \u2013 DataFrame containing mRNA data. time_points ( list ) \u2013 List of time points for the experiment. bounds ( tuple ) \u2013 Bounds for parameter estimation. bootstraps ( int ) \u2013 Number of bootstrap iterations. Defaults to 0. out_dir ( str , default: OUT_DIR ) \u2013 Output directory for saving results. Defaults to OUT_DIR. Returns: dict \u2013 A dictionary containing the results of the gene processing. Confidence Intervals using Linearization paramest.identifiability.ci confidence_intervals(gene, popt, pcov, target, model, alpha_val=0.05) Computes the confidence intervals for parameter estimates using Wald Intervals approach. Parameters: gene ( str ) \u2013 Gene name. popt ( ndarray ) \u2013 Optimized parameter estimates. pcov ( ndarray ) \u2013 Covariance matrix of the optimized parameters. target ( ndarray ) \u2013 Target data. model ( ndarray ) \u2013 Model predictions. alpha_val ( float , default: 0.05 ) \u2013 Significance level for confidence intervals. Defaults to 0.05. Returns: dict \u2013 A dictionary containing the confidence intervals and other statistics. Knockout Analysis knockout.helper Perturbation & Parameter Sensitivity Analysis sensitivity.analysis compute_bound(value, perturbation=PERTURBATIONS_VALUE) Computes the lower and upper bounds for a given parameter value for sensitivity analysis and perturbations. Parameters: value ( float ) \u2013 The parameter value. perturbation ( float , default: PERTURBATIONS_VALUE ) \u2013 The perturbation factor. Returns: list \u2013 A list containing the lower and upper bounds. define_sensitivity_problem_rand(num_psites, values) Defines the Morris sensitivity analysis problem for the random model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. values ( list ) \u2013 List of parameter values. Returns: dict \u2013 A dictionary containing the number of variables, parameter names, and bounds. define_sensitivity_problem_ds(num_psites, values) Defines the Morris sensitivity analysis problem for the dynamic-site model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. values ( list ) \u2013 List of parameter values. Returns: dict \u2013 A dictionary containing the number of variables, parameter names, and bounds. Model Diagram models.diagram.helpers powerset(iterable) Return the list of all subsets (as frozensets) of the given iterable. Parameters: iterable \u2013 An iterable (e.g., list, set) to generate subsets from. Returns: A list of frozensets representing all subsets of the input iterable. state_label(state) Convert a set of phosphorylation sites into a node label. Parameters: state \u2013 A frozenset representing the phosphorylation state. Returns: A string representing the label for the node. create_random_diagram(x, num_sites, output_filename) Create a random phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram. create_distributive_diagram(x, num_sites, output_filename) Create a distributive phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram. create_successive_model(x, num_sites, output_filename) Create a successive phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram. Model Types models.distmod ode_core(y, t, A, B, C, D, S_rates, D_rates) The core ODE system for the distributive phosphorylation model. Parameters: y \u2013 array of concentrations t \u2013 time A \u2013 mRNA production rate B \u2013 mRNA degradation rate C \u2013 protein production rate D \u2013 protein degradation rate S_rates \u2013 phosphorylation rates for each site D_rates \u2013 dephosphorylation rates for each site Returns: dydt \u2013 array of derivatives unpack_params(params, num_psites) Function to unpack the parameters for the distributive ODE system. Parameters: params ( array ) \u2013 Parameter vector containing A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m. num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. S_rates ( array ) \u2013 Phosphorylation rates for each site. D_rates ( array ) \u2013 Dephosphorylation rates for each site. solve_ode(params, init_cond, num_psites, t) Solve the ODE system for the distributive phosphorylation model. Parameters: params \u2013 array of parameters init_cond \u2013 initial conditions num_psites \u2013 number of phosphorylation sites t \u2013 time points Returns: sol \u2013 solution of the ODE system P_fitted \u2013 phosphorylated sites models.randmod unpack_params(params, num_sites) Unpack parameters for the Random model. Parameters: params ( array ) \u2013 Parameter vector containing A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m. num_sites ( int ) \u2013 Number of phosphorylation sites. Returns: A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. S ( array ) \u2013 Phosphorylation rates for each site. Ddeg ( array ) \u2013 Degradation rates for phosphorylated states. ode_system(y, t, A, B, C, D, num_sites, S, Ddeg, mono_idx, forward, drop, fcounts, dcounts) Compute the time derivatives of a random phosphorylation ODE system. This function supports a large number of phosphorylation states by using precomputed transition indices to optimize speed. Parameters: y ( array ) \u2013 Current state vector [R, P, X_1, ..., X_m]. t ( float ) \u2013 Time (unused; present for compatibility with ODE solvers). A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. num_sites ( int ) \u2013 Number of phosphorylation sites. S ( array ) \u2013 Phosphorylation rates for each site. Ddeg ( array ) \u2013 Degradation rates for phosphorylated states. mono_idx ( array ) \u2013 Precomputed indices for mono-phosphorylated states. forward ( array ) \u2013 Forward phosphorylation target states. drop ( array ) \u2013 Dephosphorylation target states. fcounts ( array ) \u2013 Number of valid forward transitions for each state. dcounts ( array ) \u2013 Number of valid dephosphorylation transitions for each state. Returns: out ( array ) \u2013 Derivatives [dR, dP, dX_1, ..., dX_m]. solve_ode(popt, y0, num_sites, t) Integrate the ODE system for phosphorylation dynamics in random phosphorylation model. Parameters: popt ( array ) \u2013 Optimized parameter vector [A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m]. y0 ( array ) \u2013 Initial condition vector [R0, P0, X1_0, ..., Xm_0]. num_sites ( int ) \u2013 Number of phosphorylation sites. t ( array ) \u2013 Time points to integrate over. Returns: sol ( ndarray ) \u2013 Full ODE solution of shape (len(t), len(y0)). mono ( ndarray ) \u2013 1D array of fitted values for R (after OFFSET) and P states. models.succmod ode_core(y, t, A, B, C, D, S_rates, D_rates) The core of the ODE system for the successive ODE model. Parameters: y ( array ) \u2013 The current state of the system. t ( float ) \u2013 The current time. A ( float ) \u2013 The mRNA production rate. B ( float ) \u2013 The mRNA degradation rate. C ( float ) \u2013 The protein production rate. D ( float ) \u2013 The protein degradation rate. S_rates ( array ) \u2013 The phosphorylation rates for each site. D_rates ( array ) \u2013 The dephosphorylation rates for each site. Returns: dydt (np.array): The derivatives of the state variables. unpack_params(params, num_psites) Function to unpack the parameters for the ODE system. The parameters are expected to be in the following order: A, B, C, D, S_rates, D_rates where S_rates and D_rates are arrays of length num_psites. The function returns the unpacked parameters as separate variables. :param params: array of parameters :param num_psites: number of phosphorylation sites :return: A, B, C, D, S_rates, D_rates solve_ode(params, init_cond, num_psites, t) Solve the ODE system using the given parameters and initial conditions. The function integrates the ODE system over time and returns the solution. :param params: :param init_cond: :param num_psites: :param t: :return: solution, solution of phosphorylated sites Steady-State Calculation steady.initdist initial_condition(num_psites: int) -> list Calculates the initial steady-state conditions for a given number of phosphorylation sites for distributive phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions. steady.initrand initial_condition(num_psites: int) -> list Calculates the initial steady-state conditions for a given number of phosphorylation sites for random phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions. steady.initsucc initial_condition(num_psites: int) -> list Calculates the initial steady-state conditions for a given number of phosphorylation sites for successive phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions. Plotting plotting.plotting Plotter A class to encapsulate plotting functionalities for ODE model analysis. Attributes: gene ( str ) \u2013 The gene or experiment name. out_dir ( str ) \u2013 The directory where plots will be saved. color_palette ( list ) \u2013 List of color codes used for plotting. plot_parallel(solution: np.ndarray, labels: list) Plots a parallel coordinates plot for the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. labels ( list ) \u2013 List of labels for the features in the solution. pca_components(solution: np.ndarray, target_variance: float = 0.99) Plots a scree plot showing the explained variance ratio for PCA components. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. target_variance ( float , default: 0.99 ) \u2013 The target variance to explain. Defaults to 0.99. plot_pca(solution: np.ndarray, components: int = 3) Plots the PCA results for the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. components ( int , default: 3 ) \u2013 Number of PCA components to plot. Defaults to 3. Returns: tuple \u2013 PCA result and explained variance ratio. plot_tsne(solution: np.ndarray, perplexity: int = 30) Plots a t-SNE visualization of the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. perplexity ( int , default: 30 ) \u2013 The perplexity parameter for t-SNE. Defaults to 30. Returns: \u2013 np.ndarray: The t-SNE result. plot_param_series(estimated_params: list, param_names: list, time_points: np.ndarray) Plots the time series of estimated parameters over the given time points. Parameters: estimated_params ( list ) \u2013 List of estimated parameters. param_names ( list ) \u2013 List of parameter names. time_points ( ndarray ) \u2013 Array of time points. plot_profiles(data: pd.DataFrame) Plots the profiles of estimated parameters over time. Parameters: data ( DataFrame ) \u2013 DataFrame containing the time series data. plot_model_fit(model_fit: np.ndarray, Pr_data: np.ndarray, P_data: np.ndarray, R_data: np.ndarray, sol: np.ndarray, num_psites: int, psite_labels: list, time_points: np.ndarray) Plots the model fit for mRNA, protein, and phosphorylated species across time. Parameters: model_fit ( ndarray ) \u2013 Flattened model fit data (length = 9 + 14 + 14*num_psites). Pr_data ( ndarray ) \u2013 Protein data (14,). P_data ( ndarray ) \u2013 Phosphorylation data (num_psites + 2, 14). R_data ( ndarray ) \u2013 mRNA data (9,). sol ( ndarray ) \u2013 ODE solution array. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 Labels for phosphorylation sites. time_points ( ndarray ) \u2013 Time points (14,). plot_param_scatter(est_arr: np.ndarray, num_psites: int, time_vals: np.ndarray) Plots scatter and density plots for parameters. Parameters: est_arr ( ndarray ) \u2013 2D numpy array of estimated parameters. num_psites ( int ) \u2013 Number of phosphorylation sites. time_vals ( ndarray ) \u2013 Array of time values. plot_heatmap(param_value_df: pd.DataFrame) Parameters: param_value_df ( DataFrame ) \u2013 DataFrame containing parameter values with 'Protein' as one of the columns. plot_error_distribution(error_df: pd.DataFrame) Parameters: error_df ( DataFrame ) \u2013 DataFrame containing errors with 'MAE' as one of the columns. plot_gof(merged_data: pd.DataFrame) Plot the goodness of fit for the model. Parameters: merged_data ( DataFrame ) \u2013 Dataframe containing merged data. plot_kld(merged_data: pd.DataFrame) Plots the Kullback-Divergence for the model. Parameters: merged_data ( DataFrame ) \u2013 Dataframe containing merged data. plot_params_bar(ci_results: dict, param_labels: list = None) Plots bar plot for estimated parameter with 95% Confidence Interval. Parameters: ci_results ( dict ) \u2013 Dictionary containing the results of the confidence intervals. param_labels ( list , default: None ) \u2013 List of parameter labels. Defaults to None. plot_knockouts(results_dict: dict, num_psites: int, psite_labels: list) Plot wild-type and knockout simulation results for comparison. Parameters: results_dict ( dict ) \u2013 Dictionary containing simulation results. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 List of phosphorylation site labels. plot_top_param_pairs(excel_path: str) For each gene's '_perturbations' sheet in the Excel file, plot scatter plots for the parameter pairs with correlation. Parameters: excel_path ( str ) \u2013 Path to the Excel file. plot_model_perturbations(problem: dict, Si: dict, cutoff_idx: int, time_points: np.ndarray, n_sites: int, best_model_psite_solutions: np.ndarray, best_mrna_solutions: np.ndarray, best_protein_solutions: np.ndarray, psite_labels: list[str], protein_data_ref: np.ndarray, psite_data_ref: np.ndarray, rna_ref: np.ndarray, model_fit_sol: np.ndarray) -> None Plot the best model perturbations for the given data. Parameters: problem ( dict ) \u2013 The optimization problem. Si ( dict ) \u2013 The simulation index. cutoff_idx ( int ) \u2013 The cutoff index for the time points. time_points ( ndarray ) \u2013 The time points for the data. n_sites ( int ) \u2013 The number of phosphorylation sites. best_model_psite_solutions ( ndarray ) \u2013 The best model phosphorylation site solutions. best_mrna_solutions ( ndarray ) \u2013 The best model mRNA solutions. best_protein_solutions ( ndarray ) \u2013 The best model protein solutions. protein_ref \u2013 The reference data for the protein. psite_labels ( list [ str ] ) \u2013 The labels for the phosphorylation sites. psite_data_ref ( ndarray ) \u2013 The reference data for the phosphorylation sites. rna_ref ( ndarray ) \u2013 The reference data for mRNA. plot_time_state_grid(samples: np.ndarray, time_points: np.ndarray, state_names: list) Grid of strip plots per state showing variability across time. Parameters: samples ( ndarray ) \u2013 shape (n_samples, n_timepoints, n_states) time_points ( ndarray ) \u2013 array of time points state_names ( list ) \u2013 list of state names plot_phase_space(samples: np.ndarray, state_names: list) Phase space plots: one state vs another for each simulation. Parameters: samples ( ndarray ) \u2013 Shape (n_samples, n_timepoints, n_states) state_names ( list ) \u2013 List of state names (length = num_states) plot_future_fit(P_data: np.ndarray, R_data: np.ndarray, sol: np.ndarray, num_psites: int, psite_labels: list, time_points: np.ndarray) Plots the model fit for the future time points. Parameters: P_data ( ndarray ) \u2013 Data for phosphorylation sites. R_data ( ndarray ) \u2013 Data for mRNA. sol ( ndarray ) \u2013 Model solution. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 Labels for phosphorylation sites. time_points ( ndarray ) \u2013 Time points for the data. plot_regularization(excel_path: str) Read every ' _params' sheet in the Excel file, pull the Regularization value, and plot a horizontal bar chart of regularization vs. gene. Parameters: excel_path ( str ) \u2013 Path to the Excel file. plot_model_error(excel_path: str) Read every ' _params' sheet in the Excel file, pull the RMSE value, and plot a horizontal bar chart of RMSE vs. gene. Parameters: excel_path ( str ) \u2013 Path to the Excel file. Utility Functions utils.display ensure_output_directory(directory) Ensure the output directory exists. If it doesn't, create it. Parameters: directory ( str ) \u2013 Path to the output directory. load_data(excel_file, sheet='Estimated Values') Load data from an Excel file. The default sheet is \"Estimated Values\". Parameters: excel_file ( str ) \u2013 Path to the Excel file. sheet ( str , default: 'Estimated Values' ) \u2013 Name of the sheet to load. Default is \"Estimated Values\". Returns: \u2013 pd.DataFrame: DataFrame containing the data from the specified sheet. format_duration(seconds) Format a duration in seconds into a human-readable string. Parameters: seconds ( float ) \u2013 Duration in seconds. Returns: str: Formatted duration string. merge_obs_est(filename) Function to merge observed and estimated data from an Excel file. Parameters: filename ( str ) \u2013 Path to the Excel file containing observed and estimated data. Returns: \u2013 pd.DataFrame: Merged DataFrame containing observed and estimated values for each gene and Psite. save_result(results, excel_filename) Function to save results to an Excel file. Parameters: results ( list ) \u2013 List of dictionaries containing results for each gene. excel_filename ( str ) \u2013 Path to the output Excel file. create_report(results_dir: str, output_file: str = f'{model_type}_report.html') Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root result's directory. output_file ( str , default: f'{ model_type }_report.html' ) \u2013 Name of the generated global report file (placed inside results_dir). organize_output_files(directories: Iterable[Union[str, Path]]) Organize output files into protein-specific folders and a general folder. Parameters: directories ( Iterable [ Union [ str , Path ]] ) \u2013 List of directories to organize. utils.tables generate_tables(xlsx_file_path) Generate hierarchical tables from the XLSX file containing alpha and beta values. Parameters: xlsx_file_path ( str ) \u2013 Path to the XLSX file containing alpha and beta values. Returns: tuple \u2013 containing protein, psite, and the corresponding table. save_tables(tables, output_dir) Save the generated tables as LaTeX and CSV files. Parameters: tables ( list ) \u2013 List of tuples containing protein, psite, and the corresponding table. output_dir ( str ) \u2013 Directory to save the LaTeX and CSV files. save_master_table(folder='latex', output_file='latex/all_tables.tex') Save a master LaTeX file that includes all individual LaTeX files from the specified folder. Parameters: folder ( str , default: 'latex' ) \u2013 The folder containing the individual LaTeX files. output_file ( str , default: 'latex/all_tables.tex' ) \u2013 The name of the master LaTeX file to be created. utils.latexit generate_latex_table(df, sheet_name) Generate LaTeX code for a table from a DataFrame. Args: df (pd.DataFrame): DataFrame to convert to LaTeX. sheet_name (str): Name of the sheet for caption and label. Returns: str: LaTeX code for the table. generate_latex_image(image_filename) Generate LaTeX code for an image. Parameters: image_filename ( str ) \u2013 Path to the image file. Returns: str: LaTeX code for the image. main(input_dir) Main function to process Excel and PNG files in the input directory and generate LaTeX code. Parameters: input_dir ( str ) \u2013 Directory containing Excel and PNG files.","title":"Reference"},{"location":"reference.html#api-reference","text":"","title":"API Reference"},{"location":"reference.html#data-standardization-cleanup","text":"","title":"Data Standardization &amp; Cleanup"},{"location":"reference.html#processing.cleanup","text":"","title":"cleanup"},{"location":"reference.html#processing.cleanup.process_collecttri","text":"Processes the CollecTRI file to clean and filter mRNA-TF interactions. Removes complex interactions, filters by target genes, and saves the result.","title":"process_collecttri"},{"location":"reference.html#processing.cleanup.format_site","text":"Formats a phosphorylation site string. If the input is NaN or an empty string, returns an empty string. If the input contains an underscore ('_'), splits the string into two parts, converts the first part to uppercase, and appends the second part unchanged. Otherwise, converts the entire string to uppercase. Parameters: site ( str ) \u2013 The phosphorylation site string to format. Returns: str \u2013 The formatted phosphorylation site string.","title":"format_site"},{"location":"reference.html#processing.cleanup.process_msgauss","text":"Processes the MS Gaussian data file to generate time series data.","title":"process_msgauss"},{"location":"reference.html#processing.cleanup.process_msgauss_std","text":"Processes the MS Gaussian data file to compute transformed means and standard deviations.","title":"process_msgauss_std"},{"location":"reference.html#processing.cleanup.process_routlimma","text":"Processes the Rout Limma table to generate time series data for mRNA.","title":"process_routlimma"},{"location":"reference.html#processing.cleanup.update_gene_symbols","text":"Updates the GeneID column in a CSV file by mapping GeneIDs to gene/protein symbols. Parameters: filename ( str ) \u2013 The path to the CSV file to be updated. The file must contain a 'GeneID' column.","title":"update_gene_symbols"},{"location":"reference.html#processing.cleanup.move_processed_files","text":"Moves or copies processed files to their respective directories.","title":"move_processed_files"},{"location":"reference.html#optimization-results-mapping","text":"","title":"Optimization Results Mapping"},{"location":"reference.html#processing.map","text":"","title":"map"},{"location":"reference.html#processing.map.map_optimization_results","text":"Reads the TF-mRNA optimization results from an Excel file and maps mRNA to each TF. Parameters: tf_file_path \u2013 Path to the Excel file containing TF-mRNA optimization results. kin_file_path \u2013 Path to the Excel file containing Kinase-Phosphorylation optimization results. sheet_name \u2013 The name of the sheet in the Excel file to read from. Default is 'Alpha Values'. Returns: \u2013 pd.DataFrame: A DataFrame containing the mapped TF, mRNA, Psite, and Kinase information.","title":"map_optimization_results"},{"location":"reference.html#processing.map.create_cytoscape_table","text":"Creates a Cytoscape-compatible edge table from a mapping file. Parameters: mapping_csv_path ( str ) \u2013 Path to the input CSV file with columns: TF, TF_strength, mRNA, Psite, Kinase, Kinase_strength Returns: table ( DataFrame ) \u2013 Edge table with columns [Source, Target, Interaction, Strength]","title":"create_cytoscape_table"},{"location":"reference.html#processing.map.add_kinetic_strength_columns","text":"Adds kinetic strength columns to the mapping files based on the provided Excel file. Parameters: mapping_path ( str ) \u2013 Path to the first mapping file. mapping__path ( str ) \u2013 Path to the second mapping file. excel_path ( str ) \u2013 Path to the Excel file containing kinetic strength data. suffix ( str ) \u2013 Suffix to append to the output files.","title":"add_kinetic_strength_columns"},{"location":"reference.html#processing.map.generate_nodes","text":"Infers node types and aggregates all phosphorylation sites per target node from phosphorylation edges. Parameters: edge_df ( DataFrame ) \u2013 Must have columns ['Source', 'Target', 'Interaction', 'Psite'] Returns: \u2013 pd.DataFrame: DataFrame with columns ['Node', 'Type', 'Psite']","title":"generate_nodes"},{"location":"reference.html#kinase-phosphorylation-optimization","text":"","title":"Kinase-Phosphorylation Optimization"},{"location":"reference.html#evolutionary-algorithms","text":"","title":"Evolutionary Algorithms"},{"location":"reference.html#kinopt.evol.config.constants","text":"","title":"constants"},{"location":"reference.html#kinopt.evol.config.logconf","text":"","title":"logconf"},{"location":"reference.html#kinopt.evol.config.logconf.ColoredFormatter","text":"Bases: Formatter","title":"ColoredFormatter"},{"location":"reference.html#kinopt.evol.config.logconf.ColoredFormatter.format","text":"Format the log record with ANSI color codes and elapsed time. Parameters: record ( LogRecord ) \u2013 The log record to format. Returns: str: The formatted log message with ANSI color codes.","title":"format"},{"location":"reference.html#kinopt.evol.config.logconf.ColoredFormatter.remove_ansi","text":"Remove ANSI escape codes from a string. Parameters: s ( str ) \u2013 The string from which to remove ANSI escape codes. Returns: str: The string without ANSI escape codes.","title":"remove_ansi"},{"location":"reference.html#kinopt.evol.config.logconf.setup_logger","text":"Function to set up a logger with both file and console handlers. Parameters: name ( str , default: 'phoskintime' ) \u2013 Name of the logger. log_file ( str , default: None ) \u2013 Path to the log file. If None, a default path is generated. level ( int , default: DEBUG ) \u2013 Logging level (e.g., logging.DEBUG, logging.INFO). log_dir ( str , default: LOG_DIR ) \u2013 Directory where log files are stored. rotate ( bool , default: True ) \u2013 Whether to use rotating file handler. max_bytes ( int , default: 2 * 1024 * 1024 ) \u2013 Maximum size of log file before rotation. backup_count ( int , default: 5 ) \u2013 Number of backup files to keep. Returns: logger ( Logger ) \u2013 Configured logger instance.","title":"setup_logger"},{"location":"reference.html#kinopt.evol.exporter.plotout","text":"","title":"plotout"},{"location":"reference.html#kinopt.evol.exporter.plotout.plot_residuals_for_gene","text":"Generates and saves combined residual-related plots for one gene with all psites in the legend. Parameters: gene ( str ) \u2013 Gene identifier. gene_data ( dict ) \u2013 Dictionary with keys 'psites', 'observed', 'estimated', and 'residuals' containing data for all psites. TIME_POINTS ( ndarray or list ) \u2013 Time points corresponding to the series.","title":"plot_residuals_for_gene"},{"location":"reference.html#kinopt.evol.exporter.plotout.opt_analyze_nsga","text":"Function to generate and save various plots related to optimization results. Parameters: problem \u2013 The optimization problem instance. result \u2013 The result of the optimization run. F \u2013 Objective function values. pairs \u2013 Pairs of objectives to plot. approx_ideal \u2013 Approximate ideal point in objective space. approx_nadir \u2013 Approximate nadir point in objective space. asf_i \u2013 Index of the best solution in terms of the augmented weighted sum. pseudo_i \u2013 Index of the pseudo weights. n_evals \u2013 Number of evaluations at each generation. hv \u2013 Hypervolume values. hist \u2013 History of the optimization process. val \u2013 Values for convergence plot. hist_cv_avg \u2013 Average constraint violation history. k \u2013 Number of generations. igd \u2013 Inverted generational distance values. best_objectives \u2013 Best objectives found during the optimization process. waterfall_df \u2013 DataFrame containing waterfall plot data. convergence_df \u2013 DataFrame containing convergence data. alpha_values \u2013 Dictionary containing alpha values for parameters. beta_values \u2013 Dictionary containing beta values for parameters. Returns: \u2013 None","title":"opt_analyze_nsga"},{"location":"reference.html#kinopt.evol.exporter.plotout.opt_analyze_de","text":"Function to generate and save various plots related to optimization results. Parameters: long_df ( DataFrame ) \u2013 DataFrame containing parameter values and objective function values. convergence_df ( DataFrame ) \u2013 DataFrame containing convergence data. ordered_optimizer_runs ( DataFrame ) \u2013 DataFrame containing ordered optimizer runs. x_values ( list ) \u2013 X-axis values for the waterfall plot. y_values ( list ) \u2013 Y-axis values for the waterfall plot. val ( list ) \u2013 Values for the convergence plot. Returns: \u2013 None","title":"opt_analyze_de"},{"location":"reference.html#kinopt.evol.exporter.sheetutils","text":"","title":"sheetutils"},{"location":"reference.html#kinopt.evol.exporter.sheetutils.output_results","text":"Function to output results to an Excel file. Parameters: P_initial ( dict ) \u2013 Dictionary with initial parameters. P_init_dense ( ndarray ) \u2013 Dense matrix of initial parameters. P_estimated ( ndarray ) \u2013 Dense matrix of estimated parameters. residuals ( ndarray ) \u2013 Dense matrix of residuals. alpha_values ( dict ) \u2013 Dictionary with alpha values. beta_values ( dict ) \u2013 Dictionary with beta values. result ( str ) \u2013 Result string for logging. timepoints ( list ) \u2013 List of time points. OUT_FILE ( str ) \u2013 Output file path. Returns: \u2013 None","title":"output_results"},{"location":"reference.html#kinopt.evol.objfn.minfndiffevo","text":"","title":"minfndiffevo"},{"location":"reference.html#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem","text":"Bases: ElementwiseProblem Single-objective constrained optimization problem for phosphorylation dynamics (Numba-accelerated). Minimizes loss between observed and predicted phosphorylation levels subject to constraints that alpha and beta weights sum to 1.0 for each gene-psite and kinase group, respectively. Objective minimize loss (MSE, autocorrelation, Huber, or MAPE) Constraints g(x) <= 0: - for each alpha group: |sum(alpha_group) - 1| <= eps_eq - for each kinase beta group: |sum(beta_group) - 1| <= eps_eq Attributes: P_initial ( dict ) \u2013 Dictionary mapping (gene, psite) tuples to data dictionaries. P_initial_array ( ndarray ) \u2013 Observed phosphorylation matrix with shape (i_max, t_max). K_index ( dict ) \u2013 Dictionary mapping kinase names to lists of (psite_label, row_idx) tuples. K_array ( ndarray ) \u2013 Kinase activity matrix with shape (n_k_rows, t_max). gp_offsets ( ndarray ) \u2013 Offset indices for gene-psite groups. gp_kinase_ids ( ndarray ) \u2013 Kinase IDs for alpha variables. k_offsets ( ndarray ) \u2013 Offset indices for kinase groups. k_psite_rows ( ndarray ) \u2013 Psite row indices for beta variables. num_alpha ( int ) \u2013 Total number of alpha variables. num_beta ( int ) \u2013 Total number of beta variables. eps_eq ( float ) \u2013 Tolerance for equality constraints. loss_id ( int ) \u2013 Loss type identifier. include_reg ( bool ) \u2013 Whether to include regularization. n_scalar ( float ) \u2013 Scalar factor for normalization.","title":"PhosphorylationOptimizationProblem"},{"location":"reference.html#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem.estimated_series","text":"Compute estimated phosphorylation series for given parameters. Parameters: params ( array - like ) \u2013 1D array of parameters [alpha_1, ..., alpha_N, beta_1, ..., beta_M]. Returns: ndarray \u2013 Predicted phosphorylation matrix with shape (i_max, t_max).","title":"estimated_series"},{"location":"reference.html#kinopt.evol.objfn.minfndiffevo.PhosphorylationOptimizationProblem.residuals","text":"Compute residuals between observed and estimated phosphorylation for given parameters. Parameters: params ( array - like ) \u2013 1D array of parameters [alpha_1, ..., alpha_N, beta_1, ..., beta_M]. Returns: ndarray \u2013 Residual matrix (observed - estimated) with shape (i_max, t_max).","title":"residuals"},{"location":"reference.html#kinopt.evol.objfn.minfnnsgaii","text":"","title":"minfnnsgaii"},{"location":"reference.html#kinopt.evol.objfn.minfnnsgaii.PhosphorylationOptimizationProblem","text":"Bases: ElementwiseProblem Multi-objective optimization F[0] = main loss (error) F[1] = alpha sum-to-1 violations (aggregated) F[2] = beta sum-to-1 violations (aggregated) Parameters: P_initial ( dict ) \u2013 Dictionary with keys as (gene, psite) and values containing 'Kinases' and 'TimeSeries'. P_initial_array ( ndarray ) \u2013 Array of observed gene-psite data. K_index ( dict ) \u2013 Dictionary mapping each kinase to a list of (psite, time_series) tuples. K_array ( ndarray ) \u2013 Array of kinase-psite time-series data. gene_psite_counts ( list ) \u2013 List of integers indicating the number of kinases associated with each gene-psite. beta_counts ( dict ) \u2013 Dictionary indicating how many beta values correspond to each kinase-psite combination.","title":"PhosphorylationOptimizationProblem"},{"location":"reference.html#kinopt.evol.objfn.minfnnsgaii.PhosphorylationOptimizationProblem.objective_function","text":"Computes the main objective function (loss) for the given parameters. Parameters: params ( ndarray ) \u2013 Parameter vector containing alpha and beta values. Returns: float \u2013 Computed loss value based on the selected loss type (base, autocorrelation, huber, or mape).","title":"objective_function"},{"location":"reference.html#kinopt.evol.opt.optrun","text":"","title":"optrun"},{"location":"reference.html#kinopt.evol.opt.optrun.choose_de_pop_size","text":"Determine an appropriate population size for Differential Evolution (DE) algorithms. The population size is calculated based on the number of decision variables, with bounds to ensure reasonable performance. DE algorithms benefit from population sizes that are multiples of 10. Parameters: problem \u2013 The optimization problem instance with an 'n_var' attribute indicating the number of decision variables. Returns: int \u2013 The calculated population size (multiple of 10, between 100 and 600).","title":"choose_de_pop_size"},{"location":"reference.html#kinopt.evol.opt.optrun.choose_nsga_pop_size","text":"Determine an appropriate population size for NSGA-based multi-objective algorithms. The population size is scaled based on the problem dimensionality (number of decision variables) with heuristic thresholds. The size is rounded to multiples of 50 and enforced to be at least 10 times the number of objectives. Parameters: problem \u2013 The optimization problem instance with an 'n_var' attribute indicating the number of decision variables. n_obj ( int , default: 3 ) \u2013 Number of objectives in the problem. Defaults to 3. Returns: int \u2013 The calculated population size (multiple of 50, at least 10*n_obj).","title":"choose_nsga_pop_size"},{"location":"reference.html#kinopt.evol.opt.optrun.binary_tournament_loss_cv","text":"Robust binary tournament comparator for constrained optimization. This function performs binary tournament selection with constraint handling using either true constraint violations (CV) or pseudo-constrained objectives. It supports both single-objective and multi-objective formulations. Works for A) single-objective: F has length 1 - if CV exists, use constraint-domination (CV first, then F) - else compare by F only B) pseudo-constrained objectives: F = [loss, alpha_violation, beta_violation] - feasibility-first based on F[1], F[2], then loss Parameters: pop \u2013 Population of individuals with 'F' (objectives) and optionally 'CV' attributes. P ( ndarray ) \u2013 Tournament pairs array of shape (n_tournaments, 2), where each row contains indices of two competing individuals. eps_cv ( float , default: 1e-10 ) \u2013 Feasibility tolerance for constraint violations. Defaults to 1e-10. cv_mode ( str , default: 'linf' ) \u2013 Mode for aggregating constraint violations when using pseudo-constrained objectives. Options: 'linf' (max), 'l1' (sum), 'l2' (norm). Defaults to \"linf\". **kwargs \u2013 Additional keyword arguments (unused, for compatibility). Returns: \u2013 np.ndarray: Array of winning indices for each tournament, shape (n_tournaments,). Raises: ValueError \u2013 If pressure is not 2 (only binary tournaments supported) or if cv_mode is not one of 'linf', 'l1', 'l2'.","title":"binary_tournament_loss_cv"},{"location":"reference.html#kinopt.evol.opt.optrun.run_optimization","text":"Sets up and runs the multi-objective optimization problem for phosphorylation using an NSGA2 algorithm and a thread pool for parallelization. Parameters: P_initial, P_initial_array, K_index, K_array, gene_psite_counts, beta_counts \u2013 Data structures describing the problem (time-series data, kinases, etc.). PhosphorylationOptimizationProblem ( class ) \u2013 The custom problem class to be instantiated. Returns: result \u2013 The pymoo result object containing the optimized population and history. exec_time \u2013 Execution time for the optimization.","title":"run_optimization"},{"location":"reference.html#kinopt.evol.opt.optrun.pick_best_loss_with_constraints_as_objectives","text":"Select the best solution from a population with constraints formulated as objectives. This function assumes a specific objective structure where F[:,0] = loss (minimize) F[:,1] = constraint violation 1 (minimize, ideally 0) F[:,2] = constraint violation 2 (minimize, ideally 0) Selection rule A) If any feasible solutions exist (cv1<=eps and cv2<=eps): choose minimum loss among feasible. B) Else: choose minimum aggregated CV; tie-break by loss; optional tie-break by ||X||2. Parameters: result \u2013 Pymoo result object containing the final population with 'F' and 'X' attributes. eps_cv ( float , default: 1e-10 ) \u2013 Feasibility tolerance for constraint violations. Defaults to 1e-10. cv_mode ( str , default: 'l1' ) \u2013 Mode for aggregating constraint violations. Options: 'l1' (sum), 'linf' (max), 'l2' (Euclidean norm). Defaults to \"l1\". tie_tol ( float , default: 1e-12 ) \u2013 Tolerance for considering values as tied. Defaults to 1e-12. tie_break ( str , default: 'loss_then_l2' ) \u2013 Tie-breaking strategy. Options: 'loss_then_l2' or 'loss_only'. Defaults to \"loss_then_l2\". Returns: tuple \u2013 A tuple containing: - best_solution: The selected individual from the population. - best_index_in_pop (int): The index of the best solution in the population. - info (dict): Dictionary with selection metadata including selection case, number of feasible solutions, and best objective values. Raises: ValueError \u2013 If the objective array has fewer than 3 columns or if cv_mode is not one of 'l1', 'linf', 'l2'.","title":"pick_best_loss_with_constraints_as_objectives"},{"location":"reference.html#kinopt.evol.opt.optrun.post_optimization_nsga","text":"Post-process the result of a multi-objective NSGA-based optimization run. This function analyzes the optimization history, computes convergence metrics (hypervolume, IGD+), identifies the best solution using constraint handling, and generates CSV reports for convergence and parameter scans. Parameters: result \u2013 The final result object from the pymoo optimizer containing the final population, history, and objective values. weights ( ndarray , default: array ([1.0, 1.0, 1.0]) ) \u2013 Array of length 3 for weighting the objectives in decomposition-based selection. Defaults to [1.0, 1.0, 1.0]. ref_point ( ndarray , default: array ([3, 1, 1]) ) \u2013 Reference point for hypervolume computation. Defaults to [3, 1, 1]. Returns: tuple \u2013 A tuple containing 23 elements: - F: Final objective values array - pairs: Objective pairs for plotting [(0,1), (0,2), (1,2)] - n_evals: Number of evaluations per generation - hist_cv: Minimum constraint violation per generation - hist_cv_avg: Average constraint violation per generation - k: Generation index when first feasible solution appeared - metric_igd: IGDPlus metric object - metric_hv: Hypervolume metric object - best_solution: The selected best individual - best_objectives: Objective vector of best solution - optimized_params: Decision variables (X) of best solution - approx_nadir: Approximate nadir point - approx_ideal: Approximate ideal point - scores: Best solution's objective scores - best_index: Index of best solution in population - hist: Full optimization history - hist_hv: Hypervolume values per generation - hist_igd: IGD+ values per generation - convergence_df: DataFrame with iteration vs best objective - waterfall_df: DataFrame with all solutions and parameters - asf_i: Index of best solution by ASF decomposition - pseudo_weights_result: Result of pseudo-weights MCDM method - pairs (duplicate): Objective pairs - val: Best objective value per generation","title":"post_optimization_nsga"},{"location":"reference.html#kinopt.evol.opt.optrun.post_optimization_de","text":"Post-process the result of a single-objective DE or GA optimization run. This function extracts the final population, creates parameter labels from alpha and beta values, generates a parameter scan DataFrame sorted by objective value, and produces a convergence DataFrame showing the best objective per iteration. Parameters: result \u2013 The final result object from the pymoo optimizer (e.g., GA or DE result) containing the population, history, and objective values. alpha_values ( dict ) \u2013 Dictionary mapping (gene, psite) tuples to dictionaries of {kinase: value} for alpha parameters. beta_values ( dict ) \u2013 Dictionary mapping (kinase, psite) tuples to beta parameter values. Returns: tuple \u2013 A tuple containing 6 elements: - ordered_optimizer_runs: DataFrame of all solutions sorted by objective value - convergence_df: DataFrame with iteration vs best objective value - long_df: Long-form DataFrame for parameter visualization with columns ['Individual', 'Objective Value (F)', 'Parameter', 'Parameter Value', 'Type'] - x_values: List of iteration indices selected for plotting - y_values: List of objective values corresponding to x_values - val: Best objective value per generation from history","title":"post_optimization_de"},{"location":"reference.html#kinopt.evol.optcon.construct","text":"","title":"construct"},{"location":"reference.html#kinopt.evol.optcon.construct.pipeline","text":"Function to run the entire pipeline for loading and processing data. Parameters: input1_path ( str ) \u2013 Path to the first CSV file (HGNC data). input2_path ( str ) \u2013 Path to the second CSV file (kinase interactions). time_series_columns ( list [ str ] ) \u2013 List of time series columns to extract. scaling_method ( str ) \u2013 Method for scaling the data. split_point ( float ) \u2013 Split point for scaling. segment_points ( list [ float ] ) \u2013 Segment points for scaling. estimate_missing_kinases ( bool ) \u2013 Flag to estimate missing kinases. kinase_to_psites ( dict [ str , int ] ) \u2013 Dictionary mapping kinases to their respective psites. Returns: full_hgnc_df ( DataFrame ) \u2013 The scaled data from input1. interaction_df ( DataFrame ) \u2013 The subset/merged DataFrame from input2. observed ( DataFrame ) \u2013 Subset of full_hgnc_df merged with interaction_df. P_initial ( dict ) \u2013 Dictionary mapping gene-psite pairs to kinase relationships and time-series data. P_initial_array ( ndarray ) \u2013 Array containing observed time-series data for gene-psite pairs. K_array ( ndarray ) \u2013 Array containing time-series data for kinase-psite combinations. K_index ( dict ) \u2013 Mapping of kinases to their respective psite data. beta_counts ( dict ) \u2013 Mapping of kinase indices to the number of associated psites. gene_psite_counts ( list ) \u2013 List of counts of psites for each gene. n ( int ) \u2013 Number of unique gene-psite pairs.","title":"pipeline"},{"location":"reference.html#kinopt.evol.optcon.construct.load_geneid_to_psites","text":"Function to load geneid to psite mapping from input1.csv. Args: input1_path (str): Path to the first CSV file (HGNC data). Returns: geneid_psite_map (dict): Dictionary mapping gene IDs to sets of psites.","title":"load_geneid_to_psites"},{"location":"reference.html#kinopt.evol.optcon.construct.get_unique_kinases","text":"Function to extract unique kinases from input2.csv. Args: input2_path (str): Path to the second CSV file (kinase interactions). Returns: kinases (set): Set of unique kinases extracted from the input2 file.","title":"get_unique_kinases"},{"location":"reference.html#kinopt.evol.optcon.construct.check_kinases","text":"Function to check if kinases from input2.csv are present in input1.csv. Returns: \u2013 None","title":"check_kinases"},{"location":"reference.html#kinopt.evol.utils.iodata","text":"","title":"iodata"},{"location":"reference.html#kinopt.evol.utils.iodata.format_duration","text":"Returns a formatted string representing the duration in seconds, minutes, or hours. Parameters: seconds ( float ) \u2013 The duration in seconds. Returns: str: The formatted duration string.","title":"format_duration"},{"location":"reference.html#kinopt.evol.utils.iodata.load_and_scale_data","text":"Function to load and scale data from CSV files. Parameters: estimate_missing ( bool ) \u2013 If True, estimates missing values. scaling_method ( str ) \u2013 The scaling method to apply ('min_max', 'log', 'temporal', 'segmented', 'slope', 'cumulative'). split_point ( int ) \u2013 Column index for temporal scaling. seg_points ( list ) \u2013 List of column indices for segmented scaling. Returns: full_hgnc_df ( DataFrame ) \u2013 DataFrame with scaled time-series data. interaction_df ( DataFrame ) \u2013 DataFrame containing interaction data. observed ( DataFrame ) \u2013 DataFrame containing observed data.","title":"load_and_scale_data"},{"location":"reference.html#kinopt.evol.utils.iodata.apply_scaling","text":"Function to apply different scaling methods to time-series data in a DataFrame. Parameters: df ( DataFrame ) \u2013 Input DataFrame containing time-series data. time_series_columns ( list ) \u2013 List of column names to scale. method ( str ) \u2013 Scaling method ('min_max', 'log', 'temporal', 'segmented', 'slope', 'cumulative'). split_point ( int ) \u2013 Column index for temporal scaling. segment_points ( list ) \u2013 List of column indices for segmented scaling. Returns: \u2013 pd.DataFrame: DataFrame with scaled time-series data.","title":"apply_scaling"},{"location":"reference.html#kinopt.evol.utils.iodata.create_report","text":"Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root result's directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir). Returns: \u2013 None","title":"create_report"},{"location":"reference.html#kinopt.evol.utils.iodata.organize_output_files","text":"Function to organize output files into protein-specific folders and a general folder. Parameters: *directories \u2013 List of directories to organize. Returns: \u2013 None","title":"organize_output_files"},{"location":"reference.html#kinopt.evol.utils.params","text":"","title":"params"},{"location":"reference.html#kinopt.evol.utils.params.extract_parameters","text":"Function to extract alpha and beta values from the optimized parameters. Parameters: P_initial ( dict ) \u2013 Dictionary containing initial parameters for each gene-psite pair. gene_psite_counts ( list ) \u2013 List of counts for each gene-psite pair. K_index ( dict ) \u2013 Dictionary mapping kinases to their respective psite pairs. optimized_params ( list ) \u2013 List of optimized parameters. Returns: alpha_values ( dict ) \u2013 Dictionary containing alpha values for each gene-psite pair. beta_values ( dict ) \u2013 Dictionary containing beta values for each kinase-psite pair.","title":"extract_parameters"},{"location":"reference.html#kinopt.evol.utils.params.compute_metrics","text":"Function to compute error metrics for the estimated series. Parameters: optimized_params ( list ) \u2013 List of optimized parameters. P_initial ( dict ) \u2013 Dictionary containing initial parameters for each gene-psite pair. P_initial_array ( ndarray ) \u2013 Array of initial parameters. K_index ( dict ) \u2013 Dictionary mapping kinases to their respective psite pairs. K_array ( ndarray ) \u2013 Array of kinases. gene_psite_counts ( list ) \u2013 List of counts for each gene-psite pair. beta_counts ( dict ) \u2013 List of counts for each kinase-psite pair. n ( int ) \u2013 Number of samples. Returns: P_estimated ( ndarray ) \u2013 Estimated series. residuals ( ndarray ) \u2013 Residuals between initial and estimated series. mse ( float ) \u2013 Mean Squared Error. rmse ( float ) \u2013 Root Mean Squared Error. mae ( float ) \u2013 Mean Absolute Error. mape ( float ) \u2013 Mean Absolute Percentage Error. r_squared ( float ) \u2013 R-squared value.","title":"compute_metrics"},{"location":"reference.html#gradient-based-algorithms","text":"","title":"Gradient-Based Algorithms"},{"location":"reference.html#kinopt.local.config.constants","text":"","title":"constants"},{"location":"reference.html#kinopt.local.config.constants.parse_args","text":"kinopt.local CLI. Defaults come from config.toml.","title":"parse_args"},{"location":"reference.html#kinopt.local.config.logconf","text":"","title":"logconf"},{"location":"reference.html#kinopt.local.exporter.plotout","text":"","title":"plotout"},{"location":"reference.html#kinopt.local.exporter.plotout.format_timepoints","text":"Format timepoints with minimal decimals: - integers -> no decimal - non-integers -> one decimal Parameters: tp ( array - like ) \u2013 Timepoints (list or np.ndarray) tol ( float , default: 1e-09 ) \u2013 Tolerance for floating-point integer check Returns: \u2013 list[str]: Formatted labels","title":"format_timepoints"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_fits_for_gene","text":"Function to plot the observed and estimated phosphorylation levels for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing observed and estimated data for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_fits_for_gene"},{"location":"reference.html#kinopt.local.exporter.plotout.export_outcomes_to_csv","text":"Export multistart optimization outcomes to CSV. One row per start, scalar diagnostics only.","title":"export_outcomes_to_csv"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_cumulative_residuals","text":"Function to plot the cumulative residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_cumulative_residuals"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_autocorrelation_residuals","text":"Function to plot the autocorrelation of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_autocorrelation_residuals"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_histogram_residuals","text":"Function to plot histograms of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_histogram_residuals"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_qqplot_residuals","text":"Function to plot QQ plots of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_qqplot_residuals"},{"location":"reference.html#kinopt.local.exporter.plotout.plot_multistart_summary_runtime_overlay","text":"Read a multistart summary CSV and plot objective vs rank with point color = runtime. Minimal, information-dense conventions: - x: rank (best -> worst) - y: final objective (fun) - color: runtime in seconds - optional: de-emphasize non-success / infeasible points (if columns exist) Parameters: summary_csv ( str | Path ) \u2013 Path to the multistart_summary.csv out_path ( str | Path | None , default: None ) \u2013 If provided, saves the figure (e.g. .png) figsize ( tuple , default: (8, 8) ) \u2013 Figure size in inches x_col, y_col, c_col \u2013 Column names success_col, cv_col \u2013 Optional columns for styling (used if present) annotate_best ( bool , default: True ) \u2013 Annotate the best run (rank=1 or min fun) Returns: ( fig , ax , df ) \u2013 Matplotlib figure/axis and the loaded DataFrame","title":"plot_multistart_summary_runtime_overlay"},{"location":"reference.html#kinopt.local.exporter.sheetutils","text":"","title":"sheetutils"},{"location":"reference.html#kinopt.local.exporter.sheetutils.format_timepoints","text":"Format timepoints with minimal decimals: - integers -> no decimal - non-integers -> one decimal Parameters: tp ( array - like ) \u2013 Timepoints (list or np.ndarray) tol ( float , default: 1e-09 ) \u2013 Tolerance for floating-point integer check Returns: \u2013 list[str]: Formatted labels","title":"format_timepoints"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_fits_for_gene","text":"Function to plot the observed and estimated phosphorylation levels for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing observed and estimated data for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_fits_for_gene"},{"location":"reference.html#kinopt.local.exporter.sheetutils.export_outcomes_to_csv","text":"Export multistart optimization outcomes to CSV. One row per start, scalar diagnostics only.","title":"export_outcomes_to_csv"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_cumulative_residuals","text":"Function to plot the cumulative residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_cumulative_residuals"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_autocorrelation_residuals","text":"Function to plot the autocorrelation of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_autocorrelation_residuals"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_histogram_residuals","text":"Function to plot histograms of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_histogram_residuals"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_qqplot_residuals","text":"Function to plot QQ plots of residuals for each psite of a gene. Parameters: gene ( str ) \u2013 The name of the gene. gene_data ( dict ) \u2013 A dictionary containing the residuals for each psite of the gene. real_timepoints ( list ) \u2013 A list of timepoints corresponding to the observed and estimated data.","title":"plot_qqplot_residuals"},{"location":"reference.html#kinopt.local.exporter.sheetutils.plot_multistart_summary_runtime_overlay","text":"Read a multistart summary CSV and plot objective vs rank with point color = runtime. Minimal, information-dense conventions: - x: rank (best -> worst) - y: final objective (fun) - color: runtime in seconds - optional: de-emphasize non-success / infeasible points (if columns exist) Parameters: summary_csv ( str | Path ) \u2013 Path to the multistart_summary.csv out_path ( str | Path | None , default: None ) \u2013 If provided, saves the figure (e.g. .png) figsize ( tuple , default: (8, 8) ) \u2013 Figure size in inches x_col, y_col, c_col \u2013 Column names success_col, cv_col \u2013 Optional columns for styling (used if present) annotate_best ( bool , default: True ) \u2013 Annotate the best run (rank=1 or min fun) Returns: ( fig , ax , df ) \u2013 Matplotlib figure/axis and the loaded DataFrame","title":"plot_multistart_summary_runtime_overlay"},{"location":"reference.html#kinopt.local.exporter.sheetutils.output_results","text":"Function to output the results of the optimization process. Parameters: P_initial ( dict ) \u2013 Dictionary containing initial phosphorylation data. P_init_dense ( ndarray ) \u2013 Dense matrix of initial phosphorylation data. P_estimated ( ndarray ) \u2013 Dense matrix of estimated phosphorylation data. residuals ( ndarray ) \u2013 Dense matrix of residuals. alpha_values ( dict ) \u2013 Dictionary containing optimized alpha values. beta_values ( dict ) \u2013 Dictionary containing optimized beta values. result ( OptimizeResult ) \u2013 Result object from the optimization process. mse ( float ) \u2013 Mean Squared Error of the optimization. rmse ( float ) \u2013 Root Mean Squared Error of the optimization. mae ( float ) \u2013 Mean Absolute Error of the optimization. mape ( float ) \u2013 Mean Absolute Percentage Error of the optimization. r_squared ( float ) \u2013 R-squared value of the optimization.","title":"output_results"},{"location":"reference.html#kinopt.local.exporter.sheetutils.export_params_npz","text":"Export the optimized parameters to a compressed npz file. Parameters: outcomes ( list ) \u2013 List of OptimizeResult objects. path ( str ) \u2013 Path to save the npz file.","title":"export_params_npz"},{"location":"reference.html#kinopt.local.objfn.minfn","text":"","title":"minfn"},{"location":"reference.html#kinopt.local.opt.optrun","text":"","title":"optrun"},{"location":"reference.html#kinopt.local.opt.optrun.StartOutcome","text":"Outcome of a single optimization start. :param start_id: ID of the start. :param seed: Seed used for the start. :param result: Result of the optimization. :param optimized_params: Optimized parameters. :param fun: Objective function value. :param success: Whether the optimization was successful. :param constr_violation: Constraint violation. :param runtime_s: Runtime of the optimization.","title":"StartOutcome"},{"location":"reference.html#kinopt.local.opt.optrun.run_optimization","text":"Run optimization using the specified method. Parameters: obj_fun \u2013 Objective function to minimize. params_initial \u2013 Initial parameters for the optimization. opt_method \u2013 Optimization method to use (e.g., 'SLSQP', 'trust-constr'). bounds \u2013 Bounds for the parameters. constraints \u2013 Constraints for the optimization. Returns: result \u2013 Result of the optimization. optimized_params \u2013 Optimized parameters.","title":"run_optimization"},{"location":"reference.html#kinopt.local.opt.optrun.multistart_run_optimization","text":"Runs run_optimization multiple times in parallel and returns (best_result, best_params, outcomes). Selection logic (sophisticated but simple): 1) If prefer_feasible: prefer (cv <= 0) or smallest constraint violation. 2) Then lowest objective. 3) Then success=True as tie-breaker. 4) Then shortest runtime as final tie-breaker. Parameters: obj_fun \u2013 Objective function to optimize. params_initial \u2013 Initial parameters for optimization. opt_method \u2013 Optimization method to use (e.g., 'SLSQP', 'trust-constr'). bounds \u2013 Parameter bounds for optimization. constraints \u2013 Constraints for optimization. n_starts \u2013 Number of optimization starts to run (default: 24). n_jobs \u2013 Number of parallel jobs to run. -1 means use all processors (default: -1). base_seed \u2013 Base seed for random number generation (default: 1234). init_strategy \u2013 Strategy for sampling initial parameters: 'jitter', 'uniform', or 'hybrid' (default: 'hybrid'). jitter_scale \u2013 Scale for jittering initial parameters (default: 0.15). prefer_feasible \u2013 If True, prefer feasible solutions over infeasible ones (default: True). logger \u2013 Logger instance for logging messages (default: None). Returns: tuple \u2013 A tuple containing: - best_result: The optimization result object with the best outcome. - best_params: The optimized parameters corresponding to the best result. - outcomes: List of StartOutcome objects for all optimization starts.","title":"multistart_run_optimization"},{"location":"reference.html#kinopt.local.optcon.construct","text":"","title":"construct"},{"location":"reference.html#kinopt.local.optcon.construct.load_geneid_to_psites","text":"Load the geneid to psite mapping from a CSV file. Parameters: input1_path ( str , default: INPUT1 ) \u2013 Path to the input CSV file containing geneid and psite information. Returns: defaultdict: A dictionary mapping geneid to a set of psites.","title":"load_geneid_to_psites"},{"location":"reference.html#kinopt.local.optcon.construct.get_unique_kinases","text":"Extract unique kinases from the input CSV file. Parameters: input2_path ( str , default: INPUT2 ) \u2013 Path to the input CSV file containing kinase information. Returns: set: A set of unique kinases.","title":"get_unique_kinases"},{"location":"reference.html#kinopt.local.optcon.construct.check_kinases","text":"Check if kinases in input2.csv are present in input1.csv and log the results.","title":"check_kinases"},{"location":"reference.html#kinopt.local.utils.iodata","text":"","title":"iodata"},{"location":"reference.html#kinopt.local.utils.iodata.format_duration","text":"Formats a duration in seconds into a human-readable string. - If less than 60 seconds, returns in seconds. - If less than 3600 seconds, returns in minutes. - If more than 3600 seconds, returns in hours. :param seconds: :return: Formatted string","title":"format_duration"},{"location":"reference.html#kinopt.local.utils.iodata.load_and_scale_data","text":"Load and scale the data from the specified input files. :param estimate_missing: :param scaling_method: :param split_point: :param seg_points: :return: Time series data, interaction data, observed data","title":"load_and_scale_data"},{"location":"reference.html#kinopt.local.utils.iodata.apply_scaling","text":"Apply scaling to the specified columns of a DataFrame based on the given method. The scaling methods include: - 'min_max': Min-Max scaling - 'log': Logarithmic scaling - 'temporal': Temporal scaling (two segments) - 'segmented': Segmented scaling (multiple segments) - 'slope': Slope scaling - 'cumulative': Cumulative scaling :param df: :param cols: :param method: :param split_point: :param seg_points: :return: df","title":"apply_scaling"},{"location":"reference.html#kinopt.local.utils.iodata.create_report","text":"Creates a single global report HTML file from all gene folders inside the results directory. For each gene folder (e.g. \"ABL2\"), the report will include: - All PNG plots and interactive HTML plots displayed in a grid with three plots per row. - Each plot is confined to a fixed size of 900px by 900px. - Data tables from XLSX or CSV files in the gene folder are displayed below the plots, one per row. Parameters: results_dir ( str ) \u2013 Path to the root results directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir).","title":"create_report"},{"location":"reference.html#kinopt.local.utils.iodata.organize_output_files","text":"Function to organize output files into protein-specific folders. It moves files matching the pattern 'protein_name_*.{json,svg,png,html,csv,xlsx}' into a folder named after the protein (e.g., 'ABL2') and moves all other files into a 'General' folder within the same directory. :param directories:","title":"organize_output_files"},{"location":"reference.html#kinopt.local.utils.params","text":"","title":"params"},{"location":"reference.html#kinopt.local.utils.params.extract_parameters","text":"Extracts the alpha and beta parameters from the optimized parameters. :param P_initial: :param gene_kinase_counts: :param total_alpha: :param unique_kinases: :param K_index: :param optimized_params: :return: Alpha and beta values as dictionaries","title":"extract_parameters"},{"location":"reference.html#kinopt.local.utils.params.compute_metrics","text":"Computes the estimated series and various metrics based on the optimized parameters. :param optimized_params: :param P_init_dense: :param t_max: :param gene_alpha_starts: :param gene_kinase_counts: :param gene_kinase_idx: :param total_alpha: :param kinase_beta_starts: :param kinase_beta_counts: :param K_data: :param K_indices: :param K_indptr: :return: Estimated series, residuals, MSE, RMSE, MAE, MAPE, R-squared","title":"compute_metrics"},{"location":"reference.html#fitting-analysis-feasibility","text":"","title":"Fitting Analysis &amp; Feasibility"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit","text":"","title":"postfit"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.goodnessoffit","text":"Function to plot the goodness of fit and kullback-leibler divergence for estimated and observed values. Parameters: estimated ( DataFrame ) \u2013 DataFrame containing estimated values. observed ( DataFrame ) \u2013 DataFrame containing observed values. Returns: \u2013 None","title":"goodnessoffit"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.reshape_alpha_beta","text":"Function to reshape alpha and beta values for plotting. Parameters: alpha_values ( DataFrame ) \u2013 DataFrame containing alpha values. beta_values ( DataFrame ) \u2013 DataFrame containing beta values. Returns: pd.DataFrame: Reshaped DataFrame containing both alpha and beta values.","title":"reshape_alpha_beta"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.perform_pca","text":"Function to perform PCA analysis on the given DataFrame. Parameters: df ( DataFrame ) \u2013 DataFrame containing the data for PCA analysis. Returns: \u2013 pd.DataFrame: DataFrame with PCA results and additional columns for type and gene/psite information.","title":"perform_pca"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.plot_pca","text":"Plot PCA or t-SNE results for each gene/psite. The function creates scatter plots with different markers for alpha and beta parameters, and adds labels for each point. The function also adjusts text labels to avoid overlap using the adjustText library. :param result_df_sorted: DataFrame containing PCA or t-SNE results. :param y_axis_column: Column name for the y-axis values in the plot.","title":"plot_pca"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.perform_tsne","text":"Perform t-SNE analysis on the given scaled data. The function returns a DataFrame with t-SNE results and additional columns for type and gene/psite information. :param scaled_data: :param df: :return: - pd.DataFrame: DataFrame with t-SNE results and additional columns.","title":"perform_tsne"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.additional_plots","text":"Function to create additional plots including CDF, KDE, Boxplot, and Hierarchical Clustering. :param df: :param scaled_data: :param alpha_values: :param beta_values: :param residuals_df:","title":"additional_plots"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.create_sankey_from_network","text":"Creates a Sankey diagram from the given data and saves it as an HTML file. This function processes the input data to generate nodes and links for a Sankey diagram. It assigns colors to nodes and links based on their attributes and values, and uses Plotly to render the diagram. The resulting diagram is saved as an HTML file in the specified output directory. :param output_dir: str The directory where the Sankey diagram HTML file will be saved. :param data: pd.DataFrame A DataFrame containing the data for the Sankey diagram. It must include the following columns: - 'Source': The source node of the link. - 'Target': The target node of the link. - 'Value': The value of the link, which determines the flow size. :param title: str The title of the Sankey diagram. The function performs the following steps: 1. Initializes nodes and links for the Sankey diagram. 2. Maps node labels to indices and assigns colors to nodes. 3. Processes the data to create links between nodes, assigning colors based on link values. 4. Builds the Sankey diagram using Plotly. 5. Adds a color bar to explain the flow gradient. 6. Saves the Sankey diagram as an HTML file in the specified output directory.","title":"create_sankey_from_network"},{"location":"reference.html#kinopt.fitanalysis.helpers.postfit.important_connections","text":"Extracts the top N most important connections based on their absolute values and saves them to a CSV file. :param output_dir: str The directory where the CSV file will be saved. :param data: pd.DataFrame A DataFrame containing the connections with columns 'Source', 'Target', and 'Value'. :param top_n: int, optional The number of top connections to extract (default is 20). The function sorts the connections by their absolute values in descending order, selects the top N connections, and saves them to a CSV file named 'top_connections.csv' in the specified output directory.","title":"important_connections"},{"location":"reference.html#kinopt.optimality.KKT","text":"","title":"KKT"},{"location":"reference.html#kinopt.optimality.KKT.generate_latex_table","text":"Function to generate a LaTeX table from a summary dictionary. Parameters: summary_dict ( dict ) \u2013 Dictionary containing summary data. table_caption ( str ) \u2013 Caption for the LaTeX table. table ( str , default: None ) \u2013 Optional existing LaTeX table to append to. Returns: str \u2013 LaTeX formatted table as a string.","title":"generate_latex_table"},{"location":"reference.html#kinopt.optimality.KKT.print_primal_feasibility_results","text":"Logs the primal feasibility summary and violation details. Parameters: primal_summary ( dict ) \u2013 Dictionary containing primal feasibility results. alpha_violations ( dict ) \u2013 Dictionary containing alpha constraint violations. beta_violations ( dict ) \u2013 Dictionary containing beta constraint violations. logger_obj \u2013 Optional logger object to log the information.","title":"print_primal_feasibility_results"},{"location":"reference.html#kinopt.optimality.KKT.print_sensitivity_and_active_constraints","text":"Logs the sensitivity summary and active constraints summary. Parameters: sensitivity_summary ( dict ) \u2013 Dictionary containing sensitivity analysis results. active_constraints_summary ( dict ) \u2013 Dictionary containing active constraints summary. logger_obj \u2013 Optional logger object to log the information.","title":"print_sensitivity_and_active_constraints"},{"location":"reference.html#kinopt.optimality.KKT.plot_constraint_violations","text":"Function to plot constraint violations for alpha and beta values. It creates a stacked bar plot showing the violations for each protein. The top 5 proteins with the highest violations are highlighted in red. Parameters: alpha_violations ( Series ) \u2013 Series containing alpha constraint violations. beta_violations ( Series ) \u2013 Series containing beta constraint violations. out_dir ( str ) \u2013 Directory to save the plot.","title":"plot_constraint_violations"},{"location":"reference.html#kinopt.optimality.KKT.plot_sensitivity_analysis","text":"Function to plot sensitivity analysis results. It creates a horizontal bar plot showing the mean, max, and min sensitivity for each protein. Parameters: sensitivity_analysis ( DataFrame ) \u2013 DataFrame containing sensitivity analysis results. out_dir ( str ) \u2013 Directory to save the plot. Returns: \u2013 None","title":"plot_sensitivity_analysis"},{"location":"reference.html#kinopt.optimality.KKT.process_excel_results","text":"Function to process the Excel results file. It reads the alpha and beta values, estimated and observed values, validates normalization constraints, computes residuals and gradients, and generates LaTeX tables for the residuals and sensitivity summaries. It also performs sensitivity analysis and identifies high sensitivity sites. The results are returned as a dictionary. Parameters: file_path ( str , default: OUT_FILE ) \u2013 Path to the Excel file containing results. Returns: dict: Dictionary containing the processed results, including alpha and beta values, estimated and observed values, constraint violations, residuals summary, sensitivity summary, and high sensitivity sites.","title":"process_excel_results"},{"location":"reference.html#kinopt.optimality.KKT.post_optimization_results","text":"Function to process and visualize the results of the optimization. Returns: dict: Dictionary containing the processed results, including alpha and beta values, estimated and observed values, constraint violations, residuals summary, sensitivity summary, and high sensitivity sites.","title":"post_optimization_results"},{"location":"reference.html#tf-mrna-optimization","text":"","title":"TF-mRNA Optimization"},{"location":"reference.html#evolutionary-algorithms_1","text":"","title":"Evolutionary Algorithms"},{"location":"reference.html#tfopt.evol.config.constants","text":"","title":"constants"},{"location":"reference.html#tfopt.evol.config.constants.parse_args","text":"tfopt.evol CLI: bounds, loss, optimizer selection. Defaults come from config.toml.","title":"parse_args"},{"location":"reference.html#tfopt.evol.config.logconf","text":"","title":"logconf"},{"location":"reference.html#tfopt.evol.exporter.plotout","text":"","title":"plotout"},{"location":"reference.html#tfopt.evol.exporter.plotout.plot_estimated_vs_observed","text":"Plot the estimated vs observed expression levels for a set of genes. Parameters: predictions ( ndarray ) \u2013 Predicted expression levels. expression_matrix ( ndarray ) \u2013 Observed expression levels. gene_ids ( list ) \u2013 List of gene identifiers. time_points ( ndarray ) \u2013 Time points for the experiments. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. tf_protein_matrix ( ndarray ) \u2013 Matrix of TF protein levels. tf_ids ( list ) \u2013 List of TF identifiers. num_targets ( int ) \u2013 Number of target genes to plot. save_path ( str , default: OUT_DIR ) \u2013 Directory to save the plots.","title":"plot_estimated_vs_observed"},{"location":"reference.html#tfopt.evol.exporter.plotout.compute_predictions","text":"Compute the predicted expression levels based on the optimization variables. Parameters: x ( ndarray ) \u2013 Optimization variables. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. protein_mat ( ndarray ) \u2013 Matrix of TF protein levels. psite_tensor ( ndarray ) \u2013 Tensor of phosphorylation sites. n_reg ( int ) \u2013 Number of regulators. T_use ( int ) \u2013 Number of time points to use. n_mRNA ( int ) \u2013 Number of mRNAs. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF.","title":"compute_predictions"},{"location":"reference.html#tfopt.evol.exporter.sheetutils","text":"","title":"sheetutils"},{"location":"reference.html#tfopt.evol.exporter.sheetutils.save_results_to_excel","text":"Save the optimization results to an Excel file. Parameters: gene_ids ( list ) \u2013 List of gene identifiers. tf_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha values. final_beta ( ndarray ) \u2013 Final beta values. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels. expression_matrix ( ndarray ) \u2013 Observed expression levels. predictions ( ndarray ) \u2013 Predicted expression levels. objective_value ( float ) \u2013 Objective value from optimization. reg_map ( dict ) \u2013 Mapping of genes to regulators. filename ( str , default: OUT_FILE ) \u2013 Path to the output Excel file.","title":"save_results_to_excel"},{"location":"reference.html#tfopt.evol.objfn.minfn","text":"","title":"minfn"},{"location":"reference.html#tfopt.evol.objfn.minfn.TFOptimizationMultiObjectiveProblem","text":"Bases: Problem Represents a multi-objective optimization problem specific to transcription factor (TF) and mRNA synthesis dynamics. This class is an extension of the Problem class and is designed to model complex biological processes by incorporating various dynamic parameters like regulators, protein matrices, psite tensors, and associated configurations. It supports parallel evaluation for multi-thread usage, optimizing performance for large populations. Attributes: n_mRNA ( int ) \u2013 Number of mRNA species in the system. n_TF ( int ) \u2013 Number of transcription factor species in the system. n_reg ( int ) \u2013 Number of regulators. n_psite_max ( int ) \u2013 Maximum number of potential p-sites. n_alpha ( int ) \u2013 Number of alpha parameters used in modeling. T_use ( int ) \u2013 Number of time units or steps to use in the evaluation. mRNA_mat ( ndarray ) \u2013 A matrix representing the mRNA dynamics. regulators ( ndarray ) \u2013 Array of regulator IDs associated with mRNA and TF interactions. protein_mat ( ndarray ) \u2013 A matrix representing the protein synthesis rates or patterns. psite_tensor ( ndarray ) \u2013 A tensor indicating probabilistic binding sites of proteins. beta_start_indices ( ndarray ) \u2013 Array indicating the starting indices of beta coefficients. num_psites ( ndarray ) \u2013 Array indicating the number of p-sites per transcription factor. no_psite_tf ( ndarray ) \u2013 Boolean array indicating TFs with zero p-sites. loss_type ( int ) \u2013 Configurable loss function type for the optimization. Defaults to 0. lam1 ( float ) \u2013 First regularization parameter for loss calculation. Defaults to 1e-3. lam2 ( float ) \u2013 Second regularization parameter for loss calculation. Defaults to 1e-3. max_threads ( int ) \u2013 Maximum number of threads to use for evaluation. 0 indicates automatic thread selection based on system capacity.","title":"TFOptimizationMultiObjectiveProblem"},{"location":"reference.html#tfopt.evol.objfn.minfn.TFOptimizationMultiObjectiveProblem.__init__","text":"Initializes the class with various parameters required for computational evaluation. Parameters: n_var ( int ) \u2013 The number of variables. n_mRNA ( int ) \u2013 The number of mRNA molecules. n_TF ( int ) \u2013 The number of transcription factors (TFs). n_reg ( int ) \u2013 The number of regulators. n_psite_max ( int ) \u2013 The maximum number of p-sites. n_alpha ( int ) \u2013 The number of alpha coefficients. mRNA_mat ( ndarray ) \u2013 Matrix representing the mRNA data. regulators ( ndarray ) \u2013 Array representing the regulator mappings. protein_mat ( ndarray ) \u2013 Matrix representing the protein data. psite_tensor ( ndarray ) \u2013 Tensor representing the p-site data. T_use ( int ) \u2013 The time step or usage parameter. beta_start_indices ( ndarray ) \u2013 Array of start indices for beta calculations. num_psites ( ndarray ) \u2013 Array representing the number of p-sites. no_psite_tf ( ndarray ) \u2013 Boolean array indicating TFs with no associated p-sites. xl ( Optional [ ndarray ] , default: None ) \u2013 Optional lower-bound array for the variables. xu ( Optional [ ndarray ] , default: None ) \u2013 Optional upper-bound array for the variables. **kwargs \u2013 Additional optional arguments such as \"loss_type\", \"lam1\", \"lam2\", and \"threads\".","title":"__init__"},{"location":"reference.html#tfopt.evol.opt.optrun","text":"","title":"optrun"},{"location":"reference.html#tfopt.evol.opt.optrun.run_optimization","text":"Execute multi-objective optimization using the specified algorithm. This function configures and runs one of three multi-objective evolutionary algorithms (UNSGA3, SMSEMOA, or AGEMOEA) on the provided optimization problem. The algorithm is configured with appropriate genetic operators (two-point crossover and polynomial mutation) and terminated after 1000 generations. Parameters: problem ( Problem ) \u2013 The pymoo Problem instance defining the optimization problem, including objectives, constraints, and variable bounds. total_dim ( int ) \u2013 Total number of decision variables (dimensions) in the optimization problem. Used to determine population size and mutation probability. optimizer ( int ) \u2013 Selector for the optimization algorithm: - 0: UNSGA3 (Unified NSGA-III) - Reference direction-based algorithm - 1: SMSEMOA - S-Metric Selection Evolutionary Multi-objective Algorithm - 2: AGEMOEA - Adaptive Geometry Estimation-based Multi-objective Evolutionary Algorithm Returns: Result \u2013 A pymoo Result object containing the optimization outcomes, including: - X: Decision variables of the Pareto-optimal solutions - F: Objective function values of the Pareto-optimal solutions - algorithm: The algorithm instance used - Additional statistics and convergence information Notes Population size is set to 2 * total_dim (or larger for UNSGA3 if needed) Crossover probability: 0.9 Mutation probability: 1.0 / total_dim Mutation distribution index (eta): 20 Termination: Fixed at 1000 generations Random seed: 1 (for reproducibility) Duplicate elimination is enabled for all algorithms UNSGA3 automatically adjusts population size to match reference directions","title":"run_optimization"},{"location":"reference.html#tfopt.evol.optcon.construct","text":"","title":"construct"},{"location":"reference.html#tfopt.evol.optcon.construct.build_fixed_arrays","text":"Builds fixed-shape arrays from the input data. Parameters: mRNA_ids ( list ) \u2013 List of mRNA identifiers. mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression levels. TF_ids ( list ) \u2013 List of TF identifiers. protein_dict ( dict ) \u2013 Dictionary mapping TFs to their protein levels. psite_dict ( dict ) \u2013 Dictionary mapping TFs to their phosphorylation sites. psite_labels_dict ( dict ) \u2013 Dictionary mapping TFs to their phosphorylation site labels. reg_map ( dict ) \u2013 Mapping of genes to their regulators. Returns: mRNA_mat (np.ndarray): Matrix of mRNA expression levels. regulators (np.ndarray): Matrix of regulators for each mRNA. protein_mat (np.ndarray): Matrix of TF protein levels. psite_tensor (np.ndarray): Tensor of phosphorylation sites. n_reg (int): Number of regulators. n_psite_max (int): Maximum number of phosphorylation sites across all TFs. psite_labels_arr (list): List of phosphorylation site labels for each TF. num_psites (np.ndarray): Array indicating the number of phosphorylation sites for each TF.","title":"build_fixed_arrays"},{"location":"reference.html#tfopt.evol.optcon.filter","text":"","title":"filter"},{"location":"reference.html#tfopt.evol.optcon.filter.load_raw_data","text":"Load raw data from files. Returns: mRNA_ids \u2013 List of mRNA gene identifiers. mRNA_mat \u2013 Matrix of mRNA expression data. mRNA_time_cols \u2013 Time points for mRNA data. TF_ids \u2013 List of transcription factor identifiers. protein_dict \u2013 Dictionary mapping TF_ids to their protein data. psite_dict \u2013 Dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict \u2013 Dictionary mapping TF_ids to their phosphorylation site labels. TF_time_cols \u2013 Time points for TF data. reg_map \u2013 Regulation map, mapping mRNA genes to their regulators.","title":"load_raw_data"},{"location":"reference.html#tfopt.evol.optcon.filter.filter_mrna","text":"Filter mRNA genes to only those with regulators present in the regulation map. Parameters: mRNA_ids ( list ) \u2013 List of mRNA gene identifiers. mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression data. reg_map ( dict ) \u2013 Regulation map, mapping mRNA genes to their regulators. Returns: filtered_mRNA_ids ( list ) \u2013 List of filtered mRNA gene identifiers. filtered_mRNA_mat ( ndarray ) \u2013 Matrix of filtered mRNA expression data.","title":"filter_mrna"},{"location":"reference.html#tfopt.evol.optcon.filter.update_regulations","text":"Update the regulation map to only include relevant transcription factors. Parameters: mRNA_ids ( list ) \u2013 List of mRNA gene identifiers. reg_map ( dict ) \u2013 Regulation map, mapping mRNA genes to their regulators. TF_ids ( list ) \u2013 List of transcription factor identifiers. Returns: relevant_TFs ( set ) \u2013 Set of relevant transcription factors.","title":"update_regulations"},{"location":"reference.html#tfopt.evol.optcon.filter.filter_TF","text":"Filter transcription factors to only those present in the relevant_TFs set. Parameters: TF_ids ( list ) \u2013 List of transcription factor identifiers. protein_dict ( dict ) \u2013 Dictionary mapping TF_ids to their protein data. psite_dict ( dict ) \u2013 Dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict ( dict ) \u2013 Dictionary mapping TF_ids to their phosphorylation site labels. relevant_TFs ( set ) \u2013 Set of relevant transcription factors. Returns: TF_ids_filtered ( list ) \u2013 List of filtered transcription factor identifiers. protein_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their protein data. psite_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their phosphorylation site data. psite_labels_dict ( dict ) \u2013 Filtered dictionary mapping TF_ids to their phosphorylation site labels.","title":"filter_TF"},{"location":"reference.html#tfopt.evol.optcon.filter.determine_T_use","text":"Determine the number of time points to use for the analysis. Parameters: mRNA_mat ( ndarray ) \u2013 Matrix of mRNA expression data. TF_time_cols ( list ) \u2013 Time points for TF data.","title":"determine_T_use"},{"location":"reference.html#tfopt.evol.utils.iodata","text":"","title":"iodata"},{"location":"reference.html#tfopt.evol.utils.iodata.load_mRNA_data","text":"Load mRNA data from a CSV file. Parameters: filename ( str , default: INPUT3 ) \u2013 Path to the CSV file containing mRNA data. Returns: - mRNA_ids: List of mRNA gene identifiers (strings). - mRNA_mat: Matrix of mRNA expression data (numpy array). - time_cols: List of time columns (excluding \"GeneID\").","title":"load_mRNA_data"},{"location":"reference.html#tfopt.evol.utils.iodata.load_TF_data","text":"Load TF data from a CSV file. Parameters: filename ( str , default: INPUT1 ) \u2013 Path to the CSV file containing TF data. Returns: - TF_ids: List of TF identifiers (strings). - protein_dict: Dictionary mapping TF identifiers to their protein data (numpy array). - psite_dict: Dictionary mapping TF identifiers to their phosphorylation site data (list of numpy arrays). - psite_labels_dict: Dictionary mapping TF identifiers to their phosphorylation site labels (list of strings). - time_cols: List of time columns (excluding \"GeneID\" and \"Psite\").","title":"load_TF_data"},{"location":"reference.html#tfopt.evol.utils.iodata.load_regulation","text":"Load regulation data from a CSV file. Parameters: filename ( str , default: INPUT4 ) \u2013 Path to the CSV file containing regulation data. Returns: - reg_map: Dictionary mapping mRNA genes to their regulators (list of TF identifiers).","title":"load_regulation"},{"location":"reference.html#tfopt.evol.utils.iodata.create_report","text":"Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the directory containing gene folders.","title":"create_report"},{"location":"reference.html#tfopt.evol.utils.iodata.organize_output_files","text":"Organizes output files from multiple directories into separate folders for each protein. Parameters: directories ( str , default: () ) \u2013 List of directories to organize.","title":"organize_output_files"},{"location":"reference.html#tfopt.evol.utils.iodata.format_duration","text":"Format a duration in seconds into a human-readable string. Parameters: seconds ( float ) \u2013 Duration in seconds. Returns: str: Formatted duration string.","title":"format_duration"},{"location":"reference.html#tfopt.evol.utils.params","text":"","title":"params"},{"location":"reference.html#tfopt.evol.utils.params.create_no_psite_array","text":"Create an array indicating whether each TF has no phosphorylation sites. Parameters: n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF. Returns: no_psite_tf ( ndarray ) \u2013 Array indicating whether each TF has no phosphorylation sites.","title":"create_no_psite_array"},{"location":"reference.html#tfopt.evol.utils.params.compute_beta_indices","text":"Compute the starting indices for the beta parameters for each TF. Parameters: num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. n_TF ( int ) \u2013 Number of transcription factors. Returns: beta_start_indices ( ndarray ) \u2013 Array of starting indices for the beta parameters. cum ( int ) \u2013 Total number of beta parameters.","title":"compute_beta_indices"},{"location":"reference.html#tfopt.evol.utils.params.create_initial_guess","text":"Create the initial guess for the optimization variables. Parameters: n_mRNA ( int ) \u2013 Number of mRNAs. n_reg ( int ) \u2013 Number of regulators. n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( ndarray ) \u2013 Array indicating whether each TF has no phosphorylation sites. Returns: x0 ( ndarray ) \u2013 Initial guess for the optimization variables. n_alpha ( int ) \u2013 Number of alpha parameters.","title":"create_initial_guess"},{"location":"reference.html#tfopt.evol.utils.params.create_bounds","text":"Create the lower and upper bounds for the optimization variables. Parameters: n_alpha ( int ) \u2013 Number of alpha parameters. n_beta_total ( int ) \u2013 Total number of beta parameters. lb ( float ) \u2013 Lower bound for the optimization variables. ub ( float ) \u2013 Upper bound for the optimization variables. Returns: xl ( ndarray ) \u2013 Lower bounds for the optimization variables. xu ( ndarray ) \u2013 Upper bounds for the optimization variables.","title":"create_bounds"},{"location":"reference.html#tfopt.evol.utils.params.get_parallel_runner","text":"Get a parallel runner for multi-threading. Returns: runner \u2013 Parallelization runner. pool \u2013 ThreadPool instance for parallel execution.","title":"get_parallel_runner"},{"location":"reference.html#tfopt.evol.utils.params.extract_best_solution","text":"Extract the best solution from the optimization results. Parameters: res \u2013 Optimization results. n_alpha ( int ) \u2013 Number of alpha parameters. n_mRNA ( int ) \u2013 Number of mRNAs. n_reg ( int ) \u2013 Number of regulators. n_TF ( int ) \u2013 Number of transcription factors. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. beta_start_indices ( ndarray ) \u2013 Array of starting indices for the beta parameters. Returns: final_alpha ( ndarray ) \u2013 Final alpha parameters. final_beta ( ndarray ) \u2013 Final beta parameters. best_objectives ( ndarray ) \u2013 Best objectives from the Pareto front. final_x ( ndarray ) \u2013 Final optimization variables.","title":"extract_best_solution"},{"location":"reference.html#tfopt.evol.utils.params.print_alpha_mapping","text":"Print the mapping of transcription factors (TFs) to mRNAs with their corresponding alpha values. Parameters: mRNA_ids ( list ) \u2013 List of mRNA identifiers. reg_map ( dict ) \u2013 Mapping of genes to their regulators. TF_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha parameters (mRNA x TF).","title":"print_alpha_mapping"},{"location":"reference.html#tfopt.evol.utils.params.print_beta_mapping","text":"Print the mapping of transcription factors (TFs) to their beta parameters. Parameters: TF_ids ( list ) \u2013 List of TF identifiers. final_beta ( ndarray ) \u2013 Final beta parameters (TF x \u03b2). psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF.","title":"print_beta_mapping"},{"location":"reference.html#gradient-based-algorithms_1","text":"","title":"Gradient-Based Algorithms"},{"location":"reference.html#tfopt.local.config.constants","text":"","title":"constants"},{"location":"reference.html#tfopt.local.config.constants.parse_args","text":"tfopt.local CLI: bounds and loss selection. Defaults come from config.toml.","title":"parse_args"},{"location":"reference.html#tfopt.local.config.logconf","text":"","title":"logconf"},{"location":"reference.html#tfopt.local.exporter.plotout","text":"","title":"plotout"},{"location":"reference.html#tfopt.local.exporter.plotout.plot_estimated_vs_observed","text":"Plots the estimated vs observed values for a given set of genes and their corresponding TFs. Parameters: predictions ( ndarray ) \u2013 Predicted expression levels. expression_matrix ( ndarray ) \u2013 Observed expression levels. gene_ids ( list ) \u2013 List of gene identifiers. time_points ( ndarray ) \u2013 Time points for the experiments. regulators ( ndarray ) \u2013 Matrix of regulators for each gene. tf_protein_matrix ( ndarray ) \u2013 Matrix of TF protein levels. tf_ids ( list ) \u2013 List of TF identifiers. num_targets ( int ) \u2013 Number of target genes to plot. save_path ( str , default: OUT_DIR ) \u2013 Directory to save the plots.","title":"plot_estimated_vs_observed"},{"location":"reference.html#tfopt.local.exporter.plotout.plot_multistart_summary_runtime_overlay","text":"Creates a scatter plot visualizing multi-start optimization results with runtime overlay. This function reads a CSV summary of multiple optimization runs and generates a scatter plot showing the relationship between run rank and final objective value, with runtime (or iterations) represented as color intensity. Successful and feasible runs are emphasized while unsuccessful or infeasible runs are shown with reduced opacity. Parameters: summary_csv ( str or Path ) \u2013 Path to the CSV file containing multi-start optimization results. out_path ( str or Path , default: None ) \u2013 Path to save the output figure. If None, figure is not saved. Defaults to None. figsize ( tuple , default: (8, 8) ) \u2013 Figure size as (width, height) in inches. Defaults to (8, 8). x_col ( str , default: 'rank' ) \u2013 Column name for x-axis (run rank). If missing, will be created from y_col ranking. Defaults to \"rank\". y_col ( str , default: 'fun' ) \u2013 Column name for y-axis (final objective value). Defaults to \"fun\". c_col ( str , default: 'runtime_s' ) \u2013 Column name for color mapping (typically runtime). Falls back to \"nit\" (iterations) if not found. Defaults to \"runtime_s\". success_col ( str , default: 'success' ) \u2013 Column name indicating optimization success status. Defaults to \"success\". cv_col ( str , default: 'constr_violation' ) \u2013 Column name for constraint violation values. Falls back to common alternatives if not found. Defaults to \"constr_violation\". annotate_best ( bool , default: True ) \u2013 Whether to annotate the best (rank 1) point on the plot. Defaults to True. Returns: tuple \u2013 A tuple containing: - fig (matplotlib.figure.Figure): The generated figure object. - ax (matplotlib.axes.Axes): The axes object of the plot. - df (pd.DataFrame): The processed DataFrame with sorted results. Notes Points are considered feasible if constraint violation <= 1e-8 Infeasible or unsuccessful runs are plotted with reduced opacity (0.25) If rank column is missing, it's automatically generated from objective values If runtime column is missing, falls back to iteration count or constant color","title":"plot_multistart_summary_runtime_overlay"},{"location":"reference.html#tfopt.local.exporter.sheetutils","text":"","title":"sheetutils"},{"location":"reference.html#tfopt.local.exporter.sheetutils.save_results_to_excel","text":"Save the optimization results to an Excel file. Parameters: gene_ids ( list ) \u2013 List of gene identifiers. tf_ids ( list ) \u2013 List of TF identifiers. final_alpha ( ndarray ) \u2013 Final alpha values. final_beta ( ndarray ) \u2013 Final beta values. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels. expression_matrix ( ndarray ) \u2013 Observed expression levels. predictions ( ndarray ) \u2013 Predicted expression levels. objective_value ( float ) \u2013 Objective value from optimization. reg_map ( dict ) \u2013 Mapping of genes to regulators. filename ( str , default: OUT_FILE ) \u2013 Path to the output Excel file.","title":"save_results_to_excel"},{"location":"reference.html#tfopt.local.exporter.sheetutils.export_multistart_results","text":"Export multiple multistart optimization results to an Excel file. Parameters: results ( list ) \u2013 List of optimization results, each containing attributes like 'start_id', 'fun', 'success', etc. Returns: \u2013 None","title":"export_multistart_results"},{"location":"reference.html#tfopt.local.exporter.sheetutils.save_multistart_solutions_npz","text":"Saves multistart optimization solutions to a compressed .npz file format. This function aggregates optimization results into a structured format and saves them in a compressed NumPy .npz file. It processes the solutions, extracting relevant attributes such as optimization variables, function values, success status, and starting IDs, before saving them for later use. Parameters: all_results \u2013 list A list of optimization result objects. Each result object must have the attributes x (optimization solution vector) and fun (objective function value). Optionally, it can have success (indicating whether the optimization succeeded, defaults to False if not present) and start_id (identifier of the starting point, defaults to -1 if not present). out_path \u2013 str or Path The file path where the compressed .npz file will be saved. The path will be converted into a pathlib Path object if it is not already one.","title":"save_multistart_solutions_npz"},{"location":"reference.html#tfopt.local.objfn.minfn","text":"","title":"minfn"},{"location":"reference.html#tfopt.local.objfn.minfn.objective_","text":"Originally implemented by Julius Normann. This version has been modified and optimized for consistency & speed in submodules by Abhinav Mishra. Computes a loss value using one of several loss functions. Parameters: x \u2013 Decision vector. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes, n_TF \u2013 Number of genes and TF respectively. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Integer indicating the loss type (0: MSE, 1: MAE, 2: soft L1, 3: Cauchy, 4: Arctan, 5: Elastic Net, 6: Tikhonov). Returns: loss \u2013 The computed loss (a scalar).","title":"objective_"},{"location":"reference.html#tfopt.local.objfn.minfn.compute_predictions","text":"Computes the predicted expression matrix based on the decision vector x. Parameters: x \u2013 Decision vector. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes \u2013 Number of genes. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. Returns: predictions \u2013 (n_genes x T_use) predicted gene expression values.","title":"compute_predictions"},{"location":"reference.html#tfopt.local.objfn.minfn.objective_wrapper","text":"Wrapper function for the objective function. Parameters: x \u2013 Decision vector. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes \u2013 Number of genes. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Integer indicating the loss type. Returns: loss \u2013 The computed loss (a scalar).","title":"objective_wrapper"},{"location":"reference.html#tfopt.local.opt.optrun","text":"","title":"optrun"},{"location":"reference.html#tfopt.local.opt.optrun.run_optimizer","text":"Runs the optimization algorithm to minimize the objective function. Parameters: x0 \u2013 Initial guess for the optimization variables. bounds \u2013 Bounds for the optimization variables. lin_cons \u2013 Linear constraints for the optimization problem. expression_matrix \u2013 (n_genes x T_use) measured gene expression values. regulators \u2013 (n_genes x n_reg) indices of TF regulators for each gene. tf_protein_matrix \u2013 (n_TF x T_use) TF protein time series. psite_tensor \u2013 (n_TF x n_psite_max x T_use) matrix of PSite signals (padded with zeros). n_reg \u2013 Maximum number of regulators per gene. T_use \u2013 Number of time points used. n_genes, n_TF \u2013 Number of genes and TF respectively. beta_start_indices \u2013 Integer array giving the starting index (in the \u03b2\u2013segment) for each TF. num_psites \u2013 Integer array with the actual number of PSites for each TF. loss_type \u2013 Type of loss function to use. Returns: result : Result of the optimization process, including the optimized parameters and objective value.","title":"run_optimizer"},{"location":"reference.html#tfopt.local.opt.optrun.generate_multistart_x0","text":"Generates multiple starting points for multi-start optimization. Builds a diverse list of starting points mostly: jitter around baseline x0 some: fully random within bounds jitter_frac is relative to (ub - lb). p_random is fraction of starts that are random-in-bounds. Returns: List [ ndarray ] \u2013 List[np.ndarray]: A list of starting points for optimization.","title":"generate_multistart_x0"},{"location":"reference.html#tfopt.local.opt.optrun.run_optimizer_multistart","text":"Executes a multistart optimization loop with parallelization and optional polishing to find the best solution across multiple starting points. The function leverages a parallel approach for running multiple optimizations, selects the best result based on predefined sorting criteria, and optionally refines it. Parameters: x0 ( ndarray ) \u2013 Initial guess for the optimization variables. bounds \u2013 Bounds for the optimization variables, typically a sequence of (min, max) pairs. lin_cons \u2013 Linear constraints for the optimizer, defined as per specific optimizer requirements. expression_matrix \u2013 Input gene expression data utilized in the optimization process. regulators \u2013 Regulatory inputs or factors influencing the optimization process. tf_protein_matrix \u2013 Matrix representing transcription factor proteins relevant to the process. psite_tensor \u2013 Tensor containing phosphorylation site data used in the computations. n_reg \u2013 Number of regulators involved in the optimization. T_use \u2013 Specific configuration parameter determining time or iteration usage. n_genes \u2013 Number of genes considered within the problem scope. beta_start_indices \u2013 Indices indicating the start positions of beta parameters in the optimization. num_psites \u2013 Total number of phosphorylation sites accounted for in optimization. loss_type \u2013 Type of loss function used for evaluating optimization performance. run_optimizer_func \u2013 Optimization function to be executed for each starting point. cfg ( Optional [ MultiStartConfig ] , default: None ) \u2013 Configuration object specifying multistart parameters such as number of starts, parallelization settings, and randomness. polish ( bool , default: True ) \u2013 Indicates whether to perform a final optimization run initialized at the best solution. Defaults to True. Returns: Tuple \u2013 A tuple containing: - The best result as determined by sorting criteria. - A list of sorted optimization results from all starting points.","title":"run_optimizer_multistart"},{"location":"reference.html#tfopt.local.optcon.construct","text":"","title":"construct"},{"location":"reference.html#tfopt.local.optcon.construct.build_fixed_arrays","text":"Builds fixed-shape arrays from the input data. Parameters: - gene_ids \u2013 list of mRNA identifiers. - expression_matrix \u2013 array of shape (n_genes, T) with mRNA expression levels. - tf_ids \u2013 list of TF identifiers. - tf_protein \u2013 dict mapping TFs to their protein levels. - tf_psite_data \u2013 dict mapping TFs to their phosphorylation sites. - tf_psite_labels \u2013 dict mapping TFs to their phosphorylation site labels. - reg_map \u2013 mapping of genes to their regulators (TFs). Returns: \u2013 expression_matrix: array of shape (n_genes, T) with mRNA expression levels. \u2013 regulators: array of shape (n_genes, n_reg) with TF indices. \u2013 tf_protein_matrix: array of shape (n_TF, T) with TF protein levels. \u2013 psite_tensor: array of shape (n_TF, n_psite_max, T) with phosphorylation sites. \u2013 n_reg: number of regulators. \u2013 n_psite_max: maximum number of phosphorylation sites across all TFs. \u2013 psite_labels_arr: list of labels for each TF's phosphorylation sites. \u2013 num_psites: array indicating the number of phosphorylation sites for each TF.","title":"build_fixed_arrays"},{"location":"reference.html#tfopt.local.optcon.construct.constraint_alpha_func","text":"For each gene, the sum of its alpha parameters must equal 1. Parameters: x ( ndarray ) \u2013 Decision vector. n_genes ( int ) \u2013 Number of genes. n_reg ( int ) \u2013 Number of regulators. Returns: \u2013 np.ndarray: Array of constraints.","title":"constraint_alpha_func"},{"location":"reference.html#tfopt.local.optcon.construct.constraint_beta_func","text":"For each TF, the sum of its beta parameters must equal 1. Parameters: x ( ndarray ) \u2013 Decision vector. n_alpha ( int ) \u2013 Number of alpha parameters. n_TF ( int ) \u2013 Number of transcription factors. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( list ) \u2013 List indicating if a TF has no phosphorylation site. Returns: \u2013 np.ndarray: Array of constraints.","title":"constraint_beta_func"},{"location":"reference.html#tfopt.local.optcon.construct.build_linear_constraints","text":"Build linear constraints for the transcription factor optimization problem. Parameters: n_genes ( int ) \u2013 Number of genes. n_TF ( int ) \u2013 Number of transcription factors. n_reg ( int ) \u2013 Number of regulators. n_alpha ( int ) \u2013 Number of alpha parameters. beta_start_indices ( list ) \u2013 List of starting indices for beta parameters. num_psites ( list ) \u2013 List of number of phosphorylation sites for each TF. no_psite_tf ( list ) \u2013 List indicating if a TF has no phosphorylation site. Returns: list \u2013 List of linear constraints.","title":"build_linear_constraints"},{"location":"reference.html#tfopt.local.optcon.filter","text":"","title":"filter"},{"location":"reference.html#tfopt.local.optcon.filter.load_and_filter_data","text":"Load and filter data for the optimization problem. Returns: \u2013 gene_ids (list): List of gene IDs. \u2013 expr_matrix (np.ndarray): Gene expression matrix. \u2013 expr_time_cols (list): Time columns for expression data. \u2013 tf_ids (list): List of transcription factor IDs. \u2013 tf_protein (dict): Dictionary mapping TF IDs to their protein data. \u2013 tf_psite_data (dict): Dictionary mapping TF IDs to their phosphorylation site data. \u2013 tf_psite_labels (dict): Dictionary mapping TF IDs to their phosphorylation site labels. \u2013 tf_time_cols (list): Time columns for TF data. \u2013 reg_map (dict): Regulation map, mapping gene IDs to their regulators.","title":"load_and_filter_data"},{"location":"reference.html#tfopt.local.optcon.filter.prepare_data","text":"Prepares the data for optimization by filtering the expression matrix to match the number of time points and building fixed arrays. Parameters: gene_ids ( list ) \u2013 List of gene IDs. expr_matrix ( ndarray ) \u2013 Gene expression matrix. tf_ids ( list ) \u2013 List of transcription factor IDs. tf_protein ( dict ) \u2013 Dictionary mapping TF IDs to their protein data. tf_psite_data ( dict ) \u2013 Dictionary mapping TF IDs to their phosphorylation site data. tf_psite_labels ( dict ) \u2013 Dictionary mapping TF IDs to their phosphorylation site labels. tf_time_cols ( list ) \u2013 Time columns for TF data. reg_map ( dict ) \u2013 Regulation map, mapping gene IDs to their regulators. Returns: fixed_arrays (tuple): Tuple containing the fixed arrays: - expression_matrix: array of shape (n_genes, T) - regulators: array of shape (n_genes, n_reg) with indices into tf_ids. - tf_protein_matrix: array of shape (n_TF, T) - psite_tensor: array of shape (n_TF, n_psite_max, T), padded with zeros. - n_reg: maximum number of regulators per gene. - n_psite_max: maximum number of PSites among TFs. - psite_labels_arr: list (length n_TF) of lists of PSite names (padded with empty strings). - num_psites: array of length n_TF with the actual number of PSites for each TF. T_use (int): Number of time points used in the expression matrix.","title":"prepare_data"},{"location":"reference.html#tfopt.local.utils.iodata","text":"","title":"iodata"},{"location":"reference.html#tfopt.local.utils.iodata.min_max_normalize","text":"Row-wise (per-sample) min-max normalize time-series columns starting with 'x'. Parameters: df ( DataFrame ) \u2013 Input DataFrame with time-series columns (x1-xN). custom_max ( float , default: None ) \u2013 If given, used as max for all rows. Returns: \u2013 pd.DataFrame: Normalized DataFrame with same shape.","title":"min_max_normalize"},{"location":"reference.html#tfopt.local.utils.iodata.load_expression_data","text":"Loads gene expression (mRNA) data. Parameters: filename ( str , default: INPUT3 ) \u2013 Path to the CSV file containing mRNA data. Returns: \u2013 gene_ids: List of gene identifiers (strings). \u2013 expression_matrix: Matrix of gene expression data (numpy array). \u2013 time_cols: List of time columns (excluding \"GeneID\").","title":"load_expression_data"},{"location":"reference.html#tfopt.local.utils.iodata.load_tf_protein_data","text":"Loads TF protein data along with PSite information. Parameters: filename ( str , default: INPUT1 ) \u2013 Path to the CSV file containing TF protein data. Returns: - tf_ids: List of TF identifiers (strings). - tf_protein: Dictionary mapping TF identifiers to their protein data (numpy array). - tf_psite_data: Dictionary mapping TF identifiers to their phosphorylation site data (list of numpy arrays). - tf_psite_labels: Dictionary mapping TF identifiers to their phosphorylation site labels (list of strings). - time_cols: List of time columns (excluding \"GeneID\" and \"Psite\").","title":"load_tf_protein_data"},{"location":"reference.html#tfopt.local.utils.iodata.load_regulation","text":"Returns a mapping from gene (source) to a list of TFs (targets). Parameters: filename ( str , default: INPUT4 ) \u2013 Path to the CSV file containing regulation data. Returns: - reg_map: Dictionary mapping gene identifiers to lists of TF identifiers.","title":"load_regulation"},{"location":"reference.html#tfopt.local.utils.iodata.summarize_stats","text":"Summarizes statistics for the expression data (input3) and TF protein data (input1). Parameters: input3 ( str , default: INPUT3 ) \u2013 Path to the expression data CSV file. input1 ( str , default: INPUT1 ) \u2013 Path to the TF protein data CSV file. input4 ( str , default: INPUT4 ) \u2013 Path to the mapping file CSV.","title":"summarize_stats"},{"location":"reference.html#tfopt.local.utils.iodata.create_report","text":"Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root results directory. output_file ( str , default: 'report.html' ) \u2013 Name of the generated global report file (placed inside results_dir).","title":"create_report"},{"location":"reference.html#tfopt.local.utils.iodata.organize_output_files","text":"Function to organize output files into protein-specific folders. Parameters: directories ( str , default: () ) \u2013 List of directories to organize.","title":"organize_output_files"},{"location":"reference.html#tfopt.local.utils.params","text":"","title":"params"},{"location":"reference.html#tfopt.local.utils.params.get_optimization_parameters","text":"Prepare the optimization parameters for the optimization problem. Parameters: expression_matrix ( ndarray ) \u2013 Gene expression matrix. tf_protein_matrix ( ndarray ) \u2013 TF protein matrix. n_reg ( int ) \u2013 Number of regulators. T_use ( int ) \u2013 Number of time points to use. psite_labels_arr ( list ) \u2013 List of phosphorylation site labels for each TF. num_psites ( ndarray ) \u2013 Array containing the number of phosphorylation sites for each TF. lb ( float ) \u2013 Lower bound for beta parameters. ub ( float ) \u2013 Upper bound for beta parameters. Returns: x0 (np.ndarray): Initial guess for the optimization variables. n_alpha (int): Number of alpha parameters. beta_start_indices (np.ndarray): Starting indices for beta parameters. bounds (list): List of bounds for the optimization variables. no_psite_tf (np.ndarray): Array indicating whether each TF has no phosphorylation sites. n_genes (int): Number of genes. n_TF (int): Number of transcription factors.","title":"get_optimization_parameters"},{"location":"reference.html#tfopt.local.utils.params.postprocess_results","text":"Post-process the optimization results to extract the final alpha and beta parameters. Parameters: result ( OptimizeResult ) \u2013 The result of the optimization. n_alpha ( int ) \u2013 Number of alpha parameters. n_genes ( int ) \u2013 Number of genes. n_reg ( int ) \u2013 Number of regulators. beta_start_indices ( ndarray ) \u2013 Starting indices for beta parameters. num_psites ( ndarray ) \u2013 Array containing the number of phosphorylation sites for each TF. reg_map ( dict ) \u2013 Regulation map, mapping gene IDs to their regulators. gene_ids ( list ) \u2013 List of gene IDs. tf_ids ( list ) \u2013 List of transcription factor IDs. psite_labels_arr ( list ) \u2013 List of lists containing phosphorylation site labels. Returns: final_x ( ndarray ) \u2013 Final optimization result. final_alpha ( ndarray ) \u2013 Final alpha parameters reshaped into a matrix. final_beta ( ndarray ) \u2013 Final beta parameters reshaped into a matrix.","title":"postprocess_results"},{"location":"reference.html#fitting-analysis","text":"","title":"Fitting Analysis"},{"location":"reference.html#tfopt.fitanalysis.helper","text":"","title":"helper"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter","text":"A class to plot various analysis results from an Excel file.","title":"Plotter"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.__init__","text":"Initializes the Plotter instance by loading data from the Excel file. Args: filepath (str): Path to the Excel file containing analysis results. savepath (str): Directory where the plots will be saved.","title":"__init__"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.load_data","text":"Loads data from the specified Excel file. Args: filepath (str): Path to the Excel file. savepath (str): Directory where the plots will be saved.","title":"load_data"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_alpha_distribution","text":"Plots the distribution of alpha parameter values grouped by transcription factors (TFs) using a strip plot.","title":"plot_alpha_distribution"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_beta_barplots","text":"Processes the beta values DataFrame and creates a separate bar plot for each unique transcription factor (TF).","title":"plot_beta_barplots"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_heatmap_abs_residuals","text":"Plots a heatmap of the absolute values of the residuals.","title":"plot_heatmap_abs_residuals"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_goodness_of_fit","text":"Creates a scatter plot comparing observed vs. estimated values, fits a linear regression model, plots the 95% confidence interval, and labels points outside the confidence interval.","title":"plot_goodness_of_fit"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_kld","text":"Plots the Kullback-Leibler Divergence (KLD) for each mRNA. The KLD is calculated between the observed and estimated distributions of the mRNA expression levels.","title":"plot_kld"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_pca","text":"Plots a PCA (Principal Component Analysis) of the observed and estimated values.","title":"plot_pca"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_boxplot_alpha","text":"Plots a boxplot of the alpha values.","title":"plot_boxplot_alpha"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_boxplot_beta","text":"Plots a boxplot of the beta values.","title":"plot_boxplot_beta"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_cdf_alpha","text":"Plots the cumulative distribution function (CDF) of the alpha values.","title":"plot_cdf_alpha"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_cdf_beta","text":"Plots the cumulative distribution function (CDF) of the beta values.","title":"plot_cdf_beta"},{"location":"reference.html#tfopt.fitanalysis.helper.Plotter.plot_time_wise_residuals","text":"Plots the residuals over time for each mRNA.","title":"plot_time_wise_residuals"},{"location":"reference.html#ode-modelling-parameter-estimation","text":"","title":"ODE Modelling &amp; Parameter Estimation"},{"location":"reference.html#configuration","text":"","title":"Configuration"},{"location":"reference.html#config.cli","text":"Command\u2011line entry point for the phoskintime pipeline.","title":"cli"},{"location":"reference.html#config.cli--usage","text":"","title":"Usage"},{"location":"reference.html#config.cli--come-one-level-up-from-the-package-root-it-should-be-the-working-directory","text":"","title":"Come one level up from the package root, it should be the working directory"},{"location":"reference.html#config.cli--where-you-can-see-the-project-directory","text":"","title":"(where you can see the project directory)."},{"location":"reference.html#config.cli--run-everything-with-the-default-local-solver","text":"python phoskintime all","title":"run everything with the default (local) solver"},{"location":"reference.html#config.cli--run-only-preprocessing","text":"python phoskintime prep","title":"run only preprocessing"},{"location":"reference.html#config.cli--run-tfopt-with-local-flavour","text":"python phoskintime tfopt --mode local","title":"run tfopt with local flavour"},{"location":"reference.html#config.cli--run-tfopt-with-evol-flavour","text":"python phoskintime tfopt --mode evol","title":"run tfopt with evol flavour"},{"location":"reference.html#config.cli--run-kinopt-with-local-flavour","text":"python phoskintime kinopt --mode local","title":"run kinopt with local flavour"},{"location":"reference.html#config.cli--run-kinopt-with-evol-flavour","text":"python phoskintime kinopt --mode evol","title":"run kinopt with evol flavour"},{"location":"reference.html#config.cli--run-the-model","text":"python phoskintime model","title":"run the model"},{"location":"reference.html#config.cli.prep","text":"Preprocess data (processing.cleanup).","title":"prep"},{"location":"reference.html#config.cli.tfopt","text":"Transcription-Factor-mRNA Optimisation. Parameters: mode ( str , default: Option ('local', help='local | evol') ) \u2013 local | evol conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. Returns: None","title":"tfopt"},{"location":"reference.html#config.cli.kinopt","text":"Kinase-Phosphorylation Optimization. Parameters: mode ( str , default: Option ('local', help='local | evol') ) \u2013 local | evol conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to TOML/YAML config. Uses defaults if omitted.') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. Returns: None","title":"kinopt"},{"location":"reference.html#config.cli.model","text":"Run the model (bin.main). Parameters: conf ( Path | None , default: Option (None, '--conf', file_okay=True, dir_okay=False, writable=False, help='Path to model config file. Uses defaults if omitted.') ) \u2013 Path to model config file. Uses defaults if omitted. Returns: None","title":"model"},{"location":"reference.html#config.cli.all","text":"Run every stage in sequence. Preprocessing -> TF optimisation -> Kinase optimisation -> Model. Parameters: tf_mode ( str , default: Option ('local', help='tfopt mode: local | evol') ) \u2013 tfopt mode: local | evol kin_mode ( str , default: Option ('local', help='kinopt mode: local | evol') ) \u2013 kinopt mode: local | evol tf_conf ( Path | None , default: Option (None, help='tfopt config file') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. kin_conf ( Path | None , default: Option (None, help='kinopt config file') ) \u2013 Path to TOML/YAML config. Uses defaults if omitted. model_conf ( Path | None , default: Option (None, help='model config file') ) \u2013 Path to model config file. Uses defaults if omitted. Returns: None","title":"all"},{"location":"reference.html#config.config","text":"","title":"config"},{"location":"reference.html#config.config.parse_bound_pair","text":"Parse a string representing a pair of bounds (lower, upper) into a tuple of floats. The upper bound can be 'inf' or 'infinity' to represent infinity. Raises ValueError if the input is not in the correct format. Args: val (str): The string to parse, e.g., \"0,3\" or \"0,infinity\". Returns: tuple: A tuple containing the lower and upper bounds as floats.","title":"parse_bound_pair"},{"location":"reference.html#config.config.parse_fix_value","text":"Parse a fixed value or a list of fixed values from a string. If the input is a single value, it returns that value as a float. If the input is a comma-separated list, it returns a list of floats. Raises ValueError if the input is not in the correct format. Args: val (str): The string to parse, e.g., \"1.0\" or \"1.0,2.0\". Returns: float or list: The parsed fixed value(s) as a float or a list of floats.","title":"parse_fix_value"},{"location":"reference.html#config.config.ensure_output_directory","text":"Parameters: directory ( str ) \u2013 The path to the directory to create. Returns: None","title":"ensure_output_directory"},{"location":"reference.html#config.config.parse_args","text":"Parse command-line arguments for the PhosKinTime script. This function uses argparse to define and handle the command-line options. It includes options for setting bounds, fixed parameters, bootstrapping, profile estimation, and input file paths. The function returns the parsed arguments as a Namespace object. The arguments include: --A-bound, --B-bound, --C-bound, --D-bound, --Ssite-bound, --Dsite-bound, --bootstraps, --input-excel-protein, --input-excel-psite, --input-excel-rna. Returns: argparse.Namespace: The parsed command-line arguments.","title":"parse_args"},{"location":"reference.html#config.config.log_config","text":"Log the configuration settings for the PhosKinTime script. This function logs the parameter bounds bootstrapping iterations. It uses the provided logger to output the information. Parameters: logger ( Logger ) \u2013 The logger to use for logging. bounds ( dict ) \u2013 The parameter bounds. args ( Namespace ) \u2013 The command-line arguments. Returns: None","title":"log_config"},{"location":"reference.html#config.config.extract_config","text":"Extract configuration settings from command-line arguments. This function creates a dictionary containing the parameter bounds, bootstrapping iterations. The function returns the configuration dictionary. Parameters: args ( Namespace ) \u2013 The command-line arguments. Returns: dict: The configuration settings.","title":"extract_config"},{"location":"reference.html#config.config.score_fit","text":"Calculate the score for the fit of a model to target data. The score is a weighted combination of various metrics including mean squared error (MSE), root mean squared error (RMSE), mean absolute error (MAE), variance, and regularization penalty. The weights for each metric can be adjusted using the parameters alpha, beta, gamma, and delta. The regularization penalty is controlled by the reg_penalty parameter. The function returns the calculated score. Args: params (np.ndarray): The model parameters. target (np.ndarray): The target data. prediction (np.ndarray): The predicted data. alpha (float): Weight for RMSE. beta (float): Weight for MAE. gamma (float): Weight for variance. delta (float): Weight for MSE. mu (float): Regularization penalty weight. Returns: float: The calculated score.","title":"score_fit"},{"location":"reference.html#config.config.future_times","text":"Extend ttime points by n_new points, each spaced by multiplying the previous interval by ratio. If ratio is None, it is inferred from the last two points. Parameters: n_new ( int ) \u2013 Number of new time points to generate. ratio ( float , default: None ) \u2013 Ratio to multiply the previous interval. Defaults to None. tp ( ndarray , default: TIME_POINTS ) \u2013 Existing time points. Defaults to TIME_POINTS. Returns: np.ndarray: Extended time points.","title":"future_times"},{"location":"reference.html#config.constants","text":"","title":"constants"},{"location":"reference.html#config.constants.get_param_names_rand","text":"Generate parameter names for the random model. Format: ['A', 'B', 'C', 'D'] + ['S1', 'S2', ..., 'S '] + [parameter names for all combinations of dephosphorylation sites]. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of parameter names.","title":"get_param_names_rand"},{"location":"reference.html#config.constants.get_param_names_ds","text":"Generate parameter names for distributive or successive models. Format: ['A', 'B', 'C', 'D'] + ['S1', 'S2', ..., 'S '] + ['D1', 'D2', ..., 'D ']. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of parameter names.","title":"get_param_names_ds"},{"location":"reference.html#config.constants.generate_labels_rand","text":"Generates labels for the states based on the number of phosphorylation sites for the random model. Returns a list with the base labels \"R\" and \"P\", followed by labels for all combinations of phosphorylated sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of state labels.","title":"generate_labels_rand"},{"location":"reference.html#config.constants.generate_labels_ds","text":"Generates labels for the states based on the number of phosphorylation sites for the distributive or successive models. Returns a list with the base labels \"R\" and \"P\", followed by labels for each individual phosphorylated state. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: list: List of state labels.","title":"generate_labels_ds"},{"location":"reference.html#config.constants.location","text":"Returns a clickable hyperlink string for supported terminals using ANSI escape sequences. Parameters: path ( str ) \u2013 The file path or URL. label ( str , default: None ) \u2013 The display text for the link. Defaults to the path if not provided. Returns: str ( str ) \u2013 A string that, when printed, shows a clickable link in terminals that support ANSI hyperlinks.","title":"location"},{"location":"reference.html#config.constants.get_number_of_params_rand","text":"Calculate the number of parameters required for the ODE system based on the number of phosphorylation sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites (1 to 4). Returns: int \u2013 Total number of parameters.","title":"get_number_of_params_rand"},{"location":"reference.html#config.constants.get_bounds_rand","text":"Generate bounds for the ODE parameters based on the number of phosphorylation sites. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. lower ( float , default: 0 ) \u2013 Lower bound for parameters. upper ( float ) \u2013 Upper bound for parameters. Returns: list \u2013 List of bounds as [lower, upper] for each parameter.","title":"get_bounds_rand"},{"location":"reference.html#config.logconf","text":"","title":"logconf"},{"location":"reference.html#config.logconf.ColoredFormatter","text":"Bases: Formatter Custom formatter to add colors to log messages and elapsed time. This formatter uses ANSI escape codes to colorize the log messages based on their severity level. It also includes a right-aligned clock that shows the elapsed time since the logger was initialized. The elapsed time is displayed in a human-readable format (e.g., \"1h 23m 45s\"). The formatter is designed to be used with a logger that has a console handler. The elapsed time is calculated from the time the logger was initialized and is displayed in a right-aligned format. The formatter also ensures that the log messages are padded to a specified width, which can be adjusted using the width parameter. The remove_ansi method is used to strip ANSI escape codes from the log message for accurate padding calculation. The format method is overridden to customize the log message format, including the timestamp, logger name, log level, and message. The setup_logger function is used to configure the logger with a file handler and a stream handler. The file handler writes log messages to a specified log file, while the stream handler outputs log messages to the console. The logger is set to the specified logging level, and the log file is created in the specified directory. The log file is rotated based on size, and old log files are backed up.","title":"ColoredFormatter"},{"location":"reference.html#config.logconf.ColoredFormatter.format","text":"Format the log record with colors and elapsed time. This method overrides the default format method to customize the log message format. It includes the timestamp, logger name, log level, and message.","title":"format"},{"location":"reference.html#config.logconf.ColoredFormatter.remove_ansi","text":"Remove ANSI escape codes from a string.","title":"remove_ansi"},{"location":"reference.html#config.logconf.setup_logger","text":"Setup a logger with colored output and file logging. This function creates a logger with colored output for console messages :param name: :param log_file: :param level: :param log_dir: :param rotate: :param max_bytes: :param backup_count: :param mp_file_logging: - \"off\": disable file logging - \"main_only\": file logging only in main process - \"per_process\": file logging in each process :return: logger","title":"setup_logger"},{"location":"reference.html#core-functions","text":"","title":"Core Functions"},{"location":"reference.html#paramest.normest","text":"","title":"normest"},{"location":"reference.html#paramest.normest.worker_find_lambda","text":"Worker function for a single lambda value. Parameters: lam ( float ) \u2013 Regularization parameter. gene ( str ) \u2013 Gene name. target ( ndarray ) \u2013 Target data. p0 ( ndarray ) \u2013 Initial parameter guess. time_points ( ndarray ) \u2013 Time points for the model fitting. free_bounds ( Tuple [ ndarray , ndarray ] ) \u2013 Parameter bounds for the optimization. init_cond ( ndarray ) \u2013 Initial conditions for the ODE solver. num_psites ( int ) \u2013 Number of phosphorylation sites. p_data ( ndarray ) \u2013 Measurement data for protein-phospho. pr_data ( ndarray ) \u2013 Reference data for protein. Returns: Tuple [ float , float , str ] \u2013 Tuple containing the lambda value, score, and weight key.","title":"worker_find_lambda"},{"location":"reference.html#paramest.normest.find_best_lambda","text":"Finds best lambda_reg to use in model_func.","title":"find_best_lambda"},{"location":"reference.html#paramest.normest.normest","text":"Function to estimate parameters for a given gene using ODE models. Parameters: gene \u2013 Gene name. pr_data \u2013 Protein data. p_data \u2013 Phosphorylation data. r_data \u2013 Reference data. init_cond \u2013 Initial conditions for the ODE solver. num_psites \u2013 Number of phosphorylation sites. time_points \u2013 Time points for the model fitting. bounds \u2013 Parameter bounds for the optimization. bootstraps \u2013 Number of bootstrap iterations. use_regularization \u2013 Whether to use regularization in the fitting process. Returns: \u2013 Tuple containing estimated parameters, model fits, error values, and regularization term.","title":"normest"},{"location":"reference.html#paramest.toggle","text":"","title":"toggle"},{"location":"reference.html#paramest.toggle.estimate_parameters","text":"This function allows for the selection of the estimation mode and handles the parameter estimation process accordingly. Parameters: gene ( str ) \u2013 Gene name. pr_data ( array ) \u2013 Array of protein data. p_data ( array ) \u2013 Array of protein-phospho data. r_data ( array ) \u2013 Array of RNA data. init_cond ( array ) \u2013 Initial conditions for the model. num_psites ( int ) \u2013 Number of phosphorylation sites. time_points ( array ) \u2013 Time points for the data. bounds ( tuple ) \u2013 Bounds for the parameter estimation. bootstraps ( int ) \u2013 Number of bootstrap samples. Returns: model_fits ( list ) \u2013 List of model fits. estimated_params ( array ) \u2013 Estimated parameters. seq_model_fit ( array ) \u2013 Sequence model fit. errors ( array ) \u2013 Errors in the estimation. reg_term ( float ) \u2013 Regularization term.","title":"estimate_parameters"},{"location":"reference.html#weights-for-curve-fitting","text":"","title":"Weights for Curve Fitting"},{"location":"reference.html#models.weights","text":"","title":"weights"},{"location":"reference.html#models.weights.early_emphasis","text":"Function that calculates custom weights for early time points in a dataset. Parameters: pr_data \u2013 2D numpy array of shape (num_psites, n_times) p_data \u2013 2D numpy array of shape (num_psites, n_times) time_points \u2013 1D numpy array of time points num_psites \u2013 Number of phosphorylation sites Returns: custom_weights \u2013 1D numpy array of weights for early time points","title":"early_emphasis"},{"location":"reference.html#models.weights.get_protein_weights","text":"Function to extract weights for a specific gene from the input files. Parameters: gene ( str ) \u2013 Gene ID to filter the weights. input1_path ( Path , default: parent / 'processing' / 'input1_wstd.csv' ) \u2013 Path to the input1_wstd.csv file. input2_path ( Path , default: parent / 'data' / 'input2.csv' ) \u2013 Path to the input2.csv file. Returns: weights ( ndarray ) \u2013 Extracted weights for the specified gene.","title":"get_protein_weights"},{"location":"reference.html#models.weights.full_weight","text":"Function to create a full weight array for parameter estimation. Parameters: p_data_weight ( ndarray ) \u2013 The weight data to be processed. use_regularization ( bool ) \u2013 Flag to indicate if regularization is used. reg_len ( int ) \u2013 Length of the regularization term. Returns: \u2013 numpy.ndarray: The full weight array.","title":"full_weight"},{"location":"reference.html#models.weights.get_weight_options","text":"Function to calculate weights for parameter estimation based on the target data and time points. Parameters: target ( ndarray ) \u2013 The target data for which weights are calculated. t_target ( ndarray ) \u2013 The time points corresponding to the target data. num_psites ( int ) \u2013 Number of phosphorylation sites. use_regularization ( bool ) \u2013 Flag to indicate if regularization is used. reg_len ( int ) \u2013 Length of the regularization term. early_weights ( ndarray ) \u2013 Weights for early time points. ms_gauss_weights ( ndarray ) \u2013 Weights based on Gaussian distribution. Returns: dict \u2013 A dictionary containing different weight options.","title":"get_weight_options"},{"location":"reference.html#parameter-estimation","text":"","title":"Parameter Estimation"},{"location":"reference.html#paramest.core","text":"","title":"core"},{"location":"reference.html#paramest.core.process_gene","text":"Process a single gene by estimating its parameters and generating plots. Parameters: gene ( str ) \u2013 Gene name. protein_data ( DataFrame ) \u2013 DataFrame containing protein-only data. kinase_data ( DataFrame ) \u2013 DataFrame containing kinase data. mrna_data ( DataFrame ) \u2013 DataFrame containing mRNA data. time_points ( list ) \u2013 List of time points for the experiment. bounds ( tuple ) \u2013 Bounds for parameter estimation. bootstraps ( int , default: 0 ) \u2013 Number of bootstrap iterations. Defaults to 0. out_dir ( str , default: OUT_DIR ) \u2013 Output directory for saving results. Defaults to OUT_DIR. Returns: \u2013 gene: The gene being processed. \u2013 estimated_params: Estimated parameters for the gene. \u2013 model_fits: Model fits for the gene. \u2013 seq_model_fit: Sequential model fit for the gene. \u2013 errors: Error metrics (MSE, MAE). \u2013 final_params: Final estimated parameters. \u2013 param_df: DataFrame of estimated parameters. \u2013 gene_psite_data: Dictionary of gene-specific data. \u2013 psite_labels: Labels for phosphorylation sites. \u2013 pca_result: PCA result for the gene. \u2013 ev: Explained variance for PCA. \u2013 tsne_result: t-SNE result for the gene. \u2013 perturbation_analysis: Sensitivity analysis results. \u2013 perturbation_curves_params: Trajectories with parameters for sensitivity analysis. \u2013 knockout_results: Dictionary of knockout results. \u2013 regularization: Regularization value used in parameter estimation.","title":"process_gene"},{"location":"reference.html#paramest.core.process_gene_wrapper","text":"Wrapper function to process a gene. Parameters: gene ( str ) \u2013 Gene name. protein_data ( DataFrame ) \u2013 DataFrame containing protein-only data. kinase_data ( DataFrame ) \u2013 DataFrame containing kinase data. mrna_data ( DataFrame ) \u2013 DataFrame containing mRNA data. time_points ( list ) \u2013 List of time points for the experiment. bounds ( tuple ) \u2013 Bounds for parameter estimation. bootstraps ( int ) \u2013 Number of bootstrap iterations. Defaults to 0. out_dir ( str , default: OUT_DIR ) \u2013 Output directory for saving results. Defaults to OUT_DIR. Returns: dict \u2013 A dictionary containing the results of the gene processing.","title":"process_gene_wrapper"},{"location":"reference.html#confidence-intervals-using-linearization","text":"","title":"Confidence Intervals using Linearization"},{"location":"reference.html#paramest.identifiability.ci","text":"","title":"ci"},{"location":"reference.html#paramest.identifiability.ci.confidence_intervals","text":"Computes the confidence intervals for parameter estimates using Wald Intervals approach. Parameters: gene ( str ) \u2013 Gene name. popt ( ndarray ) \u2013 Optimized parameter estimates. pcov ( ndarray ) \u2013 Covariance matrix of the optimized parameters. target ( ndarray ) \u2013 Target data. model ( ndarray ) \u2013 Model predictions. alpha_val ( float , default: 0.05 ) \u2013 Significance level for confidence intervals. Defaults to 0.05. Returns: dict \u2013 A dictionary containing the confidence intervals and other statistics.","title":"confidence_intervals"},{"location":"reference.html#knockout-analysis","text":"","title":"Knockout Analysis"},{"location":"reference.html#knockout.helper","text":"","title":"helper"},{"location":"reference.html#perturbation-parameter-sensitivity-analysis","text":"","title":"Perturbation &amp; Parameter Sensitivity Analysis"},{"location":"reference.html#sensitivity.analysis","text":"","title":"analysis"},{"location":"reference.html#sensitivity.analysis.compute_bound","text":"Computes the lower and upper bounds for a given parameter value for sensitivity analysis and perturbations. Parameters: value ( float ) \u2013 The parameter value. perturbation ( float , default: PERTURBATIONS_VALUE ) \u2013 The perturbation factor. Returns: list \u2013 A list containing the lower and upper bounds.","title":"compute_bound"},{"location":"reference.html#sensitivity.analysis.define_sensitivity_problem_rand","text":"Defines the Morris sensitivity analysis problem for the random model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. values ( list ) \u2013 List of parameter values. Returns: dict \u2013 A dictionary containing the number of variables, parameter names, and bounds.","title":"define_sensitivity_problem_rand"},{"location":"reference.html#sensitivity.analysis.define_sensitivity_problem_ds","text":"Defines the Morris sensitivity analysis problem for the dynamic-site model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites. values ( list ) \u2013 List of parameter values. Returns: dict \u2013 A dictionary containing the number of variables, parameter names, and bounds.","title":"define_sensitivity_problem_ds"},{"location":"reference.html#model-diagram","text":"","title":"Model Diagram"},{"location":"reference.html#models.diagram.helpers","text":"","title":"helpers"},{"location":"reference.html#models.diagram.helpers.powerset","text":"Return the list of all subsets (as frozensets) of the given iterable. Parameters: iterable \u2013 An iterable (e.g., list, set) to generate subsets from. Returns: A list of frozensets representing all subsets of the input iterable.","title":"powerset"},{"location":"reference.html#models.diagram.helpers.state_label","text":"Convert a set of phosphorylation sites into a node label. Parameters: state \u2013 A frozenset representing the phosphorylation state. Returns: A string representing the label for the node.","title":"state_label"},{"location":"reference.html#models.diagram.helpers.create_random_diagram","text":"Create a random phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram.","title":"create_random_diagram"},{"location":"reference.html#models.diagram.helpers.create_distributive_diagram","text":"Create a distributive phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram.","title":"create_distributive_diagram"},{"location":"reference.html#models.diagram.helpers.create_successive_model","text":"Create a successive phosphorylation diagram. Parameters: x \u2013 Placeholder parameter, not used in this function. num_sites \u2013 The number of phosphorylation sites. output_filename \u2013 The name of the output file for the diagram.","title":"create_successive_model"},{"location":"reference.html#model-types","text":"","title":"Model Types"},{"location":"reference.html#models.distmod","text":"","title":"distmod"},{"location":"reference.html#models.distmod.ode_core","text":"The core ODE system for the distributive phosphorylation model. Parameters: y \u2013 array of concentrations t \u2013 time A \u2013 mRNA production rate B \u2013 mRNA degradation rate C \u2013 protein production rate D \u2013 protein degradation rate S_rates \u2013 phosphorylation rates for each site D_rates \u2013 dephosphorylation rates for each site Returns: dydt \u2013 array of derivatives","title":"ode_core"},{"location":"reference.html#models.distmod.unpack_params","text":"Function to unpack the parameters for the distributive ODE system. Parameters: params ( array ) \u2013 Parameter vector containing A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m. num_psites ( int ) \u2013 Number of phosphorylation sites. Returns: A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. S_rates ( array ) \u2013 Phosphorylation rates for each site. D_rates ( array ) \u2013 Dephosphorylation rates for each site.","title":"unpack_params"},{"location":"reference.html#models.distmod.solve_ode","text":"Solve the ODE system for the distributive phosphorylation model. Parameters: params \u2013 array of parameters init_cond \u2013 initial conditions num_psites \u2013 number of phosphorylation sites t \u2013 time points Returns: sol \u2013 solution of the ODE system P_fitted \u2013 phosphorylated sites","title":"solve_ode"},{"location":"reference.html#models.randmod","text":"","title":"randmod"},{"location":"reference.html#models.randmod.unpack_params","text":"Unpack parameters for the Random model. Parameters: params ( array ) \u2013 Parameter vector containing A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m. num_sites ( int ) \u2013 Number of phosphorylation sites. Returns: A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. S ( array ) \u2013 Phosphorylation rates for each site. Ddeg ( array ) \u2013 Degradation rates for phosphorylated states.","title":"unpack_params"},{"location":"reference.html#models.randmod.ode_system","text":"Compute the time derivatives of a random phosphorylation ODE system. This function supports a large number of phosphorylation states by using precomputed transition indices to optimize speed. Parameters: y ( array ) \u2013 Current state vector [R, P, X_1, ..., X_m]. t ( float ) \u2013 Time (unused; present for compatibility with ODE solvers). A ( float ) \u2013 mRNA production rate. B ( float ) \u2013 mRNA degradation rate. C ( float ) \u2013 protein production rate. D ( float ) \u2013 protein degradation rate. num_sites ( int ) \u2013 Number of phosphorylation sites. S ( array ) \u2013 Phosphorylation rates for each site. Ddeg ( array ) \u2013 Degradation rates for phosphorylated states. mono_idx ( array ) \u2013 Precomputed indices for mono-phosphorylated states. forward ( array ) \u2013 Forward phosphorylation target states. drop ( array ) \u2013 Dephosphorylation target states. fcounts ( array ) \u2013 Number of valid forward transitions for each state. dcounts ( array ) \u2013 Number of valid dephosphorylation transitions for each state. Returns: out ( array ) \u2013 Derivatives [dR, dP, dX_1, ..., dX_m].","title":"ode_system"},{"location":"reference.html#models.randmod.solve_ode","text":"Integrate the ODE system for phosphorylation dynamics in random phosphorylation model. Parameters: popt ( array ) \u2013 Optimized parameter vector [A, B, C, D, S_1.S_n, Ddeg_1.Ddeg_m]. y0 ( array ) \u2013 Initial condition vector [R0, P0, X1_0, ..., Xm_0]. num_sites ( int ) \u2013 Number of phosphorylation sites. t ( array ) \u2013 Time points to integrate over. Returns: sol ( ndarray ) \u2013 Full ODE solution of shape (len(t), len(y0)). mono ( ndarray ) \u2013 1D array of fitted values for R (after OFFSET) and P states.","title":"solve_ode"},{"location":"reference.html#models.succmod","text":"","title":"succmod"},{"location":"reference.html#models.succmod.ode_core","text":"The core of the ODE system for the successive ODE model. Parameters: y ( array ) \u2013 The current state of the system. t ( float ) \u2013 The current time. A ( float ) \u2013 The mRNA production rate. B ( float ) \u2013 The mRNA degradation rate. C ( float ) \u2013 The protein production rate. D ( float ) \u2013 The protein degradation rate. S_rates ( array ) \u2013 The phosphorylation rates for each site. D_rates ( array ) \u2013 The dephosphorylation rates for each site. Returns: dydt (np.array): The derivatives of the state variables.","title":"ode_core"},{"location":"reference.html#models.succmod.unpack_params","text":"Function to unpack the parameters for the ODE system. The parameters are expected to be in the following order: A, B, C, D, S_rates, D_rates where S_rates and D_rates are arrays of length num_psites. The function returns the unpacked parameters as separate variables. :param params: array of parameters :param num_psites: number of phosphorylation sites :return: A, B, C, D, S_rates, D_rates","title":"unpack_params"},{"location":"reference.html#models.succmod.solve_ode","text":"Solve the ODE system using the given parameters and initial conditions. The function integrates the ODE system over time and returns the solution. :param params: :param init_cond: :param num_psites: :param t: :return: solution, solution of phosphorylated sites","title":"solve_ode"},{"location":"reference.html#steady-state-calculation","text":"","title":"Steady-State Calculation"},{"location":"reference.html#steady.initdist","text":"","title":"initdist"},{"location":"reference.html#steady.initdist.initial_condition","text":"Calculates the initial steady-state conditions for a given number of phosphorylation sites for distributive phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions.","title":"initial_condition"},{"location":"reference.html#steady.initrand","text":"","title":"initrand"},{"location":"reference.html#steady.initrand.initial_condition","text":"Calculates the initial steady-state conditions for a given number of phosphorylation sites for random phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions.","title":"initial_condition"},{"location":"reference.html#steady.initsucc","text":"","title":"initsucc"},{"location":"reference.html#steady.initsucc.initial_condition","text":"Calculates the initial steady-state conditions for a given number of phosphorylation sites for successive phosphorylation model. Parameters: num_psites ( int ) \u2013 Number of phosphorylation sites in the model. Returns: list ( list ) \u2013 A list of steady-state values for the variables [R, P, P_sites]. Raises: ValueError \u2013 If the optimization fails to find a solution for the steady-state conditions.","title":"initial_condition"},{"location":"reference.html#plotting","text":"","title":"Plotting"},{"location":"reference.html#plotting.plotting","text":"","title":"plotting"},{"location":"reference.html#plotting.plotting.Plotter","text":"A class to encapsulate plotting functionalities for ODE model analysis. Attributes: gene ( str ) \u2013 The gene or experiment name. out_dir ( str ) \u2013 The directory where plots will be saved. color_palette ( list ) \u2013 List of color codes used for plotting.","title":"Plotter"},{"location":"reference.html#plotting.plotting.Plotter.plot_parallel","text":"Plots a parallel coordinates plot for the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. labels ( list ) \u2013 List of labels for the features in the solution.","title":"plot_parallel"},{"location":"reference.html#plotting.plotting.Plotter.pca_components","text":"Plots a scree plot showing the explained variance ratio for PCA components. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. target_variance ( float , default: 0.99 ) \u2013 The target variance to explain. Defaults to 0.99.","title":"pca_components"},{"location":"reference.html#plotting.plotting.Plotter.plot_pca","text":"Plots the PCA results for the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. components ( int , default: 3 ) \u2013 Number of PCA components to plot. Defaults to 3. Returns: tuple \u2013 PCA result and explained variance ratio.","title":"plot_pca"},{"location":"reference.html#plotting.plotting.Plotter.plot_tsne","text":"Plots a t-SNE visualization of the given solution. Parameters: solution ( ndarray ) \u2013 2D numpy array of shape (samples, features) representing the data. perplexity ( int , default: 30 ) \u2013 The perplexity parameter for t-SNE. Defaults to 30. Returns: \u2013 np.ndarray: The t-SNE result.","title":"plot_tsne"},{"location":"reference.html#plotting.plotting.Plotter.plot_param_series","text":"Plots the time series of estimated parameters over the given time points. Parameters: estimated_params ( list ) \u2013 List of estimated parameters. param_names ( list ) \u2013 List of parameter names. time_points ( ndarray ) \u2013 Array of time points.","title":"plot_param_series"},{"location":"reference.html#plotting.plotting.Plotter.plot_profiles","text":"Plots the profiles of estimated parameters over time. Parameters: data ( DataFrame ) \u2013 DataFrame containing the time series data.","title":"plot_profiles"},{"location":"reference.html#plotting.plotting.Plotter.plot_model_fit","text":"Plots the model fit for mRNA, protein, and phosphorylated species across time. Parameters: model_fit ( ndarray ) \u2013 Flattened model fit data (length = 9 + 14 + 14*num_psites). Pr_data ( ndarray ) \u2013 Protein data (14,). P_data ( ndarray ) \u2013 Phosphorylation data (num_psites + 2, 14). R_data ( ndarray ) \u2013 mRNA data (9,). sol ( ndarray ) \u2013 ODE solution array. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 Labels for phosphorylation sites. time_points ( ndarray ) \u2013 Time points (14,).","title":"plot_model_fit"},{"location":"reference.html#plotting.plotting.Plotter.plot_param_scatter","text":"Plots scatter and density plots for parameters. Parameters: est_arr ( ndarray ) \u2013 2D numpy array of estimated parameters. num_psites ( int ) \u2013 Number of phosphorylation sites. time_vals ( ndarray ) \u2013 Array of time values.","title":"plot_param_scatter"},{"location":"reference.html#plotting.plotting.Plotter.plot_heatmap","text":"Parameters: param_value_df ( DataFrame ) \u2013 DataFrame containing parameter values with 'Protein' as one of the columns.","title":"plot_heatmap"},{"location":"reference.html#plotting.plotting.Plotter.plot_error_distribution","text":"Parameters: error_df ( DataFrame ) \u2013 DataFrame containing errors with 'MAE' as one of the columns.","title":"plot_error_distribution"},{"location":"reference.html#plotting.plotting.Plotter.plot_gof","text":"Plot the goodness of fit for the model. Parameters: merged_data ( DataFrame ) \u2013 Dataframe containing merged data.","title":"plot_gof"},{"location":"reference.html#plotting.plotting.Plotter.plot_kld","text":"Plots the Kullback-Divergence for the model. Parameters: merged_data ( DataFrame ) \u2013 Dataframe containing merged data.","title":"plot_kld"},{"location":"reference.html#plotting.plotting.Plotter.plot_params_bar","text":"Plots bar plot for estimated parameter with 95% Confidence Interval. Parameters: ci_results ( dict ) \u2013 Dictionary containing the results of the confidence intervals. param_labels ( list , default: None ) \u2013 List of parameter labels. Defaults to None.","title":"plot_params_bar"},{"location":"reference.html#plotting.plotting.Plotter.plot_knockouts","text":"Plot wild-type and knockout simulation results for comparison. Parameters: results_dict ( dict ) \u2013 Dictionary containing simulation results. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 List of phosphorylation site labels.","title":"plot_knockouts"},{"location":"reference.html#plotting.plotting.Plotter.plot_top_param_pairs","text":"For each gene's '_perturbations' sheet in the Excel file, plot scatter plots for the parameter pairs with correlation. Parameters: excel_path ( str ) \u2013 Path to the Excel file.","title":"plot_top_param_pairs"},{"location":"reference.html#plotting.plotting.Plotter.plot_model_perturbations","text":"Plot the best model perturbations for the given data. Parameters: problem ( dict ) \u2013 The optimization problem. Si ( dict ) \u2013 The simulation index. cutoff_idx ( int ) \u2013 The cutoff index for the time points. time_points ( ndarray ) \u2013 The time points for the data. n_sites ( int ) \u2013 The number of phosphorylation sites. best_model_psite_solutions ( ndarray ) \u2013 The best model phosphorylation site solutions. best_mrna_solutions ( ndarray ) \u2013 The best model mRNA solutions. best_protein_solutions ( ndarray ) \u2013 The best model protein solutions. protein_ref \u2013 The reference data for the protein. psite_labels ( list [ str ] ) \u2013 The labels for the phosphorylation sites. psite_data_ref ( ndarray ) \u2013 The reference data for the phosphorylation sites. rna_ref ( ndarray ) \u2013 The reference data for mRNA.","title":"plot_model_perturbations"},{"location":"reference.html#plotting.plotting.Plotter.plot_time_state_grid","text":"Grid of strip plots per state showing variability across time. Parameters: samples ( ndarray ) \u2013 shape (n_samples, n_timepoints, n_states) time_points ( ndarray ) \u2013 array of time points state_names ( list ) \u2013 list of state names","title":"plot_time_state_grid"},{"location":"reference.html#plotting.plotting.Plotter.plot_phase_space","text":"Phase space plots: one state vs another for each simulation. Parameters: samples ( ndarray ) \u2013 Shape (n_samples, n_timepoints, n_states) state_names ( list ) \u2013 List of state names (length = num_states)","title":"plot_phase_space"},{"location":"reference.html#plotting.plotting.Plotter.plot_future_fit","text":"Plots the model fit for the future time points. Parameters: P_data ( ndarray ) \u2013 Data for phosphorylation sites. R_data ( ndarray ) \u2013 Data for mRNA. sol ( ndarray ) \u2013 Model solution. num_psites ( int ) \u2013 Number of phosphorylation sites. psite_labels ( list ) \u2013 Labels for phosphorylation sites. time_points ( ndarray ) \u2013 Time points for the data.","title":"plot_future_fit"},{"location":"reference.html#plotting.plotting.Plotter.plot_regularization","text":"Read every ' _params' sheet in the Excel file, pull the Regularization value, and plot a horizontal bar chart of regularization vs. gene. Parameters: excel_path ( str ) \u2013 Path to the Excel file.","title":"plot_regularization"},{"location":"reference.html#plotting.plotting.Plotter.plot_model_error","text":"Read every ' _params' sheet in the Excel file, pull the RMSE value, and plot a horizontal bar chart of RMSE vs. gene. Parameters: excel_path ( str ) \u2013 Path to the Excel file.","title":"plot_model_error"},{"location":"reference.html#utility-functions","text":"","title":"Utility Functions"},{"location":"reference.html#utils.display","text":"","title":"display"},{"location":"reference.html#utils.display.ensure_output_directory","text":"Ensure the output directory exists. If it doesn't, create it. Parameters: directory ( str ) \u2013 Path to the output directory.","title":"ensure_output_directory"},{"location":"reference.html#utils.display.load_data","text":"Load data from an Excel file. The default sheet is \"Estimated Values\". Parameters: excel_file ( str ) \u2013 Path to the Excel file. sheet ( str , default: 'Estimated Values' ) \u2013 Name of the sheet to load. Default is \"Estimated Values\". Returns: \u2013 pd.DataFrame: DataFrame containing the data from the specified sheet.","title":"load_data"},{"location":"reference.html#utils.display.format_duration","text":"Format a duration in seconds into a human-readable string. Parameters: seconds ( float ) \u2013 Duration in seconds. Returns: str: Formatted duration string.","title":"format_duration"},{"location":"reference.html#utils.display.merge_obs_est","text":"Function to merge observed and estimated data from an Excel file. Parameters: filename ( str ) \u2013 Path to the Excel file containing observed and estimated data. Returns: \u2013 pd.DataFrame: Merged DataFrame containing observed and estimated values for each gene and Psite.","title":"merge_obs_est"},{"location":"reference.html#utils.display.save_result","text":"Function to save results to an Excel file. Parameters: results ( list ) \u2013 List of dictionaries containing results for each gene. excel_filename ( str ) \u2013 Path to the output Excel file.","title":"save_result"},{"location":"reference.html#utils.display.create_report","text":"Creates a single global report HTML file from all gene folders inside the results directory. Parameters: results_dir ( str ) \u2013 Path to the root result's directory. output_file ( str , default: f'{ model_type }_report.html' ) \u2013 Name of the generated global report file (placed inside results_dir).","title":"create_report"},{"location":"reference.html#utils.display.organize_output_files","text":"Organize output files into protein-specific folders and a general folder. Parameters: directories ( Iterable [ Union [ str , Path ]] ) \u2013 List of directories to organize.","title":"organize_output_files"},{"location":"reference.html#utils.tables","text":"","title":"tables"},{"location":"reference.html#utils.tables.generate_tables","text":"Generate hierarchical tables from the XLSX file containing alpha and beta values. Parameters: xlsx_file_path ( str ) \u2013 Path to the XLSX file containing alpha and beta values. Returns: tuple \u2013 containing protein, psite, and the corresponding table.","title":"generate_tables"},{"location":"reference.html#utils.tables.save_tables","text":"Save the generated tables as LaTeX and CSV files. Parameters: tables ( list ) \u2013 List of tuples containing protein, psite, and the corresponding table. output_dir ( str ) \u2013 Directory to save the LaTeX and CSV files.","title":"save_tables"},{"location":"reference.html#utils.tables.save_master_table","text":"Save a master LaTeX file that includes all individual LaTeX files from the specified folder. Parameters: folder ( str , default: 'latex' ) \u2013 The folder containing the individual LaTeX files. output_file ( str , default: 'latex/all_tables.tex' ) \u2013 The name of the master LaTeX file to be created.","title":"save_master_table"},{"location":"reference.html#utils.latexit","text":"","title":"latexit"},{"location":"reference.html#utils.latexit.generate_latex_table","text":"Generate LaTeX code for a table from a DataFrame. Args: df (pd.DataFrame): DataFrame to convert to LaTeX. sheet_name (str): Name of the sheet for caption and label. Returns: str: LaTeX code for the table.","title":"generate_latex_table"},{"location":"reference.html#utils.latexit.generate_latex_image","text":"Generate LaTeX code for an image. Parameters: image_filename ( str ) \u2013 Path to the image file. Returns: str: LaTeX code for the image.","title":"generate_latex_image"},{"location":"reference.html#utils.latexit.main","text":"Main function to process Excel and PNG files in the input directory and generate LaTeX code. Parameters: input_dir ( str ) \u2013 Directory containing Excel and PNG files.","title":"main"},{"location":"Documentation/CHANGELOG.html","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [0.1.0] - 2025-04-19 Added Initial release of PhosKinTime , a Python toolkit for ODE-based modeling of phosphorylation kinetics and transcriptional time-series. Features include: Parameter estimation. Sensitivity analysis. Steady-state computation. Interactive visualization. Support for Python 3.10, 3.11, and 3.12. Dependencies include numpy , pandas , seaborn , matplotlib , scipy , and more. CLI entry point phoskintime via bin.main:main in root. Packaged directories: bin , config , kinopt , models , paramest , plotting , sensitivity , steady , tfopt , and utils . Documentation and homepage available at https://bibymaths.github.io/phoskintime/ . [0.2.0] - 2025-04-24 Added Added light grid in plotting of model. Added CHANGELOG.md . Added direct link to open file from CLI. Added CLI wrappers for entry point. Added deployment configuration file. Added support for network via Cytoscape. Added configuration file for PhosKinTime settings. Enhanced analysis and plotting functions: added upper bound parameter, updated loss type defaults, and improved legend formatting. Changed Updated parameter bounds and model settings in configuration files. Refactored logging statements and improved data filtering in main processing files. Fixed Fixed display of missing kinases in output before optimization in kinopt . Removed Removed clipping of predicted expression. Deleted abopt directory. [0.3.0] - 2025-04-24 Added Support for non-psite time series in kinase data. New results directory for structured output saving. Detailed docstrings and inline documentation for key functions. Changed Refactored powell.jl : cleaner function names, improved parameter handling, and threading support. Updated threading configuration and residuals calculation. Replaced print statements with logger output in Python modules. Adjusted beta bounds and default loss function settings. Improved ODE system equations, plotting aesthetics, and documentation structure. Fixed LaTeX formatting in README.md. Sheet name for estimated values in Excel export. Removed Obsolete abopt directory. Outdated module references and unused code. Removed julia implementation of kinopt Removed Project.toml for Julia dependency management. [0.4.0] - alpha Added - Phase space plots and strip plots for state distributions in sensitivity analysis. - Time-state grid visualization replacing old time-wise plots. - Enhanced logging format for parameter bounds and model configuration. - Increased number of trajectories to 10,000 for improved sensitivity resolution. - Support for parameter relationship plots and top parameter pair visualizations. Changed - Refactored sensitivity analysis functions and configuration parameters. - Updated site parameter labels and adjusted development mode flags. - Improved aesthetics of phase space and strip plots. - Adjusted ODE model references ( ODE_MODEL ) and refined output normalization logic. - Replaced hardcoded values with computed perturbations for sensitivity analysis. Fixed - Markdown formatting in README and PYPI_README. - Sheet name bug in Excel export for estimated values. Removed - Deprecated analysis modes and unused constants. - Combined time-weight calculation from data preprocessing. [0.4.0] \u2013 Unreleased Added Model error plotting in the visualization pipeline. Detailed descriptions for new Y_METRIC options in metric reports. Changed Streamlined argument parsing and enhanced logging details (now logs additional configuration parameters). Updated default ODE model constant from randmod to succmod for improved simulation accuracy. Disabled development mode by default; enhanced HTML\u2010report structure and log\u2010file handling. Refactored output\u2010directory parameter to a list format and reorganized output files with improved naming conventions across display and plotting modules. Updated upper bound ranges and default values for key parameters in config files. Adjusted figure sizing and label management in plotting functions; updated regex for parameter\u2010label matching to support multi\u2010digit labels. Improved plotting file naming and handling of perturbation values. Enhanced Excel sheet processing for parameter imports and added regularization checks during data import. Improved confidence\u2010interval logging format and enhanced regularization\u2010term computation in normest.py . Updated lambda\u2010range handling in normest.py . Fixed None yet. Removed None.","title":"Changelog"},{"location":"Documentation/CHANGELOG.html#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"Documentation/CHANGELOG.html#010-2025-04-19","text":"","title":"[0.1.0] - 2025-04-19"},{"location":"Documentation/CHANGELOG.html#added","text":"Initial release of PhosKinTime , a Python toolkit for ODE-based modeling of phosphorylation kinetics and transcriptional time-series. Features include: Parameter estimation. Sensitivity analysis. Steady-state computation. Interactive visualization. Support for Python 3.10, 3.11, and 3.12. Dependencies include numpy , pandas , seaborn , matplotlib , scipy , and more. CLI entry point phoskintime via bin.main:main in root. Packaged directories: bin , config , kinopt , models , paramest , plotting , sensitivity , steady , tfopt , and utils . Documentation and homepage available at https://bibymaths.github.io/phoskintime/ .","title":"Added"},{"location":"Documentation/CHANGELOG.html#020-2025-04-24","text":"","title":"[0.2.0] - 2025-04-24"},{"location":"Documentation/CHANGELOG.html#added_1","text":"Added light grid in plotting of model. Added CHANGELOG.md . Added direct link to open file from CLI. Added CLI wrappers for entry point. Added deployment configuration file. Added support for network via Cytoscape. Added configuration file for PhosKinTime settings. Enhanced analysis and plotting functions: added upper bound parameter, updated loss type defaults, and improved legend formatting.","title":"Added"},{"location":"Documentation/CHANGELOG.html#changed","text":"Updated parameter bounds and model settings in configuration files. Refactored logging statements and improved data filtering in main processing files.","title":"Changed"},{"location":"Documentation/CHANGELOG.html#fixed","text":"Fixed display of missing kinases in output before optimization in kinopt .","title":"Fixed"},{"location":"Documentation/CHANGELOG.html#removed","text":"Removed clipping of predicted expression. Deleted abopt directory.","title":"Removed"},{"location":"Documentation/CHANGELOG.html#030-2025-04-24","text":"","title":"[0.3.0] - 2025-04-24"},{"location":"Documentation/CHANGELOG.html#added_2","text":"Support for non-psite time series in kinase data. New results directory for structured output saving. Detailed docstrings and inline documentation for key functions.","title":"Added"},{"location":"Documentation/CHANGELOG.html#changed_1","text":"Refactored powell.jl : cleaner function names, improved parameter handling, and threading support. Updated threading configuration and residuals calculation. Replaced print statements with logger output in Python modules. Adjusted beta bounds and default loss function settings. Improved ODE system equations, plotting aesthetics, and documentation structure.","title":"Changed"},{"location":"Documentation/CHANGELOG.html#fixed_1","text":"LaTeX formatting in README.md. Sheet name for estimated values in Excel export.","title":"Fixed"},{"location":"Documentation/CHANGELOG.html#removed_1","text":"Obsolete abopt directory. Outdated module references and unused code. Removed julia implementation of kinopt Removed Project.toml for Julia dependency management.","title":"Removed"},{"location":"Documentation/CHANGELOG.html#040-alpha","text":"Added - Phase space plots and strip plots for state distributions in sensitivity analysis. - Time-state grid visualization replacing old time-wise plots. - Enhanced logging format for parameter bounds and model configuration. - Increased number of trajectories to 10,000 for improved sensitivity resolution. - Support for parameter relationship plots and top parameter pair visualizations. Changed - Refactored sensitivity analysis functions and configuration parameters. - Updated site parameter labels and adjusted development mode flags. - Improved aesthetics of phase space and strip plots. - Adjusted ODE model references ( ODE_MODEL ) and refined output normalization logic. - Replaced hardcoded values with computed perturbations for sensitivity analysis. Fixed - Markdown formatting in README and PYPI_README. - Sheet name bug in Excel export for estimated values. Removed - Deprecated analysis modes and unused constants. - Combined time-weight calculation from data preprocessing.","title":"[0.4.0] - alpha"},{"location":"Documentation/CHANGELOG.html#040-unreleased","text":"","title":"[0.4.0] \u2013 Unreleased"},{"location":"Documentation/CHANGELOG.html#added_3","text":"Model error plotting in the visualization pipeline. Detailed descriptions for new Y_METRIC options in metric reports.","title":"Added"},{"location":"Documentation/CHANGELOG.html#changed_2","text":"Streamlined argument parsing and enhanced logging details (now logs additional configuration parameters). Updated default ODE model constant from randmod to succmod for improved simulation accuracy. Disabled development mode by default; enhanced HTML\u2010report structure and log\u2010file handling. Refactored output\u2010directory parameter to a list format and reorganized output files with improved naming conventions across display and plotting modules. Updated upper bound ranges and default values for key parameters in config files. Adjusted figure sizing and label management in plotting functions; updated regex for parameter\u2010label matching to support multi\u2010digit labels. Improved plotting file naming and handling of perturbation values. Enhanced Excel sheet processing for parameter imports and added regularization checks during data import. Improved confidence\u2010interval logging format and enhanced regularization\u2010term computation in normest.py . Updated lambda\u2010range handling in normest.py .","title":"Changed"},{"location":"Documentation/CHANGELOG.html#fixed_2","text":"None yet.","title":"Fixed"},{"location":"Documentation/CHANGELOG.html#removed_2","text":"None.","title":"Removed"},{"location":"Documentation/config/index.html","text":"Config Module The config module centralizes all configuration, constant definitions, command-line argument parsing, and logging setup for the PhosKinTime package. This module is designed to standardize configuration settings across the package, making it easy to adjust model parameters, file paths, logging behavior, and other key settings. Overview The config module is composed of several submodules: constants.py This file defines global constants used throughout the package. It includes: Model Settings: ODE_MODEL : Selects the ODE model type (e.g., \"distmod\" for Distributive, \"succmod\" for Successive, \"randmod\" for Random). ESTIMATION_MODE : Chooses the parameter estimation strategy (\"sequential\" or \"normal\"). A mapping ( model_names ) that converts internal model identifiers to human-readable names (stored in model_type ). Time Points and Directories: TIME_POINTS : A NumPy array of time points for phosphorylation. TIME_POINTS_RNA : A NumPy array of time points for mRNA measurements. Directory paths such as PROJECT_ROOT , OUT_DIR , DATA_DIR , INPUT_EXCEL , and LOG_DIR . Plotting and Regularization Settings: COLOR_PALETTE : A list of colors for plotting. USE_REGULARIZATION : A boolean flag to enable or disable regularization. Scoring Weights: Weights for the composite scoring function ( ALPHA_WEIGHT , BETA_WEIGHT , GAMMA_WEIGHT , DELTA_WEIGHT , MU_REG ) that combine error metrics such as RMSE, MAE, variance, MSE, and the L2 norm of parameters. config.py This file handles command-line argument parsing and configuration extraction. It provides: The parse_args function to define and parse the necessary CLI arguments (such as parameter bounds, fixed parameter values, bootstrapping iterations, and input file paths). Utility functions like ensure_output_directory to create necessary directories. The extract_config function, which aggregates all command-line arguments and constants into a unified configuration dictionary used by the rest of the package. A composite scoring function ( score_fit ) that calculates a combined error score based on various error metrics and the L2 regularization penalty. logconf.py This file sets up the logging system for the package. Key features include: Colored Console Logging: A custom ColoredFormatter formats log messages with colors (e.g., blue for INFO, red for ERROR) to improve readability in the console. Rotating File Logging: Log messages are also saved to files in the directory specified by LOG_DIR , with rotation settings (maximum bytes and backup count) to prevent log files from becoming too large. Setup Function: The setup_logger function initializes and returns a logger configured with both file and stream (console) handlers. Global Configuration The constants defined in constants.py control major aspects of the modeling and estimation processes. For example, to switch between different kinetic models, update the ODE_MODEL value. Logging The logger configured in logconf.py is used to log progress, warnings, and errors. Both console and file logging are available. Log messages include time stamps, module names, log levels, and elapsed time, formatted with colors for easier debugging. Customization Model & Estimation Settings: Adjust ODE_MODEL in constants.py to select different modeling strategies and parameter estimation routines. Parameter Bounds and Fixed Values: These can be set via command-line arguments or within the configuration file. Custom parsers ensure values are correctly converted (e.g., converting \"inf\" to Python\u2019s infinity). Output Directories: Paths for data, results, and logs are automatically generated relative to PROJECT_ROOT . Modify these if necessary for your environment. Logging Behavior: The logging format and rotation settings can be adjusted in logconf.py to suit your needs. Scoring Function: The composite scoring function in config.py can be tuned by modifying the weights ( ALPHA_WEIGHT , BETA_WEIGHT , etc.) to reflect the priorities of your analysis.","title":"Configuration"},{"location":"Documentation/config/index.html#config-module","text":"The config module centralizes all configuration, constant definitions, command-line argument parsing, and logging setup for the PhosKinTime package. This module is designed to standardize configuration settings across the package, making it easy to adjust model parameters, file paths, logging behavior, and other key settings.","title":"Config Module"},{"location":"Documentation/config/index.html#overview","text":"The config module is composed of several submodules: constants.py This file defines global constants used throughout the package. It includes: Model Settings: ODE_MODEL : Selects the ODE model type (e.g., \"distmod\" for Distributive, \"succmod\" for Successive, \"randmod\" for Random). ESTIMATION_MODE : Chooses the parameter estimation strategy (\"sequential\" or \"normal\"). A mapping ( model_names ) that converts internal model identifiers to human-readable names (stored in model_type ). Time Points and Directories: TIME_POINTS : A NumPy array of time points for phosphorylation. TIME_POINTS_RNA : A NumPy array of time points for mRNA measurements. Directory paths such as PROJECT_ROOT , OUT_DIR , DATA_DIR , INPUT_EXCEL , and LOG_DIR . Plotting and Regularization Settings: COLOR_PALETTE : A list of colors for plotting. USE_REGULARIZATION : A boolean flag to enable or disable regularization. Scoring Weights: Weights for the composite scoring function ( ALPHA_WEIGHT , BETA_WEIGHT , GAMMA_WEIGHT , DELTA_WEIGHT , MU_REG ) that combine error metrics such as RMSE, MAE, variance, MSE, and the L2 norm of parameters. config.py This file handles command-line argument parsing and configuration extraction. It provides: The parse_args function to define and parse the necessary CLI arguments (such as parameter bounds, fixed parameter values, bootstrapping iterations, and input file paths). Utility functions like ensure_output_directory to create necessary directories. The extract_config function, which aggregates all command-line arguments and constants into a unified configuration dictionary used by the rest of the package. A composite scoring function ( score_fit ) that calculates a combined error score based on various error metrics and the L2 regularization penalty. logconf.py This file sets up the logging system for the package. Key features include: Colored Console Logging: A custom ColoredFormatter formats log messages with colors (e.g., blue for INFO, red for ERROR) to improve readability in the console. Rotating File Logging: Log messages are also saved to files in the directory specified by LOG_DIR , with rotation settings (maximum bytes and backup count) to prevent log files from becoming too large. Setup Function: The setup_logger function initializes and returns a logger configured with both file and stream (console) handlers.","title":"Overview"},{"location":"Documentation/config/index.html#global-configuration","text":"The constants defined in constants.py control major aspects of the modeling and estimation processes. For example, to switch between different kinetic models, update the ODE_MODEL value.","title":"Global Configuration"},{"location":"Documentation/config/index.html#logging","text":"The logger configured in logconf.py is used to log progress, warnings, and errors. Both console and file logging are available. Log messages include time stamps, module names, log levels, and elapsed time, formatted with colors for easier debugging.","title":"Logging"},{"location":"Documentation/config/index.html#customization","text":"Model & Estimation Settings: Adjust ODE_MODEL in constants.py to select different modeling strategies and parameter estimation routines. Parameter Bounds and Fixed Values: These can be set via command-line arguments or within the configuration file. Custom parsers ensure values are correctly converted (e.g., converting \"inf\" to Python\u2019s infinity). Output Directories: Paths for data, results, and logs are automatically generated relative to PROJECT_ROOT . Modify these if necessary for your environment. Logging Behavior: The logging format and rotation settings can be adjusted in logconf.py to suit your needs. Scoring Function: The composite scoring function in config.py can be tuned by modifying the weights ( ALPHA_WEIGHT , BETA_WEIGHT , etc.) to reflect the priorities of your analysis.","title":"Customization"},{"location":"Documentation/identifiability/index.html","text":"Parameter Identifiability This module provides a function to compute confidence intervals (CIs) and significance statistics for model parameters using linear approximation based on the covariance matrix from a nonlinear least squares fit, commonly known as also Wald Intervals . Purpose Given: Best-fit parameter estimates ( popt ) Their covariance matrix ( pcov ) The observed data ( target ) This function estimates: Standard errors t-statistics Two-sided p-values 95% confidence intervals (or another level via alpha_val ) Mathematical Background 1. Standard Error The standard error of each parameter is estimated as: $$ \\text{SE}(\\beta_i) = \\sqrt{ \\text{Var}(\\beta_i) } = \\sqrt{ \\text{diag}(\\text{pcov})_i } $$ Where pcov is the covariance matrix from the curve fitting routine (typically from scipy.optimize.curve_fit ). 2. Degrees of Freedom $$ \\text{df} = n_{\\text{obs}} - n_{\\text{params}} $$ Used to select the correct t-distribution for the confidence interval and p-value computation. 3. t-Statistic For each parameter: $$ t_i = \\frac{\\hat{\\beta}_i}{\\text{SE}(\\hat{\\beta}_i)} $$ 4. p-Value Two-sided p-value from the Student\u2019s t-distribution: $$ p_i = 2 \\cdot P(T > |t_i|) = 2 \\cdot \\text{sf}(|t_i|, \\text{df}) $$ 5. Confidence Interval Using the t-critical value $t^*$: $$ t^* = t_{1 - \\alpha/2, \\text{df}} $$ Confidence bounds: $$ \\text{CI}_i = \\left[ \\max\\left(0, \\hat{\\beta}_i - t^* \\cdot \\text{SE}(\\hat{\\beta}_i)\\right),\\ \\hat{\\beta}_i + t^* \\cdot \\text{SE}(\\hat{\\beta}_i) \\right] $$ Lower bound is clipped to zero for non-negative parameters. When to Use To assess parameter certainty To report statistical significance and error bars","title":"Confidence Intervals"},{"location":"Documentation/identifiability/index.html#parameter-identifiability","text":"This module provides a function to compute confidence intervals (CIs) and significance statistics for model parameters using linear approximation based on the covariance matrix from a nonlinear least squares fit, commonly known as also Wald Intervals .","title":"Parameter Identifiability"},{"location":"Documentation/identifiability/index.html#purpose","text":"Given: Best-fit parameter estimates ( popt ) Their covariance matrix ( pcov ) The observed data ( target ) This function estimates: Standard errors t-statistics Two-sided p-values 95% confidence intervals (or another level via alpha_val )","title":"Purpose"},{"location":"Documentation/identifiability/index.html#mathematical-background","text":"","title":"Mathematical Background"},{"location":"Documentation/identifiability/index.html#1-standard-error","text":"The standard error of each parameter is estimated as: $$ \\text{SE}(\\beta_i) = \\sqrt{ \\text{Var}(\\beta_i) } = \\sqrt{ \\text{diag}(\\text{pcov})_i } $$ Where pcov is the covariance matrix from the curve fitting routine (typically from scipy.optimize.curve_fit ).","title":"1. Standard Error"},{"location":"Documentation/identifiability/index.html#2-degrees-of-freedom","text":"$$ \\text{df} = n_{\\text{obs}} - n_{\\text{params}} $$ Used to select the correct t-distribution for the confidence interval and p-value computation.","title":"2. Degrees of Freedom"},{"location":"Documentation/identifiability/index.html#3-t-statistic","text":"For each parameter: $$ t_i = \\frac{\\hat{\\beta}_i}{\\text{SE}(\\hat{\\beta}_i)} $$","title":"3. t-Statistic"},{"location":"Documentation/identifiability/index.html#4-p-value","text":"Two-sided p-value from the Student\u2019s t-distribution: $$ p_i = 2 \\cdot P(T > |t_i|) = 2 \\cdot \\text{sf}(|t_i|, \\text{df}) $$","title":"4. p-Value"},{"location":"Documentation/identifiability/index.html#5-confidence-interval","text":"Using the t-critical value $t^*$: $$ t^* = t_{1 - \\alpha/2, \\text{df}} $$ Confidence bounds: $$ \\text{CI}_i = \\left[ \\max\\left(0, \\hat{\\beta}_i - t^* \\cdot \\text{SE}(\\hat{\\beta}_i)\\right),\\ \\hat{\\beta}_i + t^* \\cdot \\text{SE}(\\hat{\\beta}_i) \\right] $$ Lower bound is clipped to zero for non-negative parameters.","title":"5. Confidence Interval"},{"location":"Documentation/identifiability/index.html#when-to-use","text":"To assess parameter certainty To report statistical significance and error bars","title":"When to Use"},{"location":"Documentation/kinopt/index.html","text":"kinopt: A Comprehensive Optimization Framework for PhosKinTime kinopt is a modular framework designed for the analysis and optimization of gene\u2013phosphorylation time-series data. It integrates several specialized submodules that cater to different optimization strategies and post-processing analyses. Whether you need a global evolutionary approach, a local constrained optimization, or a Julia-based Powell optimization routine, kinopt offers the tools to process your experimental data and generate in-depth reports on model performance. Directory Structure kinopt/ \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 input1.csv # Primary input data file with phosphorylation time series data. \u2502 \u2514\u2500\u2500 input2.csv # Interaction data file containing protein-phosphorylation-kinase information. \u251c\u2500\u2500 evol \u2502 \u251c\u2500\u2500 config # Configuration files (constants, logging, etc.) for the evolutionary approach. \u2502 \u251c\u2500\u2500 exporter # Plotting and Excel sheet export functions. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for global optimization using evolutionary algorithms. \u2502 \u251c\u2500\u2500 objfn # Objective function implementations (single- and multi-objective). \u2502 \u251c\u2500\u2500 opt # Optimization routines (integration with pymoo). \u2502 \u251c\u2500\u2500 optcon # Functions to construct input data, constraints, and precomputed mappings. \u2502 \u251c\u2500\u2500 README.md # Detailed readme for the evol module. \u2502 \u2514\u2500\u2500 utils # Utility functions for data I/O and parameter extraction. \u251c\u2500\u2500 fitanalysis \u2502 \u251c\u2500\u2500 helpers # Auxiliary scripts for additional performance evaluation. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for fit analysis. \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 config # Configuration files specific to local optimization. \u2502 \u251c\u2500\u2500 exporter # Functions for exporting local optimization results and diagnostic plots. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for local optimization (SLSQP/TRUST-CONSTR based). \u2502 \u251c\u2500\u2500 objfn # Local objective function implementations with Numba acceleration. \u2502 \u251c\u2500\u2500 opt # Local optimization routines using SciPy. \u2502 \u251c\u2500\u2500 optcon # Construction of local constraints and precomputation of mappings. \u2502 \u251c\u2500\u2500 README.md # Detailed readme for the local module. \u2502 \u2514\u2500\u2500 utils # Utilities for data scaling, file organization, and report generation. \u251c\u2500\u2500 optimality \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 KKT.py # Post-optimization analysis: feasibility, sensitivity, and reporting. \u2502 \u2514\u2500\u2500 README.md # Detailed readme for the optimality module. \u251c\u2500\u2500 __init__.py Overview kinopt provides an end-to-end solution for: Data Preparation: Preprocess and scale input CSV files containing time-series data and kinase interactions. Global Optimization (evol): Uses evolutionary algorithms (via pymoo) to search the global parameter space for optimal \u03b1 (mixing) and \u03b2 (scaling) values. Local Optimization (local): Implements local constrained optimization using SciPy's solvers (SLSQP or TRUST-CONSTR) with efficient objective evaluation via Numba. Optimality Analysis (optimality): Post-processes optimization results to check constraint feasibility, perform sensitivity analysis, generate LaTeX summary tables, and produce diagnostic plots. Fit Analysis (fitanalysis): Provides additional tools to evaluate the fit and performance of the optimized model. Model Equation $$ P_i(t) = \\sum_{j} Q_{i,j} \\, \\alpha_{i,j} \\left( \\sum_{k} \\beta_{k,j} \\cdot P^k_j(t) \\right) $$ Subject to: $$ 0 \\leq \\alpha_{i,j} \\leq 1, \\quad \\sum_{j} \\alpha_{i,j} = 1 $$ $$ -2 \\leq \\beta_{k,j} \\leq 2, \\quad \\sum_{k} \\beta_{k,j} = 1 $$ Where: $P_i(t)$: predicted phosphorylation level of protein $i$ at time $t$ $Q_{i,j}$: binary indicator (1 if kinase $j$ targets protein $i$, 0 otherwise) $\\alpha_{i,j}$: effect of kinase $j$ on protein $i$ (non-negative, normalized per protein) $\\beta_{k,j}$: effect of phosphorylation site $k$ on kinase $j$ (can be positive or negative, normalized per kinase) $P^k_j(t)$: observed phosphorylation level of site $k$ on kinase $j$ at time $t$ Features Modular Architecture: Each submodule (evol, local, optimality, fitanalysis) is designed to operate independently while integrating seamlessly into the overall workflow. Flexible Optimization Strategies: Choose between global evolutionary algorithms, local constrained solvers depending on your specific needs. Robust Post-Processing: Comprehensive post-optimization analysis includes constraint validation, sensitivity analysis, detailed reporting ( both in LaTeX and Excel), and extensive plotting of diagnostic metrics. Automated Reporting: After running optimization routines, the framework organizes outputs into structured directories and generates a global HTML report summarizing key results and diagnostic plots. User-Friendly Logging: Custom logging configurations provide real-time feedback during execution, ensuring transparency in the optimization process. Usage Go to the one top level up in the terminal from root and run: Running Global Optimization (evol) python -m phoskintime kinopt --mode evol Running Local Optimization (local) python -m phoskintime kinopt --mode local Post-Optimization Processing After any optimization run, the optimality module is invoked (either directly or as part of the workflow) to analyze the results, validate constraints, and generate comprehensive reports. This README provides an overview of the kinopt framework, outlining its structure, features, and usage instructions. For detailed documentation on each submodule, please refer to the individual README.md files within the respective directories.","title":"Kinase Optimization"},{"location":"Documentation/kinopt/index.html#kinopt-a-comprehensive-optimization-framework-for-phoskintime","text":"kinopt is a modular framework designed for the analysis and optimization of gene\u2013phosphorylation time-series data. It integrates several specialized submodules that cater to different optimization strategies and post-processing analyses. Whether you need a global evolutionary approach, a local constrained optimization, or a Julia-based Powell optimization routine, kinopt offers the tools to process your experimental data and generate in-depth reports on model performance.","title":"kinopt: A Comprehensive Optimization Framework for PhosKinTime"},{"location":"Documentation/kinopt/index.html#directory-structure","text":"kinopt/ \u251c\u2500\u2500 data \u2502 \u251c\u2500\u2500 input1.csv # Primary input data file with phosphorylation time series data. \u2502 \u2514\u2500\u2500 input2.csv # Interaction data file containing protein-phosphorylation-kinase information. \u251c\u2500\u2500 evol \u2502 \u251c\u2500\u2500 config # Configuration files (constants, logging, etc.) for the evolutionary approach. \u2502 \u251c\u2500\u2500 exporter # Plotting and Excel sheet export functions. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for global optimization using evolutionary algorithms. \u2502 \u251c\u2500\u2500 objfn # Objective function implementations (single- and multi-objective). \u2502 \u251c\u2500\u2500 opt # Optimization routines (integration with pymoo). \u2502 \u251c\u2500\u2500 optcon # Functions to construct input data, constraints, and precomputed mappings. \u2502 \u251c\u2500\u2500 README.md # Detailed readme for the evol module. \u2502 \u2514\u2500\u2500 utils # Utility functions for data I/O and parameter extraction. \u251c\u2500\u2500 fitanalysis \u2502 \u251c\u2500\u2500 helpers # Auxiliary scripts for additional performance evaluation. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for fit analysis. \u251c\u2500\u2500 local \u2502 \u251c\u2500\u2500 config # Configuration files specific to local optimization. \u2502 \u251c\u2500\u2500 exporter # Functions for exporting local optimization results and diagnostic plots. \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 __main__.py # Entry point for local optimization (SLSQP/TRUST-CONSTR based). \u2502 \u251c\u2500\u2500 objfn # Local objective function implementations with Numba acceleration. \u2502 \u251c\u2500\u2500 opt # Local optimization routines using SciPy. \u2502 \u251c\u2500\u2500 optcon # Construction of local constraints and precomputation of mappings. \u2502 \u251c\u2500\u2500 README.md # Detailed readme for the local module. \u2502 \u2514\u2500\u2500 utils # Utilities for data scaling, file organization, and report generation. \u251c\u2500\u2500 optimality \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 KKT.py # Post-optimization analysis: feasibility, sensitivity, and reporting. \u2502 \u2514\u2500\u2500 README.md # Detailed readme for the optimality module. \u251c\u2500\u2500 __init__.py","title":"Directory Structure"},{"location":"Documentation/kinopt/index.html#overview","text":"kinopt provides an end-to-end solution for: Data Preparation: Preprocess and scale input CSV files containing time-series data and kinase interactions. Global Optimization (evol): Uses evolutionary algorithms (via pymoo) to search the global parameter space for optimal \u03b1 (mixing) and \u03b2 (scaling) values. Local Optimization (local): Implements local constrained optimization using SciPy's solvers (SLSQP or TRUST-CONSTR) with efficient objective evaluation via Numba. Optimality Analysis (optimality): Post-processes optimization results to check constraint feasibility, perform sensitivity analysis, generate LaTeX summary tables, and produce diagnostic plots. Fit Analysis (fitanalysis): Provides additional tools to evaluate the fit and performance of the optimized model.","title":"Overview"},{"location":"Documentation/kinopt/index.html#model-equation","text":"$$ P_i(t) = \\sum_{j} Q_{i,j} \\, \\alpha_{i,j} \\left( \\sum_{k} \\beta_{k,j} \\cdot P^k_j(t) \\right) $$ Subject to: $$ 0 \\leq \\alpha_{i,j} \\leq 1, \\quad \\sum_{j} \\alpha_{i,j} = 1 $$ $$ -2 \\leq \\beta_{k,j} \\leq 2, \\quad \\sum_{k} \\beta_{k,j} = 1 $$ Where: $P_i(t)$: predicted phosphorylation level of protein $i$ at time $t$ $Q_{i,j}$: binary indicator (1 if kinase $j$ targets protein $i$, 0 otherwise) $\\alpha_{i,j}$: effect of kinase $j$ on protein $i$ (non-negative, normalized per protein) $\\beta_{k,j}$: effect of phosphorylation site $k$ on kinase $j$ (can be positive or negative, normalized per kinase) $P^k_j(t)$: observed phosphorylation level of site $k$ on kinase $j$ at time $t$","title":"Model Equation"},{"location":"Documentation/kinopt/index.html#features","text":"Modular Architecture: Each submodule (evol, local, optimality, fitanalysis) is designed to operate independently while integrating seamlessly into the overall workflow. Flexible Optimization Strategies: Choose between global evolutionary algorithms, local constrained solvers depending on your specific needs. Robust Post-Processing: Comprehensive post-optimization analysis includes constraint validation, sensitivity analysis, detailed reporting ( both in LaTeX and Excel), and extensive plotting of diagnostic metrics. Automated Reporting: After running optimization routines, the framework organizes outputs into structured directories and generates a global HTML report summarizing key results and diagnostic plots. User-Friendly Logging: Custom logging configurations provide real-time feedback during execution, ensuring transparency in the optimization process.","title":"Features"},{"location":"Documentation/kinopt/index.html#usage","text":"Go to the one top level up in the terminal from root and run:","title":"Usage"},{"location":"Documentation/kinopt/index.html#running-global-optimization-evol","text":"python -m phoskintime kinopt --mode evol","title":"Running Global Optimization (evol)"},{"location":"Documentation/kinopt/index.html#running-local-optimization-local","text":"python -m phoskintime kinopt --mode local","title":"Running Local Optimization (local)"},{"location":"Documentation/kinopt/index.html#post-optimization-processing","text":"After any optimization run, the optimality module is invoked (either directly or as part of the workflow) to analyze the results, validate constraints, and generate comprehensive reports. This README provides an overview of the kinopt framework, outlining its structure, features, and usage instructions. For detailed documentation on each submodule, please refer to the individual README.md files within the respective directories.","title":"Post-Optimization Processing"},{"location":"Documentation/knockout/index.html","text":"Knockout The knockout module provides utilities for simulating in silico knockouts of biological processes and generating all possible knockout combinations. It is designed to work with parameter vectors representing biological systems. Features Apply Knockouts: Modify parameter vectors to simulate knockouts for transcription, translation, or phosphorylation processes. Generate Knockout Combinations: Create all possible combinations of knockouts, including individual phosphorylation site knockouts. Functions apply_knockout Simulates knockouts by modifying a given parameter vector. Parameters: base_params ( np.ndarray ): Original parameter vector. knockout_targets ( dict ): Specifies processes to knock out ( transcription , translation , phosphorylation ). num_psites ( int ): Number of phosphorylation sites. Returns: A modified parameter vector with the specified knockouts applied. generate_knockout_combinations Generates all possible combinations of knockouts for transcription, translation, and phosphorylation. Parameters: num_psites ( int ): Number of phosphorylation sites. Returns: A list of dictionaries, each representing a unique knockout combination.","title":"Knockout Analysis"},{"location":"Documentation/knockout/index.html#knockout","text":"The knockout module provides utilities for simulating in silico knockouts of biological processes and generating all possible knockout combinations. It is designed to work with parameter vectors representing biological systems.","title":"Knockout"},{"location":"Documentation/knockout/index.html#features","text":"Apply Knockouts: Modify parameter vectors to simulate knockouts for transcription, translation, or phosphorylation processes. Generate Knockout Combinations: Create all possible combinations of knockouts, including individual phosphorylation site knockouts.","title":"Features"},{"location":"Documentation/knockout/index.html#functions","text":"","title":"Functions"},{"location":"Documentation/knockout/index.html#apply_knockout","text":"Simulates knockouts by modifying a given parameter vector. Parameters: base_params ( np.ndarray ): Original parameter vector. knockout_targets ( dict ): Specifies processes to knock out ( transcription , translation , phosphorylation ). num_psites ( int ): Number of phosphorylation sites. Returns: A modified parameter vector with the specified knockouts applied.","title":"apply_knockout"},{"location":"Documentation/knockout/index.html#generate_knockout_combinations","text":"Generates all possible combinations of knockouts for transcription, translation, and phosphorylation. Parameters: num_psites ( int ): Number of phosphorylation sites. Returns: A list of dictionaries, each representing a unique knockout combination.","title":"generate_knockout_combinations"},{"location":"Documentation/models/index.html","text":"Models The models module provides the implementation of various ODE-based kinetic models used in the PhosKinTime package for phosphorylation dynamics. It is designed to support multiple model types, each corresponding to a different mechanistic hypothesis about how phosphorylation occurs. 1. Distributive Model $R$: mRNA concentration $P$: protein concentration $P_i$: phosphorylated site $i$ $A, B, C, D$: rate constants $S_i$: phosphorylation rate for site $i$ $D_i$: dephosphorylation rate for site $i$ Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - (D + \\sum_i S_i) P + \\sum_i P_i $ $ \\frac{dP_i}{dt} = S_i P - (1 + D_i) P_i \\quad \\forall i $ 2. Successive Model $R, P, P_i$ as above Phosphorylation proceeds in sequence Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - D P - S_0 P + P_0 $ Phosphorylation sites: First site ($i = 0$): $ \\frac{dP_0}{dt} = S_0 P - (1 + S_1 + D_0) P_0 + P_1 $ Intermediate sites ($0 < i < n-1$): $ \\frac{dP_i}{dt} = S_i P_{i-1} - (1 + S_{i+1} + D_i) P_i + P_{i+1} $ Last site ($i = n - 1$): $ \\frac{dP_{n-1}}{dt} = S_{n-1} P_{n-2} - (1 + D_{n-1}) P_{n-1} $ 3. Random Model $X_j$: phosphorylated state $j$, total $2^n - 1$ states $S_i$: phosphorylation rates for each site $D_j$: degradation rate for state $j$ Binary transitions determine phosphorylation and dephosphorylation Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - D P - (\\sum_i S_i) P + \\sum_{j \\in \\text{1-site}} X_j + \\sum_{j \\in \\text{dephospho exit}} S_i X_j $ Each state $X_j$: $ \\frac{dX_j}{dt} = \\sum_{\\text{phospho from}} S_i X_{src} - (\\sum_i S_i + D_j) X_j + \\sum_{\\text{dephospho to}} S_i X_{src} $ Weights Without Regularization Let: $x_i$: the data point at time $i$ $t_i$: the time point index ($i = 1, 2, \\dots$) $T$: total number of time points $w_i$: weight at time $i$ Uncertanities from data : They are interpreted as the standard deviations of the data points. The formula for the weighted least squares fit becomes: $$ \\chi^2 = \\sum_{i=1}^N \\left( \\frac{y_i - f(x_i, \\theta)}{\\sigma_i} \\right)^2 $$ where $y_i$ is the observed data point, $f(x_i, \\theta)$ is the model function with parameters $\\theta$, and $\\sigma_i$ is the standard deviation (weights) for the $i^{th}$ data point. The absolute_sigma=True argument ensures that the covariance matrix of the parameter estimates is scaled by the provided $\\sigma_i$ values, rather than being rescaled by the reduced chi-squared value. This means the uncertainties in the data (as given by the weights) are treated as absolute. When the estimations are not ideal, the weights can be adjusted to improve the fit. The absoulute_sigma = False for curve_fit will rescale the covariance matrix by the reduced chi-squared value, which can be useful when the uncertainties in the data are not well characterized. The following are some common weighting schemes: Inverse Data : $w_i = \\frac{1}{|x_i| + \\epsilon}$ Exponential Decay : $w_i = \\exp(-0.5 \\cdot x_i)$ Log Scale : $w_i = \\frac{1}{\\log(1 + |x_i|)}$ Time Difference : $w_i = \\frac{1}{|x_i - x_{i-1}| + \\epsilon}$ Moving Average Deviation : $w_i = \\frac{1}{|x_i - \\text{MA}_i| + \\epsilon}$ where $\\text{MA}_i$ is a moving average (e.g., over 3 points) Sigmoid Time Decay : $w_i = \\frac{1}{1 + \\exp(t_i - 5)}$ Exponential Early Emphasis : $w_i = \\exp(-0.5 \\cdot t_i)$ Polynomial Decay : $w_i = \\frac{1}{1 + 0.5 \\cdot t_i}$ MS SNR Model (Signal-Noise Ratio) : $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$ MS Inverse Variance Model : $w_i = \\frac{1}{|x_i|^{0.7} + \\epsilon}$ Flat Region Penalty : $w_i = \\frac{1}{|\\nabla x_i| + \\epsilon}$ Steady State Decay : $w_i = \\exp(-0.1 \\cdot t_i)$ Inverse Sqrt Data : $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$ Early Emphasis (moderate or steep decay) : $w_i = 1$ (or pre-defined stepwise decay vector) Custom Early Emphasis : Based on: $w_i = \\frac{1}{(|x_i| + \\epsilon)(\\Delta t_i + \\epsilon)}$ for early $t_i$, else $w_i = 1$ With Regularization Let $w_i$ be any of the above weights and $R$ be the number of regularization parameters: Extended Weight Vector : $w = [w_1, w_2, \\dots, w_T, 1, 1, \\dots, 1]$ where the last $R$ entries are 1 (flat regularization penalty weights) This simply appends a vector of ones of length equal to the number of regularization parameters to each weight vector. Tikhonov Regularization in ODE Parameter Estimation This project applies Tikhonov regularization (\u03bb = 1e-3) to stabilize parameter estimates and improve identifiability in ODE-based model fitting. Computes unregularized estimates and their covariance matrix . Applies Tikhonov regularization post hoc: Regularized estimates : $$ \\theta_{\\text{reg}} = \\theta_{\\text{fit}} - \\lambda C \\Gamma \\theta_{\\text{fit}} $$ Regularized covariance : $$ C_{\\text{reg}} = \\left(C^{-1} + \\lambda \\Gamma \\right)^{-1} $$ Typically, \u0393 is the identity matrix. Interpretation Estimates are shrunk toward zero (or prior). Uncertainty (covariance) is reduced, reflecting added prior information. Regularization improves numerical stability and reduces overfitting . Post-Regularization Checks Compare \u03b8_fit vs \u03b8_reg and C vs C_reg . Assess model fit with regularized parameters. Examine parameter correlations and identifiability. Optionally test sensitivity to different \u03bb values. Note This approach assumes the likelihood is locally quadratic\u2014valid for most ODE-based models near optimum. Overview This module includes implementations of the following model types: Random Model ( randmod.py ): Implements a vectorized and optimized ODE system using Numba. This model represents a random mechanism of phosphorylation, where transitions between phosphorylation states are computed based on binary representations. The module prepares vectorized arrays (e.g., binary states, phosphorylation/dephosphorylation targets) and defines the ODE system accordingly. Distributive Model ( distmod.py ): Implements a distributive phosphorylation mechanism. In this model, a kinase adds phosphate groups in a manner where each phosphorylation event is independent, and the ODE system is defined with explicit state variables for the phosphorylated forms. Successive Model ( succmod.py ): Implements a successive phosphorylation mechanism, where phosphorylation occurs in a sequential, stepwise manner. This model's ODE system is tailored to capture the sequential nature of the modification. Weighting Functions ( weights.py ): Provides functions to compute various weighting schemes (e.g., early emphasis, inverse data, exponential decay) used during parameter estimation. These weights help tailor the fitting process to the dynamics of the observed data. Automatic Model Selection The package\u2019s __init__.py file in the models module automatically imports the correct model module based on the configuration constant ODE_MODEL . The selected module\u2019s solve_ode function is then exposed as the default ODE solver for the package. This enables seamless switching between different mechanistic models without changing the rest of the code. Units in the ODE Model These ODE models supports two interpretations depending on whether quantities are scaled: 1. Dimensionless Model (Scaled) All parameters and variables are unitless . Time and concentrations are rescaled to reference values (e.g., max input, steady state). Useful for qualitative dynamics, numerical stability, or fitting fold-change data. Interpretation: A, B, C, D, S_rates[i], D_rates[i] \u2192 unitless y (state vector: R, P, P_sites) \u2192 unitless 2. Dimensional (Mass-Action Style) Variables represent concentration (e.g., \u03bcM), and time is in seconds. Parameters follow biochemical units: A \u2192 concentration/time (e.g., \u03bcM/s) B, C, D, S_rates[i], D_rates[i] \u2192 1/time (e.g., 1/s) R, P, y[2+i] \u2192 concentration (e.g., \u03bcM) Caveat: Dimensional consistency requires adjustment (e.g., replacing hardcoded 1.0 with a rate constant and scaling summed terms accordingly). Here\u2019s a concise and clear README section tailored for your PhosKinTime tool, explaining the normalization logic for fold change data: Fold Change Normalization in PhosKinTime PhosKinTime supports modeling and parameter estimation of phosphorylation dynamics using time series data. Often, such experimental data is provided not in absolute concentration units but as fold change (FC) relative to a baseline (usually time point 0). To ensure accurate and biologically meaningful comparison between model output and experimental data, PhosKinTime includes built-in support to normalize model output to fold change form. Why Normalize? Experimental FC data is typically defined as: $$ \\text{FC}(t) = \\frac{X(t)}{X(t_0)} $$ where $X(t)$ is the measured signal (e.g., intensity or concentration) at time $t$, and $X(t_0)$ is the baseline (often the 0 min time point). It reflects relative change , not absolute concentration. However, PhosKinTime's ODE models simulate absolute concentrations over time: $$ Y(t) = \\text{ODE solution} $$ Directly comparing $Y(t)$ to FC data is invalid , as it compares mismatched scales and units. To bridge this gap, PhosKinTime transforms the model output into comparable fold change form by: $$ \\text{FC}_{\\text{model}}(t) = \\frac{Y(t)}{Y(t_0) + \\epsilon} $$ ($\\epsilon$ is a small constant to avoid division by zero.) This transformation is applied per phosphorylation site (or species) independently, ensuring robust and interpretable parameter fitting. References Klipp, E., et al. (2016). Systems Biology: A Textbook (2nd ed.). Wiley-VCH. Raue, A., et al. (2013). Lessons learned from quantitative dynamical modeling in systems biology. PLoS ONE , 8(9), e74335. BioModels Documentation: https://www.ebi.ac.uk/biomodels/docs/","title":"Models"},{"location":"Documentation/models/index.html#models","text":"The models module provides the implementation of various ODE-based kinetic models used in the PhosKinTime package for phosphorylation dynamics. It is designed to support multiple model types, each corresponding to a different mechanistic hypothesis about how phosphorylation occurs.","title":"Models"},{"location":"Documentation/models/index.html#1-distributive-model","text":"$R$: mRNA concentration $P$: protein concentration $P_i$: phosphorylated site $i$ $A, B, C, D$: rate constants $S_i$: phosphorylation rate for site $i$ $D_i$: dephosphorylation rate for site $i$ Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - (D + \\sum_i S_i) P + \\sum_i P_i $ $ \\frac{dP_i}{dt} = S_i P - (1 + D_i) P_i \\quad \\forall i $","title":"1. Distributive Model"},{"location":"Documentation/models/index.html#2-successive-model","text":"$R, P, P_i$ as above Phosphorylation proceeds in sequence Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - D P - S_0 P + P_0 $ Phosphorylation sites: First site ($i = 0$): $ \\frac{dP_0}{dt} = S_0 P - (1 + S_1 + D_0) P_0 + P_1 $ Intermediate sites ($0 < i < n-1$): $ \\frac{dP_i}{dt} = S_i P_{i-1} - (1 + S_{i+1} + D_i) P_i + P_{i+1} $ Last site ($i = n - 1$): $ \\frac{dP_{n-1}}{dt} = S_{n-1} P_{n-2} - (1 + D_{n-1}) P_{n-1} $","title":"2. Successive Model"},{"location":"Documentation/models/index.html#3-random-model","text":"$X_j$: phosphorylated state $j$, total $2^n - 1$ states $S_i$: phosphorylation rates for each site $D_j$: degradation rate for state $j$ Binary transitions determine phosphorylation and dephosphorylation Equations: $ \\frac{dR}{dt} = A - B R $ $ \\frac{dP}{dt} = C R - D P - (\\sum_i S_i) P + \\sum_{j \\in \\text{1-site}} X_j + \\sum_{j \\in \\text{dephospho exit}} S_i X_j $ Each state $X_j$: $ \\frac{dX_j}{dt} = \\sum_{\\text{phospho from}} S_i X_{src} - (\\sum_i S_i + D_j) X_j + \\sum_{\\text{dephospho to}} S_i X_{src} $","title":"3. Random Model"},{"location":"Documentation/models/index.html#weights","text":"","title":"Weights"},{"location":"Documentation/models/index.html#without-regularization","text":"Let: $x_i$: the data point at time $i$ $t_i$: the time point index ($i = 1, 2, \\dots$) $T$: total number of time points $w_i$: weight at time $i$ Uncertanities from data : They are interpreted as the standard deviations of the data points. The formula for the weighted least squares fit becomes: $$ \\chi^2 = \\sum_{i=1}^N \\left( \\frac{y_i - f(x_i, \\theta)}{\\sigma_i} \\right)^2 $$ where $y_i$ is the observed data point, $f(x_i, \\theta)$ is the model function with parameters $\\theta$, and $\\sigma_i$ is the standard deviation (weights) for the $i^{th}$ data point. The absolute_sigma=True argument ensures that the covariance matrix of the parameter estimates is scaled by the provided $\\sigma_i$ values, rather than being rescaled by the reduced chi-squared value. This means the uncertainties in the data (as given by the weights) are treated as absolute. When the estimations are not ideal, the weights can be adjusted to improve the fit. The absoulute_sigma = False for curve_fit will rescale the covariance matrix by the reduced chi-squared value, which can be useful when the uncertainties in the data are not well characterized. The following are some common weighting schemes: Inverse Data : $w_i = \\frac{1}{|x_i| + \\epsilon}$ Exponential Decay : $w_i = \\exp(-0.5 \\cdot x_i)$ Log Scale : $w_i = \\frac{1}{\\log(1 + |x_i|)}$ Time Difference : $w_i = \\frac{1}{|x_i - x_{i-1}| + \\epsilon}$ Moving Average Deviation : $w_i = \\frac{1}{|x_i - \\text{MA}_i| + \\epsilon}$ where $\\text{MA}_i$ is a moving average (e.g., over 3 points) Sigmoid Time Decay : $w_i = \\frac{1}{1 + \\exp(t_i - 5)}$ Exponential Early Emphasis : $w_i = \\exp(-0.5 \\cdot t_i)$ Polynomial Decay : $w_i = \\frac{1}{1 + 0.5 \\cdot t_i}$ MS SNR Model (Signal-Noise Ratio) : $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$ MS Inverse Variance Model : $w_i = \\frac{1}{|x_i|^{0.7} + \\epsilon}$ Flat Region Penalty : $w_i = \\frac{1}{|\\nabla x_i| + \\epsilon}$ Steady State Decay : $w_i = \\exp(-0.1 \\cdot t_i)$ Inverse Sqrt Data : $w_i = \\frac{1}{\\sqrt{|x_i| + \\epsilon}}$ Early Emphasis (moderate or steep decay) : $w_i = 1$ (or pre-defined stepwise decay vector) Custom Early Emphasis : Based on: $w_i = \\frac{1}{(|x_i| + \\epsilon)(\\Delta t_i + \\epsilon)}$ for early $t_i$, else $w_i = 1$","title":"Without Regularization"},{"location":"Documentation/models/index.html#with-regularization","text":"Let $w_i$ be any of the above weights and $R$ be the number of regularization parameters: Extended Weight Vector : $w = [w_1, w_2, \\dots, w_T, 1, 1, \\dots, 1]$ where the last $R$ entries are 1 (flat regularization penalty weights) This simply appends a vector of ones of length equal to the number of regularization parameters to each weight vector.","title":"With Regularization"},{"location":"Documentation/models/index.html#tikhonov-regularization-in-ode-parameter-estimation","text":"This project applies Tikhonov regularization (\u03bb = 1e-3) to stabilize parameter estimates and improve identifiability in ODE-based model fitting. Computes unregularized estimates and their covariance matrix . Applies Tikhonov regularization post hoc: Regularized estimates : $$ \\theta_{\\text{reg}} = \\theta_{\\text{fit}} - \\lambda C \\Gamma \\theta_{\\text{fit}} $$ Regularized covariance : $$ C_{\\text{reg}} = \\left(C^{-1} + \\lambda \\Gamma \\right)^{-1} $$ Typically, \u0393 is the identity matrix.","title":"Tikhonov Regularization in ODE Parameter Estimation"},{"location":"Documentation/models/index.html#interpretation","text":"Estimates are shrunk toward zero (or prior). Uncertainty (covariance) is reduced, reflecting added prior information. Regularization improves numerical stability and reduces overfitting .","title":"Interpretation"},{"location":"Documentation/models/index.html#post-regularization-checks","text":"Compare \u03b8_fit vs \u03b8_reg and C vs C_reg . Assess model fit with regularized parameters. Examine parameter correlations and identifiability. Optionally test sensitivity to different \u03bb values.","title":"Post-Regularization Checks"},{"location":"Documentation/models/index.html#note","text":"This approach assumes the likelihood is locally quadratic\u2014valid for most ODE-based models near optimum.","title":"Note"},{"location":"Documentation/models/index.html#overview","text":"This module includes implementations of the following model types: Random Model ( randmod.py ): Implements a vectorized and optimized ODE system using Numba. This model represents a random mechanism of phosphorylation, where transitions between phosphorylation states are computed based on binary representations. The module prepares vectorized arrays (e.g., binary states, phosphorylation/dephosphorylation targets) and defines the ODE system accordingly. Distributive Model ( distmod.py ): Implements a distributive phosphorylation mechanism. In this model, a kinase adds phosphate groups in a manner where each phosphorylation event is independent, and the ODE system is defined with explicit state variables for the phosphorylated forms. Successive Model ( succmod.py ): Implements a successive phosphorylation mechanism, where phosphorylation occurs in a sequential, stepwise manner. This model's ODE system is tailored to capture the sequential nature of the modification. Weighting Functions ( weights.py ): Provides functions to compute various weighting schemes (e.g., early emphasis, inverse data, exponential decay) used during parameter estimation. These weights help tailor the fitting process to the dynamics of the observed data.","title":"Overview"},{"location":"Documentation/models/index.html#automatic-model-selection","text":"The package\u2019s __init__.py file in the models module automatically imports the correct model module based on the configuration constant ODE_MODEL . The selected module\u2019s solve_ode function is then exposed as the default ODE solver for the package. This enables seamless switching between different mechanistic models without changing the rest of the code.","title":"Automatic Model Selection"},{"location":"Documentation/models/index.html#units-in-the-ode-model","text":"These ODE models supports two interpretations depending on whether quantities are scaled:","title":"Units in the ODE Model"},{"location":"Documentation/models/index.html#1-dimensionless-model-scaled","text":"All parameters and variables are unitless . Time and concentrations are rescaled to reference values (e.g., max input, steady state). Useful for qualitative dynamics, numerical stability, or fitting fold-change data. Interpretation: A, B, C, D, S_rates[i], D_rates[i] \u2192 unitless y (state vector: R, P, P_sites) \u2192 unitless","title":"1. Dimensionless Model (Scaled)"},{"location":"Documentation/models/index.html#2-dimensional-mass-action-style","text":"Variables represent concentration (e.g., \u03bcM), and time is in seconds. Parameters follow biochemical units: A \u2192 concentration/time (e.g., \u03bcM/s) B, C, D, S_rates[i], D_rates[i] \u2192 1/time (e.g., 1/s) R, P, y[2+i] \u2192 concentration (e.g., \u03bcM) Caveat: Dimensional consistency requires adjustment (e.g., replacing hardcoded 1.0 with a rate constant and scaling summed terms accordingly). Here\u2019s a concise and clear README section tailored for your PhosKinTime tool, explaining the normalization logic for fold change data:","title":"2. Dimensional (Mass-Action Style)"},{"location":"Documentation/models/index.html#fold-change-normalization-in-phoskintime","text":"PhosKinTime supports modeling and parameter estimation of phosphorylation dynamics using time series data. Often, such experimental data is provided not in absolute concentration units but as fold change (FC) relative to a baseline (usually time point 0). To ensure accurate and biologically meaningful comparison between model output and experimental data, PhosKinTime includes built-in support to normalize model output to fold change form.","title":"Fold Change Normalization in PhosKinTime"},{"location":"Documentation/models/index.html#why-normalize","text":"Experimental FC data is typically defined as: $$ \\text{FC}(t) = \\frac{X(t)}{X(t_0)} $$ where $X(t)$ is the measured signal (e.g., intensity or concentration) at time $t$, and $X(t_0)$ is the baseline (often the 0 min time point). It reflects relative change , not absolute concentration. However, PhosKinTime's ODE models simulate absolute concentrations over time: $$ Y(t) = \\text{ODE solution} $$ Directly comparing $Y(t)$ to FC data is invalid , as it compares mismatched scales and units. To bridge this gap, PhosKinTime transforms the model output into comparable fold change form by: $$ \\text{FC}_{\\text{model}}(t) = \\frac{Y(t)}{Y(t_0) + \\epsilon} $$ ($\\epsilon$ is a small constant to avoid division by zero.) This transformation is applied per phosphorylation site (or species) independently, ensuring robust and interpretable parameter fitting.","title":"Why Normalize?"},{"location":"Documentation/models/index.html#references","text":"Klipp, E., et al. (2016). Systems Biology: A Textbook (2nd ed.). Wiley-VCH. Raue, A., et al. (2013). Lessons learned from quantitative dynamical modeling in systems biology. PLoS ONE , 8(9), e74335. BioModels Documentation: https://www.ebi.ac.uk/biomodels/docs/","title":"References"},{"location":"Documentation/paramest/index.html","text":"Parameter Estimation This module provides the tools needed to estimate parameters for ODE\u2010based models of phosphorylation dynamics. Overview The module is organized into several submodules: normest.py \u2013 Implements normal parameter estimation. This approach fits the entire time-series data in one step. toggle.py \u2013 Offers a single function ( estimate_parameters ) to pipe normal estimation based on a mode flag. core.py \u2013 Integrates the estimation methods, handling data extraction, calling the appropriate estimation (via the toggle), ODE solution, error calculation, and plotting. Features Bootstrapping: Bootstrapping can be enabled to assess the variability of the parameter estimates. Flexible Model Configuration: The module supports different ODE model types (e.g., Distributive, Successive, Random) through configuration constants. For example, when using the \"randmod\" (Random model), the parameter bounds are log-transformed and the optimizer works in log-space (with conversion back to the original scale). Integration with Plotting: After estimation, the module calls plotting functions (via the Plotter class) to visualize the ODE solution, parameter profiles, and goodness-of-fit metrics.","title":"Parameter Estimation"},{"location":"Documentation/paramest/index.html#parameter-estimation","text":"This module provides the tools needed to estimate parameters for ODE\u2010based models of phosphorylation dynamics.","title":"Parameter Estimation"},{"location":"Documentation/paramest/index.html#overview","text":"The module is organized into several submodules: normest.py \u2013 Implements normal parameter estimation. This approach fits the entire time-series data in one step. toggle.py \u2013 Offers a single function ( estimate_parameters ) to pipe normal estimation based on a mode flag. core.py \u2013 Integrates the estimation methods, handling data extraction, calling the appropriate estimation (via the toggle), ODE solution, error calculation, and plotting.","title":"Overview"},{"location":"Documentation/paramest/index.html#features","text":"Bootstrapping: Bootstrapping can be enabled to assess the variability of the parameter estimates. Flexible Model Configuration: The module supports different ODE model types (e.g., Distributive, Successive, Random) through configuration constants. For example, when using the \"randmod\" (Random model), the parameter bounds are log-transformed and the optimizer works in log-space (with conversion back to the original scale). Integration with Plotting: After estimation, the module calls plotting functions (via the Plotter class) to visualize the ODE solution, parameter profiles, and goodness-of-fit metrics.","title":"Features"},{"location":"Documentation/plotting/index.html","text":"Plotting This module provides a comprehensive set of tools for visualizing data and results from ODE-based models of phosphorylation dynamics. It supports various types of plots to analyze model behavior, parameter estimates, and goodness-of-fit metrics. Features Time-Series Visualization : Generate plots for time-dependent data, including mRNA, protein, and phosphorylation levels. Dimensionality Reduction : Visualize data using PCA, t-SNE, and parallel coordinates to explore patterns and relationships. Parameter Analysis : Create scatter plots, bar charts, and density plots to evaluate parameter estimates, confidence intervals, and sensitivity. Model Fit Evaluation : Compare observed and fitted data using goodness-of-fit plots, error distributions, and Kullback-Leibler divergence. Sensitivity Analysis : Visualize parameter importance and interactions using bar plots, scatter plots, radial plots, and pie charts. State and Phase Space Exploration : Analyze state variability over time and phase space relationships between states. Regularization and Error Metrics : Summarize regularization values and model errors across genes or experiments. Output All plots are saved as high-resolution images in the specified output directory. Interactive visualizations (e.g., Plotly) are also supported for model fit only.","title":"Plotting"},{"location":"Documentation/plotting/index.html#plotting","text":"This module provides a comprehensive set of tools for visualizing data and results from ODE-based models of phosphorylation dynamics. It supports various types of plots to analyze model behavior, parameter estimates, and goodness-of-fit metrics.","title":"Plotting"},{"location":"Documentation/plotting/index.html#features","text":"Time-Series Visualization : Generate plots for time-dependent data, including mRNA, protein, and phosphorylation levels. Dimensionality Reduction : Visualize data using PCA, t-SNE, and parallel coordinates to explore patterns and relationships. Parameter Analysis : Create scatter plots, bar charts, and density plots to evaluate parameter estimates, confidence intervals, and sensitivity. Model Fit Evaluation : Compare observed and fitted data using goodness-of-fit plots, error distributions, and Kullback-Leibler divergence. Sensitivity Analysis : Visualize parameter importance and interactions using bar plots, scatter plots, radial plots, and pie charts. State and Phase Space Exploration : Analyze state variability over time and phase space relationships between states. Regularization and Error Metrics : Summarize regularization values and model errors across genes or experiments.","title":"Features"},{"location":"Documentation/plotting/index.html#output","text":"All plots are saved as high-resolution images in the specified output directory. Interactive visualizations (e.g., Plotly) are also supported for model fit only.","title":"Output"},{"location":"Documentation/processing/index.html","text":"PhosKinTime Data Preprocessing & Mapping This workflow prepares and maps time-series data for kinase and transcription factor optimization models from raw proteomics and transcriptomics datasets. Structure phoskintime/ \u251c\u2500\u2500 processing/ \u2502 \u251c\u2500\u2500 cleanup.py # Data cleaning and preparation \u2502 \u2514\u2500\u2500 map.py # Optimization result mapping and network table generation \u251c\u2500\u2500 raw/ # Input CSVs (CollecTRI, MS Gaussian, Rout Limma) \u251c\u2500\u2500 kinopt/data/ # Kinase model inputs \u251c\u2500\u2500 tfopt/data/ # TF model inputs \u2514\u2500\u2500 data/ # Network export for Cytoscape Scripts Overview cleanup.py Performs the following steps: TF-mRNA Interaction Cleanup Filters complex interactions in CollecTRI Keeps only TFs matching phospho-interactions in input2.csv Proteomics Data Transformation Transforms MS Gaussian predictions with 2^mean Formats phosphorylation sites, saves to input1.csv Error Propagation Computes std propagation: \u03c3_y = 2^x * ln(2) * \u03c3_x Saves to input1_wstd.csv Transcriptomics Cleanup Transforms Rout Limma values with 2^x Saves to input3.csv Gene Symbol Mapping Replaces Ensembl/Entrez IDs with gene symbols (using MyGeneInfo) File Management Moves cleaned files to kinopt/data/ and tfopt/data/ map.py This script processes optimization results for transcription factors (TFs) and kinases, mapping their interactions with mRNA and phosphorylation sites. It generates Cytoscape-compatible edge and node tables for network visualization. Key Features: TF-mRNA Mapping : Extracts non-zero optimization results and groups mRNA by associated TFs and their strengths. Kinase-Phosphorylation Mapping : Maps kinases to mRNA and phosphorylation sites based on optimization results. Cytoscape Table Generation : Creates edge and node tables for network visualization, including interaction types and strengths. Kinetic Strength Integration : Adds kinetic strength columns to mapping files for further analysis. Inputs Place the following raw data in processing/raw/ : CollecTRI.csv MS_Gaussian_updated_09032023.csv Rout_LimmaTable.csv input2.csv (phospho interactions) Outputs File Description input1.csv Phospho time series (KinOpt, TFOpt) input1_wstd.csv Same as above + standard deviation input2.csv Phospho kinase-interaction metadata input3.csv mRNA time series (TFOpt) input4.csv Clean TF-mRNA interactions mapping.csv Mapped TF \u2192 mRNA with Kinase + Psite mapping_.csv Cytoscape-compatible edge list nodes.csv Cytoscape node roles Notes Complex TF interactions (e.g. COMPLEX:TF1/TF2 ) are excluded. Kinase-only proteins not appearing in CollecTRI (e.g. PAK2 ) are excluded from TF mapping. Unmappable GeneIDs are printed at runtime.","title":"Processing & Mapping"},{"location":"Documentation/processing/index.html#phoskintime-data-preprocessing-mapping","text":"This workflow prepares and maps time-series data for kinase and transcription factor optimization models from raw proteomics and transcriptomics datasets.","title":"PhosKinTime Data Preprocessing &amp; Mapping"},{"location":"Documentation/processing/index.html#structure","text":"phoskintime/ \u251c\u2500\u2500 processing/ \u2502 \u251c\u2500\u2500 cleanup.py # Data cleaning and preparation \u2502 \u2514\u2500\u2500 map.py # Optimization result mapping and network table generation \u251c\u2500\u2500 raw/ # Input CSVs (CollecTRI, MS Gaussian, Rout Limma) \u251c\u2500\u2500 kinopt/data/ # Kinase model inputs \u251c\u2500\u2500 tfopt/data/ # TF model inputs \u2514\u2500\u2500 data/ # Network export for Cytoscape","title":"Structure"},{"location":"Documentation/processing/index.html#scripts-overview","text":"","title":"Scripts Overview"},{"location":"Documentation/processing/index.html#cleanuppy","text":"Performs the following steps: TF-mRNA Interaction Cleanup Filters complex interactions in CollecTRI Keeps only TFs matching phospho-interactions in input2.csv Proteomics Data Transformation Transforms MS Gaussian predictions with 2^mean Formats phosphorylation sites, saves to input1.csv Error Propagation Computes std propagation: \u03c3_y = 2^x * ln(2) * \u03c3_x Saves to input1_wstd.csv Transcriptomics Cleanup Transforms Rout Limma values with 2^x Saves to input3.csv Gene Symbol Mapping Replaces Ensembl/Entrez IDs with gene symbols (using MyGeneInfo) File Management Moves cleaned files to kinopt/data/ and tfopt/data/","title":"cleanup.py"},{"location":"Documentation/processing/index.html#mappy","text":"This script processes optimization results for transcription factors (TFs) and kinases, mapping their interactions with mRNA and phosphorylation sites. It generates Cytoscape-compatible edge and node tables for network visualization.","title":"map.py"},{"location":"Documentation/processing/index.html#key-features","text":"TF-mRNA Mapping : Extracts non-zero optimization results and groups mRNA by associated TFs and their strengths. Kinase-Phosphorylation Mapping : Maps kinases to mRNA and phosphorylation sites based on optimization results. Cytoscape Table Generation : Creates edge and node tables for network visualization, including interaction types and strengths. Kinetic Strength Integration : Adds kinetic strength columns to mapping files for further analysis.","title":"Key Features:"},{"location":"Documentation/processing/index.html#inputs","text":"Place the following raw data in processing/raw/ : CollecTRI.csv MS_Gaussian_updated_09032023.csv Rout_LimmaTable.csv input2.csv (phospho interactions)","title":"Inputs"},{"location":"Documentation/processing/index.html#outputs","text":"File Description input1.csv Phospho time series (KinOpt, TFOpt) input1_wstd.csv Same as above + standard deviation input2.csv Phospho kinase-interaction metadata input3.csv mRNA time series (TFOpt) input4.csv Clean TF-mRNA interactions mapping.csv Mapped TF \u2192 mRNA with Kinase + Psite mapping_.csv Cytoscape-compatible edge list nodes.csv Cytoscape node roles","title":"Outputs"},{"location":"Documentation/processing/index.html#notes","text":"Complex TF interactions (e.g. COMPLEX:TF1/TF2 ) are excluded. Kinase-only proteins not appearing in CollecTRI (e.g. PAK2 ) are excluded from TF mapping. Unmappable GeneIDs are printed at runtime.","title":"Notes"},{"location":"Documentation/sensitivity/index.html","text":"Sensitivity Analysis The Sensitivity module provides functionality for performing sensitivity analysis on the ODE-based phosphorylation models in the PhosKinTime package. Using the Morris method from SALib, this module evaluates the influence of each model parameter on the output of the system, thereby helping to identify the most critical parameters and potential nonlinear interactions. Overview This module (primarily implemented in analysis.py ) defines functions that: Define the Sensitivity Problem: Two functions ( define_sensitivity_problem_rand and define_sensitivity_problem_ds ) generate the problem definition (number of variables, parameter names, and bounds) required for the Morris sensitivity analysis. The choice depends on whether the model is a random model ( randmod ) or a distributive/successive model. Run Sensitivity Analysis: The sensitivity_analysis function: Generates parameter samples using the Morris method. Simulates the ODE system (via the package's solve_ode function) for each parameter set. Computes a response metric (e.g., the sum of the phosphorylated states at the final time point). Analyzes the sensitivity indices using SALib's analyze function. Generates a suite of plots (bar plots, scatter, radial, CDF, and pie charts) to visually summarize the sensitivity of each parameter.","title":"Sensitivity Analysis"},{"location":"Documentation/sensitivity/index.html#sensitivity-analysis","text":"The Sensitivity module provides functionality for performing sensitivity analysis on the ODE-based phosphorylation models in the PhosKinTime package. Using the Morris method from SALib, this module evaluates the influence of each model parameter on the output of the system, thereby helping to identify the most critical parameters and potential nonlinear interactions.","title":"Sensitivity Analysis"},{"location":"Documentation/sensitivity/index.html#overview","text":"This module (primarily implemented in analysis.py ) defines functions that: Define the Sensitivity Problem: Two functions ( define_sensitivity_problem_rand and define_sensitivity_problem_ds ) generate the problem definition (number of variables, parameter names, and bounds) required for the Morris sensitivity analysis. The choice depends on whether the model is a random model ( randmod ) or a distributive/successive model. Run Sensitivity Analysis: The sensitivity_analysis function: Generates parameter samples using the Morris method. Simulates the ODE system (via the package's solve_ode function) for each parameter set. Computes a response metric (e.g., the sum of the phosphorylated states at the final time point). Analyzes the sensitivity indices using SALib's analyze function. Generates a suite of plots (bar plots, scatter, radial, CDF, and pie charts) to visually summarize the sensitivity of each parameter.","title":"Overview"},{"location":"Documentation/steady/index.html","text":"Steady-State Initializers for Phosphorylation Models These scripts compute biologically meaningful steady-state initial values for different phosphorylation models, which are required as starting points for ODE simulations . Instead of guessing or using arbitrary initial values, we solve a nonlinear system of equations that ensures: All time derivatives are zero at $t = 0$ \u2192 i.e., the system is at equilibrium What Is Being Computed? For each model, we're solving: $$ \\text{Find } y_0 \\text{ such that } \\frac{dy}{dt}\\bigg|_{t=0} = 0 $$ where $\\mathbf{y} = [R, P, \\dots]$ are all species in the system. This is done using constrained numerical optimization ( scipy.optimize.minimize ) to solve a system of equations $f(\\mathbf{y}) = 0$. Model-Specific Logic 1. Distributive Model Each site $i$ is phosphorylated independently Steady-state means: mRNA synthesis balances degradation Protein synthesis balances degradation and phosphorylation Each phosphorylated state $P_i$ is in flux balance You solve a nonlinear system: $$ A - B R = 0 $$ $$ C R - (D + \\sum S_i) P + \\sum P_i = 0 $$ $$ S_i P - (1 + D_i) P_i = 0 \\quad \\forall i $$ 2. Successive Model Sites are phosphorylated in a fixed order: $P \\to P_0 \\to P_1 \\to \\dots \\to P_n$ Steady-state requires: mRNA and protein production/degradation balance Each intermediate state receives and passes flux without accumulation You solve: $$ A - B \\cdot R = 0 $$ $$ C \\cdot R - S_0 \\cdot P + D_0 \\cdot P_0 = 0 $$ $$ S_0 \\cdot P - (S_1 + D_0) \\cdot P_0 + D_1 \\cdot P_1 = 0 $$ $$ S_1 \\cdot P_0 - (S_2 + D_1) \\cdot P_1 + D_2 \\cdot P_2 = 0 $$ $$ \\vdots $$ $$ S_{n-1} \\cdot P_{n-2} - (S_n + D_{n-1}) \\cdot P_{n-1} + D_n \\cdot P_n = 0 $$ $$ S_n \\cdot P_{n-1} - D_n \\cdot P_n = 0 $$ Where: $R$: mRNA concentration $P$: unphosphorylated protein $P_i$: protein with $i$ sites phosphorylated in sequence $S_i$: phosphorylation rate from $P_{i-1} \\to P_i$ $D_i$: degradation rate of $P_i$ 3. Random Model All possible phosphorylated combinations are treated as distinct states Total number of states = $2^n - 1$ (excluding unphosphorylated state) You construct a system: One equation for $R$ and $P$ One for each state $X_j$ (each subset of phosphorylated sites) For each state, compute net phosphorylation in/out, and degradation At steady state, each phosphorylated state $X_j$ satisfies: $$ \\frac{dX_j}{dt} = \\sum_{k \\in N_j^{\\text{in}}} S_{k \\to j} \\cdot X_k \\sum_{l \\in N_j^{\\text{out}}} S_{j \\to l} \\cdot X_j D_j \\cdot X_j = 0 $$ Where: $X_j$: concentration of phosphorylation state $j$ $N_j^{\\text{in}}$: set of states $k$ that transition into $X_j$ $N_j^{\\text{out}}$: set of states $l$ that $X_j$ can transition into $S_{a \\rightarrow b}$: rate constant for transition from state $a$ to $b$ (e.g., phosphorylation/dephosphorylation) $D_j$: degradation rate of state $X_j$ (depends on its phosphorylation pattern) Output Each function returns steady-state concentrations: $[R, P, P_1, ..., P_n]$ (for distributive and successive ) $[R, P, X_1, ..., X_k]$ (for random , where $X_k$ are the subset states)","title":"Steady State Calculation"},{"location":"Documentation/steady/index.html#steady-state-initializers-for-phosphorylation-models","text":"These scripts compute biologically meaningful steady-state initial values for different phosphorylation models, which are required as starting points for ODE simulations . Instead of guessing or using arbitrary initial values, we solve a nonlinear system of equations that ensures: All time derivatives are zero at $t = 0$ \u2192 i.e., the system is at equilibrium","title":"Steady-State Initializers for Phosphorylation Models"},{"location":"Documentation/steady/index.html#what-is-being-computed","text":"For each model, we're solving: $$ \\text{Find } y_0 \\text{ such that } \\frac{dy}{dt}\\bigg|_{t=0} = 0 $$ where $\\mathbf{y} = [R, P, \\dots]$ are all species in the system. This is done using constrained numerical optimization ( scipy.optimize.minimize ) to solve a system of equations $f(\\mathbf{y}) = 0$.","title":"What Is Being Computed?"},{"location":"Documentation/steady/index.html#model-specific-logic","text":"","title":"Model-Specific Logic"},{"location":"Documentation/steady/index.html#1-distributive-model","text":"Each site $i$ is phosphorylated independently Steady-state means: mRNA synthesis balances degradation Protein synthesis balances degradation and phosphorylation Each phosphorylated state $P_i$ is in flux balance You solve a nonlinear system: $$ A - B R = 0 $$ $$ C R - (D + \\sum S_i) P + \\sum P_i = 0 $$ $$ S_i P - (1 + D_i) P_i = 0 \\quad \\forall i $$","title":"1. Distributive Model"},{"location":"Documentation/steady/index.html#2-successive-model","text":"Sites are phosphorylated in a fixed order: $P \\to P_0 \\to P_1 \\to \\dots \\to P_n$ Steady-state requires: mRNA and protein production/degradation balance Each intermediate state receives and passes flux without accumulation You solve: $$ A - B \\cdot R = 0 $$ $$ C \\cdot R - S_0 \\cdot P + D_0 \\cdot P_0 = 0 $$ $$ S_0 \\cdot P - (S_1 + D_0) \\cdot P_0 + D_1 \\cdot P_1 = 0 $$ $$ S_1 \\cdot P_0 - (S_2 + D_1) \\cdot P_1 + D_2 \\cdot P_2 = 0 $$ $$ \\vdots $$ $$ S_{n-1} \\cdot P_{n-2} - (S_n + D_{n-1}) \\cdot P_{n-1} + D_n \\cdot P_n = 0 $$ $$ S_n \\cdot P_{n-1} - D_n \\cdot P_n = 0 $$ Where: $R$: mRNA concentration $P$: unphosphorylated protein $P_i$: protein with $i$ sites phosphorylated in sequence $S_i$: phosphorylation rate from $P_{i-1} \\to P_i$ $D_i$: degradation rate of $P_i$","title":"2. Successive Model"},{"location":"Documentation/steady/index.html#3-random-model","text":"All possible phosphorylated combinations are treated as distinct states Total number of states = $2^n - 1$ (excluding unphosphorylated state) You construct a system: One equation for $R$ and $P$ One for each state $X_j$ (each subset of phosphorylated sites) For each state, compute net phosphorylation in/out, and degradation At steady state, each phosphorylated state $X_j$ satisfies: $$ \\frac{dX_j}{dt} = \\sum_{k \\in N_j^{\\text{in}}} S_{k \\to j} \\cdot X_k \\sum_{l \\in N_j^{\\text{out}}} S_{j \\to l} \\cdot X_j D_j \\cdot X_j = 0 $$ Where: $X_j$: concentration of phosphorylation state $j$ $N_j^{\\text{in}}$: set of states $k$ that transition into $X_j$ $N_j^{\\text{out}}$: set of states $l$ that $X_j$ can transition into $S_{a \\rightarrow b}$: rate constant for transition from state $a$ to $b$ (e.g., phosphorylation/dephosphorylation) $D_j$: degradation rate of state $X_j$ (depends on its phosphorylation pattern)","title":"3. Random Model"},{"location":"Documentation/steady/index.html#output","text":"Each function returns steady-state concentrations: $[R, P, P_1, ..., P_n]$ (for distributive and successive ) $[R, P, X_1, ..., X_k]$ (for random , where $X_k$ are the subset states)","title":"Output"},{"location":"Documentation/tfopt/index.html","text":"tfopt \u2014 Transcription Factor Optimization Framework Originally implemented by Julius Normann. This version has been modified and optimized for consistency & speed in submodules by Abhinav Mishra. tfopt provides a flexible architecture for estimating transcriptional regulatory influence using mRNA time series data, TF protein dynamics, and phosphorylation site signals. The package contains two main submodules: tfopt/evol \u2014 global optimization via multi-objective evolutionary algorithms tfopt/local \u2014 constrained optimization using SciPy solvers (e.g., SLSQP) Both modules share a consistent data preparation pipeline and model formulation. Model Equation For each mRNA (indexed by i ), the measured time series is represented by: $$ \\mathbf{R}_i = \\left([mRNA]_i(t_1), [mRNA]_i(t_2), \\dots, [mRNA]_i(T)\\right) $$ Its predicted value is modeled as a weighted combination of the effects of transcription factors (TFs) that regulate it. Each TF (indexed by j ) contributes in two ways: A protein component (when no phosphorylation site is reported) with time series ( TF_{i,j}(t) ) A PSite component (when phosphorylation sites are available) with time series ( PSite_{k,j}(t) ) for each site k These contributions are modulated by two sets of parameters: \u03b1-values : For each mRNA, the impact of TF j is weighted by ( \\alpha_{i,j} ) \u03b2-values : For each TF, a vector of weights: $$ \\beta_j = \\left( \\beta_{0,j}, \\beta_{1,j}, \\dots, \\beta_{K_j,j} \\right) $$ Here, $ \\beta_{0,j} $ multiplies the raw TF protein signal, and the remaining terms multiply phosphorylation site contributions. Objective Function To estimate the best set of weights, we minimize the difference between measured and predicted expression over all genes and time points: $$ \\min_{{\\alpha,\\beta}} \\quad \\sum_i \\sum_t \\left( R_i(t) - \\hat{R}_i(t) \\right)^2 $$ This formulation supports multiple loss types (MSE, MAE, soft L1, Cauchy, etc.) implemented in both submodules. Constraints \u03b1-constraints (for each mRNA i ): $$ \\sum_{j \\in J_i} \\alpha_{i,j} = 1, \\quad 0 \\le \\alpha_{i,j} \\le 1 $$ \u03b2-constraints (for each TF j ): $$ \\sum_{q=0}^{K_j} \\beta_{q,j} = 1, \\quad -2 \\le \\beta_{q,j} \\le 2 $$ This ensures that weights are interpretable and stable. Optimization Problem Summary The final optimization problem is: $$ \\min_{{\\alpha,\\beta}} \\sum_i \\sum_t \\left( R_i(t) - \\sum_{j\\in J_i} \\alpha_{i,j} \\cdot TF_{i,j}(t) \\cdot \\left( \\beta_{0,j} + \\sum_k PSite_{k,j}(t) \\cdot \\beta_{k,j} \\right) \\right)^2 $$ subject to the constraints above. This enables estimation of regulatory influences in a biologically meaningful and data-driven manner. Submodules evol/ \u2014 Global Evolutionary Optimization Implements multi-objective optimization using pymoo (NSGA2, AGEMOEA, SMSEMOA) Evaluates tradeoffs between fit error, \u03b1-constraint violation, and \u03b2-constraint violation Outputs Excel summaries, static and interactive plots, and HTML reports local/ \u2014 Constrained Local Optimization Implements deterministic solvers (e.g. SLSQP) Faster and more interpretable for small- to medium-scale systems Shares the same objective and constraint framework as evol Generates the same reports and plots as the global module Usage From one level top of project root: python -m phoskintime tfopt --mode evol or python -m phoskintime tfopt --mode local Output will be saved in structured folders, including Excel files, plots, and an aggregated HTML report.","title":"Transcription Factor Optimization"},{"location":"Documentation/tfopt/index.html#tfopt-transcription-factor-optimization-framework","text":"Originally implemented by Julius Normann. This version has been modified and optimized for consistency & speed in submodules by Abhinav Mishra. tfopt provides a flexible architecture for estimating transcriptional regulatory influence using mRNA time series data, TF protein dynamics, and phosphorylation site signals. The package contains two main submodules: tfopt/evol \u2014 global optimization via multi-objective evolutionary algorithms tfopt/local \u2014 constrained optimization using SciPy solvers (e.g., SLSQP) Both modules share a consistent data preparation pipeline and model formulation.","title":"tfopt \u2014 Transcription Factor Optimization Framework"},{"location":"Documentation/tfopt/index.html#model-equation","text":"For each mRNA (indexed by i ), the measured time series is represented by: $$ \\mathbf{R}_i = \\left([mRNA]_i(t_1), [mRNA]_i(t_2), \\dots, [mRNA]_i(T)\\right) $$ Its predicted value is modeled as a weighted combination of the effects of transcription factors (TFs) that regulate it. Each TF (indexed by j ) contributes in two ways: A protein component (when no phosphorylation site is reported) with time series ( TF_{i,j}(t) ) A PSite component (when phosphorylation sites are available) with time series ( PSite_{k,j}(t) ) for each site k These contributions are modulated by two sets of parameters: \u03b1-values : For each mRNA, the impact of TF j is weighted by ( \\alpha_{i,j} ) \u03b2-values : For each TF, a vector of weights: $$ \\beta_j = \\left( \\beta_{0,j}, \\beta_{1,j}, \\dots, \\beta_{K_j,j} \\right) $$ Here, $ \\beta_{0,j} $ multiplies the raw TF protein signal, and the remaining terms multiply phosphorylation site contributions.","title":"Model Equation"},{"location":"Documentation/tfopt/index.html#objective-function","text":"To estimate the best set of weights, we minimize the difference between measured and predicted expression over all genes and time points: $$ \\min_{{\\alpha,\\beta}} \\quad \\sum_i \\sum_t \\left( R_i(t) - \\hat{R}_i(t) \\right)^2 $$ This formulation supports multiple loss types (MSE, MAE, soft L1, Cauchy, etc.) implemented in both submodules.","title":"Objective Function"},{"location":"Documentation/tfopt/index.html#constraints","text":"","title":"Constraints"},{"location":"Documentation/tfopt/index.html#-constraints-for-each-mrna-i","text":"$$ \\sum_{j \\in J_i} \\alpha_{i,j} = 1, \\quad 0 \\le \\alpha_{i,j} \\le 1 $$","title":"\u03b1-constraints (for each mRNA i):"},{"location":"Documentation/tfopt/index.html#-constraints-for-each-tf-j","text":"$$ \\sum_{q=0}^{K_j} \\beta_{q,j} = 1, \\quad -2 \\le \\beta_{q,j} \\le 2 $$ This ensures that weights are interpretable and stable.","title":"\u03b2-constraints (for each TF j):"},{"location":"Documentation/tfopt/index.html#optimization-problem-summary","text":"The final optimization problem is: $$ \\min_{{\\alpha,\\beta}} \\sum_i \\sum_t \\left( R_i(t) - \\sum_{j\\in J_i} \\alpha_{i,j} \\cdot TF_{i,j}(t) \\cdot \\left( \\beta_{0,j} + \\sum_k PSite_{k,j}(t) \\cdot \\beta_{k,j} \\right) \\right)^2 $$ subject to the constraints above. This enables estimation of regulatory influences in a biologically meaningful and data-driven manner.","title":"Optimization Problem Summary"},{"location":"Documentation/tfopt/index.html#submodules","text":"","title":"Submodules"},{"location":"Documentation/tfopt/index.html#evol-global-evolutionary-optimization","text":"Implements multi-objective optimization using pymoo (NSGA2, AGEMOEA, SMSEMOA) Evaluates tradeoffs between fit error, \u03b1-constraint violation, and \u03b2-constraint violation Outputs Excel summaries, static and interactive plots, and HTML reports","title":"evol/ \u2014 Global Evolutionary Optimization"},{"location":"Documentation/tfopt/index.html#local-constrained-local-optimization","text":"Implements deterministic solvers (e.g. SLSQP) Faster and more interpretable for small- to medium-scale systems Shares the same objective and constraint framework as evol Generates the same reports and plots as the global module","title":"local/ \u2014 Constrained Local Optimization"},{"location":"Documentation/tfopt/index.html#usage","text":"From one level top of project root: python -m phoskintime tfopt --mode evol or python -m phoskintime tfopt --mode local Output will be saved in structured folders, including Excel files, plots, and an aggregated HTML report.","title":"Usage"},{"location":"Documentation/utils/index.html","text":"Utils The utils module provides a set of helper scripts to streamline data processing, table generation, file organization, and report creation for the project. These utilities ensure consistent handling of outputs, formatting, and organization across the pipeline. Scripts Overview display.py Purpose : Handles data loading, output directory management, and report generation. Key Features : Ensures output directories exist. Loads data from Excel files. Merges observed and estimated data for analysis. Saves results to Excel with multiple sheets for parameters, errors, PCA, t-SNE, and sensitivity analysis. Generates a global HTML report summarizing results with plots and tables. tables.py Purpose : Generates hierarchical tables for alpha and beta values and saves them in LaTeX and CSV formats. Key Features : Processes alpha and beta values from Excel files. Creates hierarchical tables with multi-index columns for easy comparison. Saves tables as LaTeX and CSV files for further analysis. Generates a master LaTeX file to include all individual tables. latexit.py Purpose : Converts Excel data and PNG plots into LaTeX tables and figures for documentation. Key Features : Processes Excel sheets and generates LaTeX tables. Converts PNG plots into LaTeX figure blocks. Outputs a structured LaTeX file for integration into larger documents. Outputs Excel Files : Organized results with multiple sheets for parameters, errors, and analysis. LaTeX Files : Tables and figures for documentation. CSV Files : Processed data tables for further analysis. HTML Reports : Interactive summaries of results with plots and tables.","title":"Utils"},{"location":"Documentation/utils/index.html#utils","text":"The utils module provides a set of helper scripts to streamline data processing, table generation, file organization, and report creation for the project. These utilities ensure consistent handling of outputs, formatting, and organization across the pipeline.","title":"Utils"},{"location":"Documentation/utils/index.html#scripts-overview","text":"","title":"Scripts Overview"},{"location":"Documentation/utils/index.html#displaypy","text":"Purpose : Handles data loading, output directory management, and report generation. Key Features : Ensures output directories exist. Loads data from Excel files. Merges observed and estimated data for analysis. Saves results to Excel with multiple sheets for parameters, errors, PCA, t-SNE, and sensitivity analysis. Generates a global HTML report summarizing results with plots and tables.","title":"display.py"},{"location":"Documentation/utils/index.html#tablespy","text":"Purpose : Generates hierarchical tables for alpha and beta values and saves them in LaTeX and CSV formats. Key Features : Processes alpha and beta values from Excel files. Creates hierarchical tables with multi-index columns for easy comparison. Saves tables as LaTeX and CSV files for further analysis. Generates a master LaTeX file to include all individual tables.","title":"tables.py"},{"location":"Documentation/utils/index.html#latexitpy","text":"Purpose : Converts Excel data and PNG plots into LaTeX tables and figures for documentation. Key Features : Processes Excel sheets and generates LaTeX tables. Converts PNG plots into LaTeX figure blocks. Outputs a structured LaTeX file for integration into larger documents.","title":"latexit.py"},{"location":"Documentation/utils/index.html#outputs","text":"Excel Files : Organized results with multiple sheets for parameters, errors, and analysis. LaTeX Files : Tables and figures for documentation. CSV Files : Processed data tables for further analysis. HTML Reports : Interactive summaries of results with plots and tables.","title":"Outputs"}]}